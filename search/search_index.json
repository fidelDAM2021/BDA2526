{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CE IA i Big Data Curs 25/26","text":""},{"location":"#big-data-aplicat","title":"Big Data Aplicat","text":"<ul> <li>0. Presentaci\u00f3</li> <li>1. Introducci\u00f3 a Big Data</li> <li>2. Elements i arquitectura Big Data</li> <li>3.1 Rep\u00e0s Docker</li> <li>3.2 Docker Compose</li> <li>4.1 Introducci\u00f3 a Node-RED</li> <li>4.2 Node-RED intermedi</li> <li>4.3 Node-RED avan\u00e7at</li> <li>4.4 Node-RED dashboards</li> <li>4.5 Formularis en Node-RED</li> <li>5. Fiware. Orion. Context Broker</li> <li>6. MQTT</li> <li>7.1 Stack ELK. Introducci\u00f3</li> <li>7.2 Stack ELK pr\u00e0ctic</li> </ul>"},{"location":"documents/","title":"Presentaci\u00f3 del m\u00f2dul Big Data Aplicat (BDA)","text":"Professor: Fidel Oltra Contacte: jf.oltralandete@edu.gva.es"},{"location":"documents/#descripcio-del-modul-bda","title":"Descripci\u00f3 del m\u00f2dul BDA","text":"<p>El m\u00f2dul de Big Data Aplicat (BDA) forma part del Curs d'Especialitzaci\u00f3 en IA i Big Data (IABD) i t\u00e9 una durada de 120 hores. El m\u00f2dul est\u00e0 dissenyat per proporcionar als estudiants els coneixements i habilitats necessaris per gestionar, processar i analitzar grans volums de dades utilitzant tecnologies i eines de Big Data.</p>"},{"location":"documents/#temporalitzacio","title":"Temporalitzaci\u00f3","text":"<p>4 hores a la setmana al llarg de 30 setmanes.</p> <p>Dilluns: 16:25 - 18:15  Dimecres: 16:25 - 18:15</p>"},{"location":"documents/#objectius","title":"Objectius","text":"<p>Els objectius generals del Curs d'Especialitzaci\u00f3 en IA i Big Data se concreten, en cada m\u00f2dul, en els seus Resultats d'Aprenentatge (RA) i Criteris d'Avaluaci\u00f3 (CA) que se detallen en la programaci\u00f3 del m\u00f2dul.</p> <p>Els Resultats d'Aprenentatge (RA) espec\u00edfics del m\u00f2dul BDA s\u00f3n:</p> <ul> <li> <p>RA1: Gestiona solucions a problemes proposats, utilitzant sistemes d\u2019emmagatzematge i eines associades al centre de dades.</p> </li> <li> <p>RA2: Gestiona sistemes d\u2019emmagatzematge i l\u2019ampli ecosistema al voltant facilitant el processament de grans quantitats de dades sense errors i de forma r\u00e0pida.</p> </li> <li> <p>RA3: Genera mecanismes d\u2019integritat de les dades, comprovant\u2010ne el manteniment en els sistemes de fitxers distribu\u00efts i valorant la sobrec\u00e0rrega que comporta en el tractament de les dades.</p> </li> <li> <p>RA4: Realitza el seguiment de la monitoritzaci\u00f3 d\u2019un sistema, assegurant la fiabilitat i l\u2019estabilitat dels serveis que es proveeixen.</p> </li> <li> <p>RA5: Valida les t\u00e8cniques de Big Data per transformar una gran quantitat de dades en informaci\u00f3 significativa, facilitant la presa de decisions de negocis.</p> </li> </ul>"},{"location":"documents/#competencies-professionals","title":"Compet\u00e8ncies professionals","text":"<ul> <li> <p>b) Desenvolupar i implementar sistemes d\u2019intel\u00b7lig\u00e8ncia artificial que faciliten la presa de decisions \u00e0gils dins d\u2019un negoci gestionant i explotant dades massives.</p> </li> <li> <p>c) Gestionar la transformaci\u00f3 digital necess\u00e0ria a les organitzacions per a la consecuci\u00f3 de l\u2019efici\u00e8ncia empresarial mitjan\u00e7ant el tractament de dades.</p> </li> <li> <p>h) Integrar sistemes d\u2019explotaci\u00f3 de grans volums de dades aplicant solucions de Big Data.</p> </li> <li> <p>i) Implantar les funcionalitats, processos i sistemes de decisions empresarials aplicant\u2010hi t\u00e8cniques de Big Data.</p> </li> <li> <p>j) Executar el sistema d\u2019explotaci\u00f3 de dades segons les necessitats d\u2019\u00fas i les condicions de seguretat establertes assegurant el compliment dels principis legals i \u00e8tics.</p> </li> <li> <p>k) Configurar les eines que es fan servir per construir solucions Big Data i d\u2019Intel\u00b7lig\u00e8ncia Artificial.</p> </li> <li> <p>l) Gestionar de manera eficient les dades, la informaci\u00f3 i la seua representaci\u00f3 per transformar\u2010les en coneixement.</p> </li> </ul>"},{"location":"documents/#continguts","title":"Continguts","text":"<p>Els continguts d\u2019aquest m\u00f2dul professional, segons estableix el curr\u00edculum vigent, s\u00f3n els seg\u00fcents:</p> <ul> <li> <p>C1. Gesti\u00f3 de solucions amb sistemes d\u2019emmagatzematge i eines del centre de dades per resoldre problemes.</p> </li> <li> <p>C2. Gesti\u00f3 de sistemes d\u2019emmagatzematge i ecosistemes Big Data.</p> </li> <li> <p>C3. Generaci\u00f3 de mecanismes d\u2019integritat de les dades. Comprovaci\u00f3 de manteniment de sistemes de fitxers.</p> </li> <li> <p>C4. Monitoritzaci\u00f3, optimitzaci\u00f3 i soluci\u00f3 de problemes.</p> </li> <li> <p>C5. Validaci\u00f3 de t\u00e8cniques Big Data en la presa de decisions a intel\u00b7lig\u00e8ncia de negocis BI.</p> </li> </ul>"},{"location":"documents/#unitats-de-programacio","title":"Unitats de programaci\u00f3","text":"<p>UP01: Introducci\u00f3 a Big Data. Arquitectura. Entorn de treball. UP02: Node-RED UP03: Fiware. Topologia de les dades. Br\u00f3kers. UP04: MQTT. UP05: Stack ELK. UP06: Altres bases de dades NoSQL. UP07: Desenvolupament. Visualitzaci\u00f3.</p>"},{"location":"documents/#metodologia","title":"Metodologia","text":"<ul> <li> <p>Apunts, exemples, pr\u00e0ctiques i documentaci\u00f3 en la plataforma Aules.</p> </li> <li> <p>Aprenentatge basat en Reptes (ABR) i Projectes (ABP), mitjan\u00e7ant el desenvolupament primer de reptes m\u00e9s concrets i, m\u00e9s endavant, de projectes intermodulars reals complets, proposats, sempre que siga possible, en col\u00b7laboraci\u00f3 amb empreses i organitzacions.</p> </li> <li> <p>Aprenentatge col\u00b7laboratiu, en els propis projectes i reptes, que s'abordaran mitjan\u00e7ant el treball en equip i amb eines de gesti\u00f3 de projectes.</p> </li> <li> <p>Classe invertida (Flipped Classroom), on l'alumnat treballa els continguts pel seu compte, i aprofita els problemes que va trobant al llarg del desenvolupament dels projectes i reptes, o en la resoluci\u00f3 d'exercicis, per preguntar a l'aula els seus dubtes. La classe per tant esdev\u00e9 un espai de resoluci\u00f3 de dubtes i d'aplicaci\u00f3 pr\u00e0ctica dels continguts.</p> </li> </ul>"},{"location":"u01/","title":"Introducci\u00f3 a Big Data","text":""},{"location":"u01/#que-es-big-data","title":"Qu\u00e8 \u00e9s Big Data?","text":"<p>Big Data \u00e9s un terme que fa refer\u00e8ncia a la gesti\u00f3 i an\u00e0lisi de volums de dades que, pel seu tamany, complexitat o velocitat d'entrada, no poden ser tractats de manera convencional amb eines tradicionals. Aquestes dades poden ser de diferents tipus, com ara text, imatges, \u00e0udio, v\u00eddeo, etc. </p> <p>El terme Big Data s'associa normalment a les anomenades \"tres V\" (que de vegades s\u00f3n 4):</p> <ul> <li> <p>Volum: Fa refer\u00e8ncia a la quantitat de dades que es generen i emmagatzemen. A m\u00e9s quantitat, m\u00e9s necessitem de sistemes diferents als tradicionals.</p> </li> <li> <p>Velocitat: Fa refer\u00e8ncia a la rapidesa amb qu\u00e8 es generen i es processen les dades. Amb el creixement de l'anomenat IOT (Internet de les Coses) les dades arriben quasi de manera instant\u00e0nia i s'han de llegir i tractar de manera igualment r\u00e0pida.</p> </li> <li> <p>Varietat: Fa refer\u00e8ncia a la diversitat de formats en qu\u00e8 es poden presentar les dades. La informaci\u00f3 pot arribar des de fonts molt diferents i amb formats diversos: text no estructurat, imatges, \u00e0udio, correus electr\u00f2nics, etc.</p> </li> <li> <p>Veracitat: Fa refer\u00e8ncia a la qualitat de les dades. Les dades poden ser incorrectes, incompletes o no actualitzades. Aix\u00f2 pot ser un problema a l'hora de prendre decisions basades en aquestes dades.</p> </li> </ul> <p></p>"},{"location":"u01/#per-que-es-important-el-big-data","title":"Per qu\u00e8 \u00e9s important el Big Data?","text":"<p>El Big Data \u00e9s important perqu\u00e8 permet a les empreses i organitzacions millorar la seva presa de decisions, ja que permet analitzar grans quantitats de dades i extreure'n coneixement. Aix\u00f2 pot ser \u00fatil per a moltes coses, com ara:</p> <ul> <li>Millorar la presa de decisions: Les empreses poden utilitzar les dades per prendre decisions m\u00e9s informades i basades en evid\u00e8ncies.</li> <li>Millorar la relaci\u00f3 amb els clients: Les empreses poden utilitzar les dades per entendre millor les necessitats dels clients i oferir-los productes i serveis m\u00e9s personalitzats.</li> <li>Millorar l'efici\u00e8ncia operativa: Les empreses poden utilitzar les dades per identificar \u00e0rees on poden millorar l'efici\u00e8ncia i reduir els costos.</li> <li>Identificar oportunitats de negoci: Les empreses poden utilitzar les dades per identificar noves oportunitats de negoci i millorar la seva competitivitat.</li> </ul>"},{"location":"u01/#exemples-de-sectors-o-situacions-on-es-aconsellable-utilitzar-big-data","title":"Exemples de sectors o situacions on \u00e9s aconsellable utilitzar Big Data","text":"<p>El Big Data \u00e9s \u00fatil en molts sectors i situacions diferents. Algunes de les \u00e0rees on el Big Data pot ser especialment \u00fatil s\u00f3n:</p> <ul> <li>Salut: El Big Data pot ser utilitzat per millorar el diagn\u00f2stic i el tractament de malalties, aix\u00ed com per predir epid\u00e8mies i identificar tend\u00e8ncies de salut.</li> <li>Finances: El Big Data pot ser utilitzat per predir tend\u00e8ncies del mercat, identificar oportunitats d'inversi\u00f3 i detectar frau.</li> <li>Xarxes socials: El Big Data pot ser utilitzat per analitzar el comportament dels usuaris en les xarxes socials i millorar la segmentaci\u00f3 dels clients, identificar oportunitats de negoci, millorar la relaci\u00f3 amb els clients o possibles clients, etc.</li> <li>Transport: El Big Data pot ser utilitzat per millorar la planificaci\u00f3 del transport, predir la congesti\u00f3 del tr\u00e0nsit, optimitzar les rutes de transport, etc.</li> <li>IoT: El Big Data pot ser utilitzat per analitzar les dades generades per dispositius connectats a Internet i millorar la seva efici\u00e8ncia i seguretat, aprofitant al m\u00e0xim la informaci\u00f3 rebuda.</li> </ul> <p>Aix\u00f2 s\u00f3n nom\u00e9s alguns exemples, per\u00f2 el Big Data pot ser \u00fatil en molts altres sectors i situacions.</p>"},{"location":"u01/#conceptes-relacionats-amb-big-data","title":"Conceptes relacionats amb Big Data","text":"<p>Alguns conceptes relacionats amb els sistemes de Big Data s\u00f3n:</p> <ul> <li>Escalabilitat (horitzontal vs vertical)</li> <li>Divideix i vencer\u00e0s (MapReduce)</li> <li>SQL vs NoSQL</li> <li>Cloud Computing (on premise)</li> </ul>"},{"location":"u01/#escalabilitat-horitzontal-vs-vertical","title":"Escalabilitat horitzontal vs vertical","text":"<ul> <li> <p>Escalabilitat vertical: Consisteix en augmentar la capacitat d'un sistema afegint m\u00e9s recursos a un \u00fanic node. Aix\u00f2 pot ser \u00fatil per a sistemes que no poden ser dividits en parts m\u00e9s petites, per\u00f2 t\u00e9 un l\u00edmit en la quantitat de recursos que es poden afegir a un \u00fanic node. </p> </li> <li> <p>Escalabilitat horitzontal: Consisteix en augmentar la capacitat d'un sistema afegint m\u00e9s nodes al sistema. Aix\u00f2 permet augmentar la capacitat del sistema de manera m\u00e9s flexible i escalable, ja que es poden afegir m\u00e9s nodes a mesura que es necessiti.</p> </li> </ul> <p>En un sistema que escala verticalment, s'han d'ampliar els components del sistema (CPU, mem\u00f2ria, disc dur, etc.) per augmentar la capacitat del sistema. Esta soluci\u00f3 \u00e9s cara i t\u00e9 l\u00edmits. En canvi, en un sistema que escala horitzontalment, podem simplement afegir o treure nodes al sistema per augmentar o disminuir la seua capacitat. L'escalabilitat vertical \u00e9s m\u00e9s econ\u00f2mica i no t\u00e9 l\u00edmits mentre puguem continuar afegint nodes. </p> <p></p> <p>En general, els sistemes de Big Data utilitzen l'escalabilitat horitzontal per aconseguir la capacitat necess\u00e0ria per processar grans quantitats de dades.</p>"},{"location":"u01/#divideix-i-venceras-mapreduce","title":"Divideix i vencer\u00e1s (MapReduce)","text":"<p>MapReduce \u00e9s un model de programaci\u00f3 i un sistema de processament distribu\u00eft dissenyat per processar grans quantitats de dades de manera eficient. El model de programaci\u00f3 MapReduce consisteix en dues fases:</p> <ul> <li>Map: En aquesta fase, les dades s\u00f3n dividides en parts m\u00e9s petites i processades de manera paral\u00b7lela i distribu\u00efda en diferents nodes del sistema.</li> <li>Reduce: En aquesta fase, els resultats de la fase Map s\u00f3n combinats i processats per obtenir el resultat final.</li> </ul> <p>El model de programaci\u00f3 MapReduce \u00e9s molt eficient per processar grans quantitats de dades de manera distribu\u00efda i escalable. Aquest model \u00e9s utilitzat en molts sistemes de Big Data, com ara Hadoop i Spark. A m\u00e9s permet redistribuir les dades entre les unitats de treball en cas de fallada d'un node.</p> <p></p>"},{"location":"u01/#sql-vs-nosql","title":"SQL vs NoSQL","text":"<ul> <li>SQL: SQL (Structured Query Language) \u00e9s un llenguatge de programaci\u00f3 utilitzat per gestionar bases de dades relacionals. SQL \u00e9s un llenguatge molt potent i flexible que permet realitzar consultes complexes i eficients sobre les dades. En general s'utilitza la categoria \"bases de dades SQL\" per fer refer\u00e8ncia a les bases de dades relacionals.</li> </ul> <p>Exemples de bases de dades SQL: </p> <pre><code>- MySQL / MariaDB\n- PostgreSQL\n- Oracle\n- SQL Server\n</code></pre> <p>Avantatges de les bases de dades SQL:</p> <pre><code>- Estructura de dades clara i definida\n- Permeten relacions entre les dades\n- Suport per a transaccions ACID (Atomicitat, Consist\u00e8ncia, A\u00efllament, Durabilitat)\n- Suport per a consultes SQL\n- Asseguren la integritat i consist\u00e8ncia de les dades\n</code></pre> <ul> <li>NoSQL: NoSQL \u00e9s un terme gen\u00e8ric que fa refer\u00e8ncia a bases de dades no relacionals. Les bases de dades NoSQL s\u00f3n dissenyades per gestionar grans quantitats de dades de manera eficient i escalable. S'utilitzen sovint en sistemes de Big Data per emmagatzemar i processar grans quantitats de dades. A difer\u00e8ncia de les bases de dades SQL o relacionals, en les bases de dades NoSQL s'ofereixen diferents models de dades i no cal un esquema predefinit per establir com s'estructuran i relaciona la informaci\u00f3.</li> </ul> <p>Exemples de bases de dades NoSQL:</p> <pre><code>- MongoDB\n- Cassandra\n- HBase\n- Redis\n- Elasticsearch\n- CouchDB\n- Neo4j\n</code></pre> <p>Avantatges de les bases de dades NoSQL:</p> <pre><code>- Escalabilitat horitzontal\n- Flexibilitat en l'emmagatzematge de dades\n- Rendiment i velocitat\n- Suport per a dades no estructurades\n- Suport per a sistemes distribu\u00efts\n</code></pre> <p>Hem de tenir en compte que en les bases de dades NoSQL les dades no tenen una estructura fixa i definida, i \u00e9s m\u00e9s complicat establir relacions entre les dades. Aix\u00f2 pot ser un avantatge o un inconvenient segons les necessitats del projecte.</p> <p>Teorema CAP </p> <p>El teorema CAP \u00e9s un principi fonamental en el disseny de sistemes distribu\u00efts que estableix que \u00e9s impossible garantir simult\u00e0niament Consist\u00e8ncia, Disponibilitat i Toler\u00e0ncia a particions en un sistema distribu\u00eft. Aix\u00f2 significa que en un sistema distribu\u00eft nom\u00e9s es poden garantir dos dels tres aspectes abans esmentats.</p> <p>https://www.ibm.com/es-es/topics/cap-theorem</p> <p></p> <p>BBDD CP (Consistency and Partition Tolerance)</p> <p>Ofereixen consist\u00e8ncia i toler\u00e0ncia a la partici\u00f3 sacrificant la disponibilitat. Aix\u00f2 significa que en cas de partici\u00f3 de la xarxa, el sistema es mant\u00e9 consistent, per\u00f2 pot ser que no estiga disponible per a totes les peticions perqu\u00e8 els nodes no consistents no estaran disponibles fins que se solucione el problema. Un exemple seria MongoDB.</p> <p>BBDD AP (Availability and Partition Tolerance)</p> <p>Ofereixen disponibilitat i toler\u00e0ncia a la partici\u00f3 sacrificant la consist\u00e8ncia. Aix\u00f2 significa que en cas de partici\u00f3 de la xarxa, el sistema es mant\u00e9 disponible per a totes les peticions, per\u00f2 pot ser que no estiga consistent fins que se solucione el problema perqu\u00e8 uns nodes poden tornar versions m\u00e9s antigues de les dades. Un exemple seria Cassandra.</p> <p>BBDD CA (Consistency and Availability)</p> <p>Ofereixen consist\u00e8ncia i disponibilitat en tots els nodes. Ara b\u00e9, no funcionar\u00e0 b\u00e9 si hi ha una partici\u00f3 entre 2 o m\u00e9s nodes del sistema, de manera que la toler\u00e0ncia a la partici\u00f3 no est\u00e0 garantida. Un exemple seria una base de dades relacional.</p> <p>https://www.genbeta.com/desarrollo/nosql-clasificacion-de-las-bases-de-datos-segun-el-teorema-cap</p>"},{"location":"u01/#models-nosql","title":"Models NoSQL","text":"<p>Dins de les tecnologies NoSQL hi ha diferents tipus de models:</p> <ul> <li>Document: Aquest model emmagatzema les dades en documents en un format similar a un JSON o XML. Cada document pot tenir diferents camps i valors, i no cal un esquema predefinit per definir com s'estructuren les dades. Exemples: MongoDB, CouchDB.</li> <li>Clau-valor: Aquest model emmagatzema les dades en parelles clau-valor, on cada clau est\u00e0 associada a un valor. Aquest model \u00e9s molt eficient per recuperar dades per clau. Exemples: Redis, DynamoDB.</li> <li>Columnar: Aquest model emmagatzema les dades en columnes en lloc de files, el que permet recuperar dades de manera eficient. Aquest model \u00e9s \u00fatil per a bases de dades anal\u00edtiques. Exemples: Cassandra, HBase.</li> <li>Graf: Aquest model emmagatzema les dades com a nodes i relacions entre els nodes. Aquest model \u00e9s \u00fatil per a bases de dades que necessiten representar relacions complexes entre les dades. Exemples: Neo4j, ArangoDB.</li> </ul> <p>Els tres darrers models que hem enumerat, el Clau-valor, el Columnar i el Graf, s\u00f3n models d'agregaci\u00f3.</p> <p>Models d'agregaci\u00f3</p> <p>Els models d'agregaci\u00f3 se basen en la noci\u00f3 d'agregaci\u00f3: una col\u00b7lecci\u00f3 d'objectes/entitats relacionats que volem tractar com una \u00fanica entitat a efectes de acc\u00e9s, manipulaci\u00f3, control de la consist\u00e8ncia i concurr\u00e8ncia, i distribuci\u00f3 de les dades. En les bases de dades relacionals podem fer JOIN per recuperar informaci\u00f3 de les diferents taules on est\u00e0 la informaci\u00f3 que hem repartit entre elles. En les bases de dades NoSQL, com no tenim relacions, hem de fer servir models d'agregaci\u00f3 per aconseguir el mateix efecte. </p> <p>T\u00e8cniques d'agregaci\u00f3 m\u00e9s comuns</p> <ul> <li>Embedding: En aquest model, les dades relacionades s'emmagatzemen juntes en un \u00fanic document. Aix\u00f2 permet recuperar les dades relacionades amb una sola consulta. Aquest model \u00e9s \u00fatil per dades que es consulten juntes amb freq\u00fc\u00e8ncia.</li> <li>Referencing: En aquest model, les dades relacionades s'emmagatzemen en documents separats i s'estableixen relacions entre els documents mitjan\u00e7ant refer\u00e8ncies. Aix\u00f2 permet gestionar les dades relacionades de manera independent i mantenir la consist\u00e8ncia de les dades. Aquest model \u00e9s \u00fatil per dades que es consulten de manera independent.</li> </ul> <p>El model Clau-valor tamb\u00e9 se considera un model d'agregaci\u00f3. La clau s'extreu del domini de l'aplicaci\u00f3 (un nom d'usuari, una adre\u00e7a de correu electr\u00f2nic, un NIF...), mentre que el valor associat en general pot agafar qualsevol format (pot ser un bloc de dades, una col\u00b7lecci\u00f3, un objecte...) i la seua interpretaci\u00f3 ser\u00e0 responsabilitat de l'aplicaci\u00f3.</p> <p></p> <p>Model d'agregaci\u00f3 documental </p> <p>\u00c9s com una extensi\u00f3 del model Clau-valor. Els documents tenen una estructura interna (document) que en general estar\u00e0 formada per combinacions d'estructures Clau-valor. Una estructura aix\u00ed facilita l'acc\u00e9s a les dades des de les aplicacions, per\u00f2 \u00e9s menys flexible que el model Clau-valor pur ja que les dades estan m\u00e9s estructurades. A m\u00e9s, les consultes s\u00f3n m\u00e9s complexes.</p> <p>Exemples d'este model s\u00f3n CouchDB o Elastic.</p> <p>Veiem per exemple un carro de la compra utilitzant un model documental:</p> <p></p> <p>Model d'agregaci\u00f3 per columnes</p> <p>Apareix agafant com a precursor el model BigTable de Google. El model t\u00e9 forma de matriu, per\u00f2 no a l'estil d'una base de dades relacional. Ac\u00ed les files s\u00f3n agregacions de dades accessibles mitjan\u00e7ant una clau, i les columnes representen atributs de l'agregaci\u00f3 en format tripleta nom-valor-timestamp. D'alguna manera \u00e9s com girar 90 graus a l'esquerra un model documental. </p> <p></p> <p>\u00c9s un model eficient en sistemes distribu\u00efts, ja que permet distribuir les dades per columnes i no per files. Aix\u00f2 permet escalar les dades de manera independent i distribu\u00efda. Un exemple d'este model \u00e9s Cassandra.</p> <p>Avantatges dels models d'agregaci\u00f3</p> <ul> <li>Efici\u00e8ncia: Permeten recuperar les dades relacionades amb una sola consulta, el que millora el rendiment de l'aplicaci\u00f3.</li> <li>Escalabilitat: Permeten escalar les dades relacionades de manera independent i distribu\u00efda.</li> </ul> <p>Problema dels models d'agregaci\u00f3</p> <p>El principal problema \u00e9s que poden haver objectes repartits entre diferents agregats. Hem de prendre mesures per garantir la consist\u00e8ncia de les dades en aquests casos.</p>"},{"location":"u01/#cloud-computing-on-premise","title":"Cloud Computing (on premise)","text":"<p>El Cloud Computing \u00e9s un model de distribuci\u00f3 de recursos inform\u00e0tics que permet l'acc\u00e9s a serveis i recursos a trav\u00e9s d'Internet. Aquest model ofereix una gran flexibilitat i escalabilitat, ja que els recursos es poden ajustar segons les necessitats de l'usuari.</p> <p>En el context del Big Data, el Cloud Computing juga un paper important. Les empreses i organitzacions que treballen amb grans volums de dades poden utilitzar el Cloud Computing per emmagatzemar, processar i analitzar aquestes dades de manera eficient i escalable. En el cas de Cloud de tercers, el prove\u00efdor de serveis Cloud es fa c\u00e0rrec de la infraestructura i els recursos necessaris per processar les dades, la qual cosa permet a les empreses centrar-se en l'an\u00e0lisi de les dades i la presa de decisions. El cost inicial no \u00e9s molt alt i l'obsolesc\u00e8ncia i la escalabilitat s\u00f3n responsabilitat del prove\u00efdor.</p> <p>El Cloud Computing utilitza normalment un n\u00favol de tercers. Tot i aix\u00f2, una opci\u00f3 popular en el Cloud Computing \u00e9s el model \"on premise\". Aquest model permet a les empreses tenir els seus propis servidors f\u00edsics i infraestructura de Cloud Computing dins de les seves pr\u00f2pies instal\u00b7lacions. Aix\u00f2 ofereix un major control i seguretat sobre les dades, ja que no es dep\u00e8n de tercers per gestionar-les. L'escalabilitat pot ser vertical (afegir m\u00e9s recursos a un \u00fanic node) o tamb\u00e9 horitzontal (comprar m\u00e9s servidors). El cost inicial \u00e9s m\u00e9s alt que en el model de n\u00favol p\u00fablic, encara que a llarg termini pot ser m\u00e9s econ\u00f2mic en certs casos perqu\u00e8 no se paga per \u00fas una vegada feta la inversi\u00f3 inicial.</p> <p>Utilitzar el Cloud Computing \"on premise\" en el context del Big Data permet a les empreses tenir un acc\u00e9s r\u00e0pid i eficient a les seves dades, aix\u00ed com una gran capacitat de processament i emmagatzematge. A m\u00e9s, aquest model permet una millor integraci\u00f3 amb altres sistemes i aplicacions empresarials. El model ofereix flexibilitat, escalabilitat i control sobre les dades.</p>"},{"location":"u01/#tipus-de-dades","title":"Tipus de dades","text":"<p>Quan treballem amb tecnologies Big Data podem fer \u00fas de dades que arriben des de diferents fonts i en diferents formats. En general, podem classificar les dades d'entrada en dues categories principals: estructurades, semiestructurades i no estructurades.</p>"},{"location":"u01/#dades-estructurades","title":"Dades estructurades","text":"<p>Les dades estructurades s\u00f3n dades de les quals coneixem el format. No necess\u00e0riament han de ser bases de dades relacionals, podem ser no relacionals amb un format definit i fixe, fulls de c\u00e0lcul, documents XML o JSON, etc.</p>"},{"location":"u01/#dades-semiestructurades","title":"Dades semiestructurades","text":"<p>Les dades semiestructurades s\u00f3n dades que tenen certa estructura i format, per\u00f2 eixe format pot variar d'un element a un altre. Un exemple d'aquest tipus de dades s\u00f3n els documents XML o JSON, on cada element pot tenir diferents camps i valors.</p>"},{"location":"u01/#dades-no-estructurades","title":"Dades no estructurades","text":"<p>Les dades no estructurades s\u00f3n dades de les quals no coneixem el format. Poden ser imatges, \u00e0udio, v\u00eddeo, text sense format fixe, etc.</p>"},{"location":"u01/#utilitzacio-de-les-dades","title":"Utilitzaci\u00f3 de les dades","text":""},{"location":"u01/#hipotesis-de-causalitat","title":"Hip\u00f2tesis de causalitat","text":"<p>Les hip\u00f2tesis de causalitat s\u00f3n afirmacions que estableixen una relaci\u00f3 de causa-efecte entre dos o m\u00e9s variables. Aquestes hip\u00f2tesis s\u00f3n importants per entendre com les dades estan relacionades i com podem utilitzar-les per prendre decisions.</p> <p>Les hip\u00f2tesis de causalitat s'utilitzen en estad\u00edstica. Se validen o se rebutjen en funci\u00f3 de les an\u00e0lisis fetes a diferents mostres de dades, i dels resultats que s'hagen obt\u00e9s.</p> <p>Un exemple: </p>"},{"location":"u01/#analisi-predictiu","title":"An\u00e0lisi predictiu","text":"<p>L'an\u00e0lisi predictiu \u00e9s una t\u00e8cnica que utilitza dades hist\u00f2riques per predir resultats futurs. Aquesta t\u00e8cnica s'utilitza en molts \u00e0mbits, com ara el m\u00e0rqueting, la salut, les finances, etc. L'an\u00e0lisi predictiu es basa en algoritmes d'aprenentatge autom\u00e0tic i intel\u00b7lig\u00e8ncia artificial per predir resultats futurs a partir de dades hist\u00f2riques.</p> <p>En Intel\u00b7lig\u00e8ncia Artificial en general no se formulen hip\u00f2tesis, sino que se busquen correlacions, tend\u00e8ncies o patrons. </p>"},{"location":"u01/#analisi-descriptiu","title":"An\u00e0lisi descriptiu","text":"<p>L'an\u00e0lisi descriptiu \u00e9s una t\u00e8cnica que utilitza dades per descriure i resumir les caracter\u00edstiques d'una poblaci\u00f3 o mostra. Aquesta t\u00e8cnica s'utilitza per entendre millor les dades i identificar tend\u00e8ncies, patrons i relacions entre les dades.</p>"},{"location":"u01/#tipus-de-processament","title":"Tipus de processament","text":"<p>Per processar les dades tenim dos formes principals de fer-ho: batch processing i stream processing.</p>"},{"location":"u01/#batch-processing","title":"Batch processing","text":"<p>El batch processing \u00e9s un m\u00e8tode de processament en qu\u00e8 les dades s\u00f3n processades en blocs o lots. Aquest m\u00e8tode \u00e9s \u00fatil per processar grans quantitats de dades de manera eficient i escalable. Els processos de batch processing s\u00f3n normalment planificats i executats en intervals regulars, com ara cada dia o cada setmana, en forma de tasques programades.</p> <p>Algunes caracter\u00edstiques principals del batch processing:</p> <ul> <li>No requereix interacci\u00f3 amb els usuaris</li> <li>\u00c9s ideal per a tasques repetitives i previsibles</li> <li>\u00c9s \u00fatil per processar grans quantitats de dades</li> <li>Pot ser m\u00e9s eficient que el processament en temps real per a tasques que no requereixen una resposta immediata</li> <li>S'executa regularment (cada x temps, una vegada al dia, etc.)</li> </ul> <p>Un exemple de batch processing podria ser l'enviament de correus electr\u00f2nics autom\u00e0tics a tots els clients que han realitzat una compra en una botiga en l\u00ednia cada dia a les 12:00, una felicitaci\u00f3 d'aniversari a tots els clients que compleixen anys cada dia a les 9:00, etc.</p>"},{"location":"u01/#stream-processing","title":"Stream processing","text":"<p>El stream processing \u00e9s un m\u00e8tode de processament en qu\u00e8 les dades s\u00f3n processades a mesura que arriben. Aquest m\u00e8tode \u00e9s \u00fatil per processar dades en temps real i respondre r\u00e0pidament a canvis en les dades. Els processos de stream processing s\u00f3n normalment continuats i en temps real, i poden ser utilitzats per a tasques com ara la detecci\u00f3 d'anomalies, la monitoritzaci\u00f3 de sistemes, la generaci\u00f3 de recomanacions, etc.</p> <p>Caracter\u00edstiques principals:</p> <ul> <li>Les dades s\u00f3n processades a mesura que arriben</li> <li>Les dades s'estan processant continuament</li> <li>\u00c9s \u00fatil per a tasques que requereixen una resposta immediata</li> </ul> <p>Un exemple de stream processing podria ser la detecci\u00f3 d'anomalies en temps real en un sistema de control de tr\u00e0nsit, la generaci\u00f3 de recomanacions en temps real en una botiga en l\u00ednia, la recepci\u00f3 i an\u00e0lisi d'informaci\u00f3 que arriba via MQTT, etc.</p> <p>MQTT \u00e9s un protocol de missatgeria que s'utilitza per a la comunicaci\u00f3 entre dispositius IoT. Aquest protocol permet enviar i rebre missatges en temps real i \u00e9s molt eficient per a la comunicaci\u00f3 entre dispositius connectats a Internet. M\u00e9s informaci\u00f3 a https://mqtt.org/.</p>"},{"location":"u02/","title":"Elements i arquitectura d'una plataforma Big Data","text":""},{"location":"u02/#plataformes-big-data","title":"Plataformes Big Data","text":"<p>Una Plataforma Big Data \u00e9s un sistema capa\u00e7 de gestionar i processar grans volums de dades. Algunes caracter\u00edstiques importants (encara que no imprescindibles) d'una plataforma Big Data s\u00f3n:</p> <ul> <li>Computaci\u00f3 en temps real</li> <li>Escalabilitat (Cloud Computing, processament distribu\u00eft)</li> <li>Utilitzaci\u00f3 de solucions de Intel\u00b7lig\u00e8ncia Artificial per fer simulacions i predicci\u00f3 de resultats</li> <li>Suport de m\u00faltiples fonts i tipus de dades (estructurades, semiestructurades i no estructurades)</li> <li>En general, basada en tecnologies de codi obert i en certs est\u00e0ndards</li> </ul> <p>Hadoop est\u00e0 considerada com la primera plataforma Big Data generalista. Va ser creada per Yahoo! i est\u00e0 basada en el paper de Google sobre el sistema de fitxers distribu\u00eft GFS i el sistema de processament de dades MapReduce.</p> <p>M\u00e9s informaci\u00f3 sobre Hadoop</p>"},{"location":"u02/#arquitectura-big-data","title":"Arquitectura Big Data","text":"<p>Un model informacional tradicional en una organitzaci\u00f3 es basa en una arquitectura de quatre capes:</p> <ul> <li>Sistemes operacionals: una p\u00e0gina web, un ERP, un CRM, etc. Qualsevol font de dades de l'organitzaci\u00f3.</li> <li>ETL: proc\u00e9s d'extracci\u00f3, transformaci\u00f3, neteja i c\u00e0rrega de dades.</li> <li>Sistemes informacionals: datawarehouses, datamarts, etc. Bases de dades en general.</li> <li>Eines d'an\u00e0lisi i visualitzaci\u00f3: eines de BI, dashboards, informes, etc.</li> </ul> <p>Les arquitectures Big Data venen a solucionar alguns dels problemes dels sistemes tradicionals, com ara:</p> <ul> <li>La dificultat per a gestionar grans volums de dades.</li> <li>La dificultat per a gestionar dades no estructurades.</li> <li>La dificultat per a gestionar dades en temps real.</li> <li>La dificultat per a integrar dades de m\u00faltiples fonts.</li> </ul> <p>Una arquitectura Big Data, com veurem a continuaci\u00f3, est\u00e0 formada per diferents capes que permeten gestionar i processar grans volums de dades. El concepte de Data Warehouse evoluciona cap al concepte de Data Lake, on es poden emmagatzemar dades en el seu format original (estiguen estructurades o no), sense necessitat de transformar-les pr\u00e8viament. Aix\u00f2 permet una major flexibilitat i agilitat en el processament de les dades. El processament o la transformaci\u00f3 de les dades se pot fer en el moment que es necessiten, i no abans.</p> <p>Eixa transformaci\u00f3 de l'emmagatzematge de les dades, juntament amb les diferents t\u00e8cniques i eines de processament de dades espec\u00edfiques per a Big Data, permeten una gesti\u00f3 m\u00e9s eficient, \u00e0gil i escalable.</p>"},{"location":"u02/#on-premise-vs-cloud","title":"On-premise vs Cloud","text":"<p>Les plataformes Big Data es poden implementar de dues maneres principals:</p> <ul> <li>On-premise: La plataforma es desplega en els servidors de l'organitzaci\u00f3. Aquesta opci\u00f3 permet un major control sobre les dades i la seguretat, per\u00f2 requereix una inversi\u00f3 inicial m\u00e9s gran i un manteniment continu.</li> <li>Cloud: La plataforma es desplega en servidors al n\u00favol. Aquesta opci\u00f3 permet una major escalabilitat i flexibilitat, ja que es poden afegir o eliminar recursos segons les necessitats. A m\u00e9s, no requereix una inversi\u00f3 inicial tan gran, ja que es paga per \u00fas.</li> <li>H\u00edbrida: Una combinaci\u00f3 de les dues opcions anteriors. Algunes dades es poden emmagatzemar i processar en els servidors de l'organitzaci\u00f3, mentre que altres dades es poden emmagatzemar i processar en el n\u00favol. Aquesta opci\u00f3 permet un major control sobre les dades m\u00e9s sensibles, mentre que es pot aprofitar la flexibilitat i escalabilitat del n\u00favol per a altres dades.</li> </ul> <p>Segur que heu escoltat conceptes com:</p> <ul> <li>IaaS (Infrastructure as a Service): Prove\u00efment d'infraestructura inform\u00e0tica (servidors, emmagatzematge, xarxes, etc.) com un servei. L'organitzaci\u00f3 gestiona el sistema operatiu, les aplicacions i les dades.</li> <li>PaaS (Platform as a Service): Prove\u00efment d'una plataforma inform\u00e0tica (sistemes operatius, bases de dades, entorns de desenvolupament, etc.) com un servei. L'organitzaci\u00f3 nom\u00e9s gestiona les aplicacions i les dades.</li> <li>SaaS (Software as a Service): Prove\u00efment d'aplicacions inform\u00e0tiques (CRM, ERP, etc.) com un servei. L'organitzaci\u00f3 nom\u00e9s gestiona les dades.</li> </ul> <p></p>"},{"location":"u02/#capes-duna-arquitectura-big-data","title":"Capes d'una arquitectura Big Data","text":"<p>Una arquitectura Big Data est\u00e0 formada per diferents capes que permeten gestionar i processar grans volums de dades. Algunes de les capes m\u00e9s importants d'una arquitectura Big Data s\u00f3n:</p> <ul> <li>Capa d'adquisici\u00f3 i interconnexi\u00f3: Capa encarregada de recollir les dades des de les seves fonts d'origen.</li> <li>Capa de coneixement i emmagatzematge: Capa encarregada de guardar les dades i generar anal\u00edtiques a partir d'elles.</li> <li>Capa de interoperabilitat i integraci\u00f3: Capa encarregada de connectar els diferents components de la plataforma Big Data.</li> <li>Capa de serveis: Capa encarregada d'oferir serveis a trav\u00e9s d'una API, generalment.</li> <li>Capa de suport: Capa encarregada de donar suport als diferents components de la plataforma Big Data, gestionant aspectes com ara la seguretat, la monitoritzaci\u00f3, etc.</li> </ul> <p>Un esquema visual d'una arquitectura Big Data es pot veure a la figura seg\u00fcent:</p> <p></p>"},{"location":"u02/#capa-dadquisicio-i-interconnexio","title":"Capa d'adquisici\u00f3 i interconnexi\u00f3","text":"<p>La capa d'adquisici\u00f3 i interconnexi\u00f3 \u00e9s la capa encarregada de recollir les dades des de les seves fonts d'origen utilitzant protocols de comunicaci\u00f3 comuns. En aquesta capa tamb\u00e9 se fa la transformaci\u00f3 de les dades, si \u00e9s necessari, per a que quan entren a la plataforma ho facen amb el format establert. Aquesta capa pot incloure diferents components, com ara:</p> <ul> <li>Connectors: Components encarregats de connectar amb les diferents fonts de dades.</li> <li>Transformadors: Components encarregats de transformar les dades a un format com\u00fa.</li> <li>Validadors: Components encarregats de validar les dades abans de ser processades.</li> </ul>"},{"location":"u02/#capa-de-coneixement-i-emmagatzematge","title":"Capa de coneixement i emmagatzematge","text":"<p>La capa de coneixement i emmagatzematge \u00e9s la capa encarregada de guardar les dades en diferents sistemes gestors d'informaci\u00f3, i tamb\u00e9, si cal, de generar anal\u00edtiques a partir d'elles utilitzant t\u00e8cniques d'IA, regles, alertes, etc.</p>"},{"location":"u02/#capa-dinteroperabilitat-i-integracio","title":"Capa d'interoperabilitat i integraci\u00f3","text":"<p>La capa d'interoperabilitat i integraci\u00f3 \u00e9s la capa encarregada de connectar els diferents components de la plataforma Big Data, oferint interf\u00edcies o connectors que permeten l'acc\u00e9s a les dades de la plataforma. Aix\u00ed, podem construir serveis intel\u00b7ligents, connectar uns sistemes amb altres, o b\u00e9 preparar les dades per exposar-les a l'exterior. </p>"},{"location":"u02/#capa-de-serveis","title":"Capa de serveis","text":"<p>La capa de serveis ofereix diferents serveis a trav\u00e9s d'una API, com ara serveis d'an\u00e0lisi de dades, serveis de predicci\u00f3, serveis de recomanaci\u00f3, etc. Aquests serveis poden ser consumits per altres sistemes o per l'usuari final. Se poden fer \u00fas de components com ara:</p> <ul> <li>APIs: Interf\u00edcies de programaci\u00f3 d'aplicacions que permeten l'acc\u00e9s als serveis de la plataforma.</li> <li>Dashboards: Interf\u00edcies gr\u00e0fiques que permeten visualitzar les dades i els resultats obtinguts.</li> <li>GIS: Sistemes d'informaci\u00f3 geogr\u00e0fica que permeten visualitzar les dades en un mapa.</li> <li>Alarmes: Serveis que permeten enviar alarmes en funci\u00f3 de regles definides.</li> <li>Recomanadors: Serveis que permeten fer recomanacions en funci\u00f3 de les dades disponibles.</li> </ul>"},{"location":"u02/#capa-de-suport","title":"Capa de suport","text":"<p>La capa de suport \u00e9s la capa encarregada de donar suport als diferents components de la plataforma Big Data, gestionant aspectes com ara la seguretat, la monitoritzaci\u00f3, la gesti\u00f3 de l'escalabilitat, etc. Es tracta d'una capa transversal a tota la plataforma, la qual permet gestionar i administrar. Per exemple, pot incloure funcionalitats com ara: </p> <ul> <li>Seguretat: Gesti\u00f3 de l'acc\u00e9s a les dades i als serveis de la plataforma. Pot incloure la comprovaci\u00f3 i autoritzaci\u00f3 de les diferents fonts de dades i usuaris.</li> <li>Monitoritzaci\u00f3 i auditoria: Control de l'estat dels diferents components de la plataforma. L'auditoria permet registrar les accions realitzades pels usuaris i els sistemes.</li> <li>Gesti\u00f3 de l'escalabilitat: Gesti\u00f3 de la capacitat de processament i emmagatzematge de la plataforma. Per exemple, pot incloure la gesti\u00f3 de la c\u00e0rrega de treball i la distribuci\u00f3 de les dades.</li> <li>Gesti\u00f3 de l'administraci\u00f3: Gesti\u00f3 dels usuaris, dels permisos, dels logs, etc. </li> </ul> <p>Ara que ja hem vist les diferents capes i les seues funcions, podem mostrar un esquema m\u00e9s detallat d'una plataforma Big Data:</p> <p></p> <p>Les diferents capes:</p> <p>Capa d'adquisici\u00f3</p> <p></p> <p>Capa de coneixement i emmagatzematge</p> <p></p> <p>Capa d'interoperabilitat i integraci\u00f3</p> <p></p> <p>Capa de serveis</p> <p></p> <p>Capa de suport</p> <p></p>"},{"location":"u02/#flux-i-qualitat-de-les-dades","title":"Flux i qualitat de les dades","text":"<p>El flux de dades en el context de Big Data es refereix al moviment de dades des del seu origen fins al seu dest\u00ed. Les dades, i el seu processament, \u00e9s la part m\u00e9s important d'un sistema Big Data. La qualitat de les dades \u00e9s imprescindible per a obtenir resultats fiables, correctes i \u00fatils.</p>"},{"location":"u02/#fases-del-flux-de-dades","title":"Fases del flux de dades","text":"<ol> <li> <p>Ingesti\u00f3 de dades: Proc\u00e9s d'adquisici\u00f3 de dades des de les seves fonts d'origen. Aquestes dades poden ser estructurades, semiestructurades o no estructurades.</p> </li> <li> <p>Normalitzaci\u00f3 de dades: Proc\u00e9s de transformaci\u00f3 de les dades per a que siguin compatibles amb el sistema de gesti\u00f3 de dades. Dins del proc\u00e9s de normalitzaci\u00f3 podem tamb\u00e9 trobar la neteja de dades. La neteja consisteix en la identificaci\u00f3 i correcci\u00f3 d'errors en les dades. La normalitzaci\u00f3 de dades tamb\u00e9 pot incloure la transformaci\u00f3 de les dades a un format com\u00fa.</p> </li> <li> <p>Distribuci\u00f3 de dades: Proc\u00e9s de distribuci\u00f3 de les dades en els diferents nodes del sistema de processament.</p> </li> <li> <p>Emmagatzenament i an\u00e0lisi de les dades: Proc\u00e9s de guardar les dades en un sistema de fitxers distribu\u00eft i processar-les per a obtenir resultats.</p> </li> <li> <p>Presentaci\u00f3 i exposici\u00f3 de les dades: Proc\u00e9s de visualitzaci\u00f3 i exposici\u00f3 de les dades per a que siguin comprensibles pels usuaris i/o accessibles per altres sistemes.</p> </li> </ol> <p>Un esquema resumit de les diferents fases del flux de dades es pot veure a la figura seg\u00fcent:</p> <p></p>"},{"location":"u02/#ingesta-de-dades","title":"Ingesta de dades","text":"<p>La ingesta de dades \u00e9s el proc\u00e9s d'adquisici\u00f3 de dades des de les seves fonts d'origen. Les dades poden ser, com hem vist, estructurades, semiestructurades o no estructurades. Les dades poden provenir de diferents fonts, com ara:</p> <ul> <li>Bases de dades relacionals</li> <li>Fitxers de text</li> <li>Fitxers de logs</li> <li>Sensors</li> <li>Xarxes socials</li> <li>etc.</li> </ul> <p>La ingesta de dades ha de complir amb els protocols de seguretat i privacitat establerts en les diferents fonts de dades. S'han de seguir els protocols de comunicaci\u00f3n definits en cada cas. La ingesta de dades pot ser en temps real o en batch, com s'ha comentat abans.</p>"},{"location":"u02/#normalitzacio-de-dades","title":"Normalitzaci\u00f3 de dades","text":"<p>Les dades recollides s'han de normalitzar per a que siguin compatibles amb el sistema de gesti\u00f3 de dades. La normalitzaci\u00f3 de dades pot incloure la neteja de dades, la transformaci\u00f3 de dades a un format com\u00fa i la identificaci\u00f3 de dades duplicades.</p> <p>Hi ha est\u00e0ndars, com ara NGSI, que defineixen com s'han de normalitzar les dades per a que siguin compatibles amb els sistemes de gesti\u00f3 de dades. NGSI \u00e9s un protocol que utilitzen les APis dels components FIWARE per a normalitzar les dades. FIWARE \u00e9s una plataforma d'arquitectura oberta que permet la creaci\u00f3 de solucions IoT i Smart City.</p>"},{"location":"u02/#distribucio-de-dades","title":"Distribuci\u00f3 de dades","text":"<p>Les dades normalitzades s'han de distribuir en els diferents nodes del sistema de processament. La distribuci\u00f3 de dades es pot fer de forma centralitzada o distribu\u00efda. En sistemes distribu\u00efts, com ara Hadoop, les dades es distribueixen en els diferents nodes del sistema de processament.</p>"},{"location":"u02/#emmagatzematge-i-analisi-de-dades","title":"Emmagatzematge i an\u00e0lisi de dades","text":"<p>Les dades, una vegada normalitzades, s'emmagatzemen en el repositori de la plataforma corresponent. Diferents sistemes anal\u00edtics poden processar les dades per a obtenir resultats. Els resultats poden ser guardats en el repositori o exposats a trav\u00e9s d'una API. En el processament se poden buscar anomalies en funci\u00f3 de regles definides, alarmes, tend\u00e8ncies, etc. Aplicant models de IA es poden fer prediccions, recomanacions, o generar nou coneiximent.</p>"},{"location":"u02/#presentacio-i-exposicio-de-les-dades","title":"Presentaci\u00f3 i exposici\u00f3 de les dades","text":"<p>Els resultats obtinguts en el proc\u00e9s d'an\u00e0lisi de dades es poden visualitzar i exposar a trav\u00e9s d'una interf\u00edcie gr\u00e0fica. Les dades tamb\u00e9 es poden exposar a trav\u00e9s d'una API per a que altres sistemes puguin accedir-hi. La presentaci\u00f3 i exposici\u00f3 de les dades ha de ser el m\u00e9s intu\u00eftiva possible, clara i comprensible per a l'usuari final. L'objectiu \u00e9\u015b facilitar la presa de decisions basada en les dades i la gesti\u00f3 dels diferents serveis que s'ofereixen a partir de les dades resultants de l'an\u00e0lisi.</p>"},{"location":"u02/#qualitat-de-les-dades","title":"Qualitat de les dades","text":"<p>La qualitat de les dades es pot mesurar en funci\u00f3 de diferents aspectes:</p> <ul> <li>Precisi\u00f3: Les dades s\u00f3n correctes i exactes?</li> <li>Integritat: Les dades s\u00f3n coherents i consistents?</li> <li>Consist\u00e8ncia: Les dades s\u00f3n uniformes i homog\u00e8nies?</li> <li>Actualitat: Les dades s\u00f3n actuals i vigents?</li> <li>Completitud: Les dades s\u00f3n completes i no hi ha valors en blanc?</li> <li>Usabilitat: Les dades s\u00f3n f\u00e0cils d'entendre i utilitzar?</li> </ul>"},{"location":"u03/","title":"Rep\u00e0s Docker","text":"<p>En aquesta unitat farem un rep\u00e0s de la tecnologia de contenidors, les imatges i el funcionament b\u00e0sic de Docker. Aquesta unitat \u00e9s un rep\u00e0s dels coneixements que ja haur\u00edem d'haver adquirit en cursos anteriors, per la qual cosa no entrarem en massa detall. Si voleu aprofundir m\u00e9s en el tema, podeu consultar la documentaci\u00f3 oficial de Docker a https://docs.docker.com/get-started.</p> <p>Treballarem amb Docker en un entorn Linux, encara que tamb\u00e9 est\u00e0 disponible per a Windows i MacOS. Si treballeu en un altre Sistema Operatiu que no siga Linux podeu utilitzar Docker Desktop, que \u00e9s una aplicaci\u00f3 que permet utilitzar Docker en Windows i MacOS. Podeu descarregar-la des de https://www.docker.com/products/docker-desktop.</p>"},{"location":"u03/#contenidors","title":"Contenidors","text":"<p>Un contenidor \u00e9s una unitat d'execuci\u00f3 lleugera que inclou tot el necessari per a executar una aplicaci\u00f3. Amb els contenidors podem empaquetar i distribuir aplicacions juntament amb les seves depend\u00e8ncies. Els contenidors s\u00f3n una eina molt \u00fatil per a desplegar aplicacions de forma r\u00e0pida i eficient.Aix\u00f2 ens permetr\u00e0 tenir un entorn de desenvolupament id\u00e8ntic a l'entorn de producci\u00f3.</p> <p>Podr\u00edem dir que el contenidor \u00e9s tamb\u00e9 una tecnologia de virtualitzaci\u00f3. A difer\u00e8ncia d\u2019una m\u00e0quina virtual, el contenidor utilitza el sistema base de la m\u00e0quina anfitriona i actua com un entorn privat que comparteix recursos amb el sistema anfitri\u00f3 sense necessitat de virtualitzar tot el hardware.</p>"},{"location":"u03/#avantatges-de-lus-de-contenidors","title":"Avantatges de l'\u00fas de contenidors","text":"<ul> <li> <p>La flexibilitat. Els contenidors s\u00f3n lleugers i portables, i poden ser executats en qualsevol lloc. Fins i tot les aplicacions m\u00e9s complexes poden incloure's als contenidors. </p> </li> <li> <p>La consist\u00e8ncia. Els contenidors asseguren que les aplicacions funcionen de la mateixa manera en qualsevol entorn.</p> </li> <li> <p>La efici\u00e8ncia. Els contenidors permeten als desenvolupadors empaquetar i distribuir aplicacions juntament amb les seves depend\u00e8ncies.</p> </li> <li> <p>La portabilitat. Els contenidors poden ser desplegats i executats en qualsevol lloc, ja siga en un entorn local, en el n\u00favol o en un centre de dades.</p> </li> <li> <p>La seguretat. Els contenidors ofereixen un entorn segur per a executar aplicacions.</p> </li> <li> <p>L'escalabilitat. Els contenidors permeten escalar aplicacions de forma r\u00e0pida i eficient.</p> </li> <li> <p>La poca c\u00e0rrega que suposen per al sistema, al compartir el mateix kernel que el sistema anfitri\u00f3.</p> </li> <li> <p>La possibilitat d'actualitzar \"en calent\". \u00c9s a dir, sense haver de parar el servei.</p> </li> </ul>"},{"location":"u03/#imatges","title":"Imatges","text":"<p>Una imatge \u00e9s un paquet que cont\u00e9 tot el necessari per a executar una aplicaci\u00f3, incloent l'entorn d'execuci\u00f3, el codi, les llibreries, les depend\u00e8ncies, les dades i la configuraci\u00f3 (variables d'entorn, fitxers, etc.) Les imatges s\u00f3n immutables, \u00e9s a dir, no es poden modificar. Per a modificar una imatge, cal crear una nova imatge a partir de l\u2019original.</p>"},{"location":"u03/#imatges-i-contenidors","title":"Imatges i contenidors","text":"<p>Un contenidor \u00e9s una inst\u00e0ncia d'una imatge. Si una imatge cont\u00e9 tot el necessari per a executar una aplicaci\u00f3, el contenidor seria com una inst\u00e0ncia d'eixa aplicaci\u00f3 en execuci\u00f3. Una imatge \u00e9s un arxiu de nom\u00e9s lectura que cont\u00e9 un conjunt de capes que s\u00f3n utilitzades per a crear un sistema de fitxers. M\u00e9s endavant veurem com crear imatges, com utilitzar imatges ja creades, i sobretot com utilitzar-les per a crear contenidors.</p>"},{"location":"u03/#docker","title":"Docker","text":"<p>Docker \u00e9s una plataforma de codi obert que permet automatitzar el desplegament d'aplicacions dins de contenidors. Docker permet als desenvolupadors empaquetar, enviar i executar aplicacions com contenidors. Aix\u00f2 permet, com hem comentat abans, simular un entorn de producci\u00f3 sense haver de modificar ni configurar el nostre sistema operatiu anfitri\u00f3.</p> <p></p> <p>B\u00e0sicament, el que aconsegueix Docker \u00e9s oferir contenidors d'aplicacions que aprofiten les capacitats de virtualitzaci\u00f3 del sistema amfitri\u00f3 per poder executar processos i serveis de forma a\u00efllada. Es tracta d'un concepte paregut al de m\u00e0quina virtual, per\u00f2 que no requerix d'un sistema operatiu. En Linux, per exemple, Docker fa \u00fas de les caracter\u00edstiques d'a\u00efllament de recursos (CPU, mem\u00f2ria, xarxa...) del nucli del sistema, tals com els cgroups i els namespaces, de manera que podem tindre diversos contenidors compartint el mateix kernel de Linux, per\u00f2 cadascun amb restriccions d'acc\u00e9s a determinats recursos. Aix\u00ed, contenidors independents s'executen dins una mateixa inst\u00e0ncia de Linux, evitant la sobrec\u00e0rrega d'iniciar i mantenir m\u00e0quines virtuals (on cada m\u00e0quina cont\u00e9 tot el necessari per a fer anar un sistema operatiu complet).</p>"},{"location":"u03/#installacio-de-docker-en-linux","title":"Instal\u00b7laci\u00f3 de Docker en Linux","text":"<p>Per a instal\u00b7lar Docker en una distribuci\u00f3 Linux, cal seguir els seg\u00fcents passos:</p> <ol> <li>Actualitzar la llista de paquets disponible el sistema:</li> </ol> <pre><code>sudo apt-get update \n</code></pre> <ol> <li>Instal\u00b7lar els paquets necessaris per a que el sistema puga descarregar paquets a trav\u00e9s de HTTPS:</li> </ol> <pre><code>sudo apt-get install apt-transport-https ca-certificates curl software-properties-common\n</code></pre> <ol> <li>Afegir la clau GPG oficial de Docker:</li> </ol> <pre><code>sudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n</code></pre> <ol> <li>Afegir el repositori de Docker a la llista de repositoris del sistema:</li> </ol> <pre><code>echo \"deb [signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n</code></pre> <ol> <li>Actualitzar la llista de paquets disponible el sistema:</li> </ol> <pre><code>sudo apt-get update\n</code></pre> <ol> <li>Instal\u00b7lar la versi\u00f3 comunit\u00e0ria de Docker:</li> </ol> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <ol> <li>Comprovar que Docker s'ha instal\u00b7lat correctament:</li> </ol> <pre><code>sudo docker --version\nsudo docker run hello-world\n</code></pre> <p>En teoria ens hauria d'apar\u00e8ixer un missatge com el seg\u00fcent:</p> <pre><code>$ sudo docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\nd1725b59e92d: Pull complete \nDigest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre> <p>Com veiem, l'execuci\u00f3 de docker s'ha realitzat com a sudo. Si volem utilitzar docker per a altres usuaris, nom\u00e9s haurem de crear un grup docker (o comprovar si ja existeix) i afegir ahi els usuaris que el puguen utilitzar.</p> <p>Per altra banda, veiem com utilitzar docker per tal de llan\u00e7ar una imatge: <code>docker run</code>. En aquest cas, una imatge de prova anomenada hello-world.</p> <p>Com veiem, ens indica que no troba la imatge 'hello-world:latest' en local, pel que la descarrega de la llibrer\u00eda (pull). Una vegada descarregada ja ens mostra el missatge que comen\u00e7a amb \"Hello from Docker\", corresponent a aquesta imatge.</p> <p>Si tornem a llan\u00e7ar l'ordre, comprovarem com ja no realitza la desc\u00e0rrega sin\u00f2 que executa directament la imatge Hello World.</p> <p>Si no voleu fer sudo cada vegada, podeu afegir-vos al grup docker fent <code>sudo usermod -aG docker $USER</code>. Si treballeu amb els ordinadors del centre, ja esteu afegits al grup.</p>"},{"location":"u03/#docker-i-serveis","title":"Docker i serveis","text":"<p>El dimoni (daemon) de Docker \u00e9s el servei que gestiona la creaci\u00f3, execuci\u00f3 i distribuci\u00f3 de contenidors. L'ordre <code>docker</code> que hem vist anteriorment, \u00e9s el client de docker, que permet a l'usuari interactuar amb el sistema, encara que tamb\u00e9 hi ha altres aplicacions clints.</p> <p>Si volem que el servei de Docker s'inicie en arrancar el sistema (systemd), farem:</p> <pre><code>sudo systemctl enable docker\n</code></pre> <p>I si volem llevar-lo de l'inici:</p> <pre><code>sudo systemctl disable docker\n</code></pre> <p>Podem trobar m\u00e9s informaci\u00f3 sobre tot el que podem fer despr\u00e9s d'haver instal\u00b7lat Docker en: https://docs.docker.com/install/linux/linux-postinstall/#configure-docker-to-start-on-boot, aix\u00ed com documentaci\u00f3 per a la configuraci\u00f3 del servei de Docker per a que escolte determinats ports mitjan\u00e7ant el fitxer /etc/docker/daemon.json: https://docs.docker.com/install/linux/linux-postinstall/#configure-where-the-docker-daemon-listens-for-connections</p>"},{"location":"u03/#comandes-basiques-de-docker","title":"Comandes b\u00e0siques de Docker","text":"<p>A continuaci\u00f3, veurem algunes de les comandes b\u00e0siques de Docker:</p> <ul> <li><code>docker run</code>: Llan\u00e7a un contenidor a partir d'una imatge, tal com acabem de veure.</li> <li><code>docker create</code>: Crea un contenidor a partir d'una imatge, per\u00f2 no l'executa.</li> <li><code>docker ps</code>: Mostra els contenidors en execuci\u00f3.</li> <li><code>docker ps -a</code>: Mostra tots els contenidors, tant els que estan en execuci\u00f3 com els que no.</li> <li><code>docker images</code>: Mostra les imatges disponibles en el sistema.</li> <li><code>docker pull</code>: Descarrega una imatge de Docker Hub sense crear cap contenidor</li> <li><code>docker push</code>: Puja una imatge a Docker Hub.</li> <li><code>docker rmi</code>: Elimina una imatge.</li> <li><code>docker rm</code>: Elimina un contenidor.</li> <li><code>docker start</code>: Inicia un contenidor. Si el contenidor ja existeix, farem <code>docker start</code>, no <code>docker run</code> cada vegada</li> <li><code>docker stop</code>: Para un contenidor.</li> <li><code>docker restart</code>: Reinicia un contenidor.</li> <li><code>docker exec</code>: Executa una comanda en un contenidor en execuci\u00f3.</li> <li><code>docker logs</code>: Mostra els logs d'un contenidor.</li> <li><code>docker inspect</code>: Mostra informaci\u00f3 detallada d'un contenidor o imatge.</li> <li><code>docker cp</code>: Copia fitxers entre el sistema local i un contenidor.</li> <li><code>docker commit</code>: Crea una nova imatge a partir d'un contenidor en execuci\u00f3.</li> <li><code>docker build</code>: Construeix una imatge a partir d'un fitxer Dockerfile.</li> <li><code>docker-network</code>: Permet posar contenidors en xarxa.</li> <li><code>docker-attach</code>: Permet connectar-se a un contenidor en execuci\u00f3 i veure en el nostre terminal el que es mostra en el terminal del contenidor.</li> </ul> <p>Exemple: anem a vore com descarregar i llan\u00e7ar una imatge per a Docker de Busybox. Busybox no \u00e9s m\u00e9s que una utilitat que combina moltes eines est\u00e0ndards d'Unix i ordres de Linux en un sol fitxer.</p> <pre><code># docker pull busybox\nUsing default tag: latest\nlatest: Pulling from library/busybox\n8c5a7da1afbc: Pull complete \nDigest: sha256:cb63aa0641a885f54de20f61d152187419e8f6b159ed11a251a09d115fdff9bd\nStatus: Downloaded newer image for busybox:latest\n</code></pre> <p>Amb a\u00e7\u00f2 hem descarregat la imatge de busybox pe a Docker des del Docker Hub (https://hub.docker.com/explore/). </p> <p>Si volem comprovar que l'hem descarregat, podem executar <code>docker images</code>, que ens mostra les imatges que tenim baixades:</p> <pre><code># docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nhello-world         latest              4ab4c602aa5e        3 weeks ago         1.84kB\nbusybox             latest              e1ddd7948a1c        2 months ago        1.16MB\n</code></pre> <p>Ara anem a executar el contenidor amb <code>docker run</code>:</p> <pre><code># docker run busybox\n</code></pre> <p>Dos coses que podem veure: com que a tenim descarregada la imatge, no la torna a descarregar. Amb la imatge de busybox al sistema, Docker la busca, la carrega en un contenidor i executa al busybox les ordres que li passem. </p> <p>Segona cosa: com que en aquest cas no li hem passat cap ordre, aparentment, no far\u00e0 res.</p> <p>Ara anem a executar una instrucci\u00f3 dins del contenidor:</p> <pre><code># docker run busybox echo \"Hola m\u00f3n!\"\nHola m\u00f3n!\n</code></pre> <p>O tamb\u00e9:</p> <pre><code># docker run busybox ls\nbin\ndev\netc\nhome\nproc\nroot\nsys\ntmp\nusr\nvar\n</code></pre> <p>O fins i tot veure l'arxiu d'usuaris:</p> <pre><code># docker run busybox cat /etc/passwd\nroot:x:0:0:root:/root:/bin/sh\ndaemon:x:1:1:daemon:/usr/sbin:/bin/false\nbin:x:2:2:bin:/bin:/bin/false\nsys:x:3:3:sys:/dev:/bin/false\nsync:x:4:100:sync:/bin:/bin/sync\nmail:x:8:8:mail:/var/spool/mail:/bin/false\nwww-data:x:33:33:www-data:/var/www:/bin/false\noperator:x:37:37:Operator:/var:/bin/false\nnobody:x:65534:65534:nobody:/home:/bin/false\n</code></pre> <p>Per veure els contenidors que tenim en execuci\u00f3, podem utilitzar <code>docker ps</code>:</p> <pre><code># docker ps\nCONTAINER ID    IMAGE       COMMAND       CREATED          STATUS           PORTS   NAMES\nd4018e11cc64    busybox     \"sleep 10\"    5 seconds ago    Up 4 seconds             elegant_keldysh\n</code></pre> <p>Si executem l'ordre <code>sh</code> dins del contenidor, podem interactuar amb ell:</p> <pre><code># docker exec -it d4018e11cc64 sh\n/ # ls\nbin   dev   etc   home  proc  root  sys   tmp   usr   var\n/ # exit\n</code></pre> <p>amb <code>docker run -it imatge</code> el contenidor se crea a partir de la imatge, se queda en funcionament i no se tanca</p> <p>amb <code>docker run -it -rm imatge</code> el contenidor se crea, se queda en funcionament i quan el tanquem, se borra</p> <p>Amb l'opci\u00f3 -a de docker ps podem obtindre tots els contenidors que s'han creat en la sessi\u00f3 actual:</p> <pre><code># docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                        \n5dde99182cec        busybox             \"sh\"                2 minutes ago       Exited (0) 2 minutes ago                           festive_ride\nd4018e11cc64        busybox             \"sleep 10\"          16 minutes ago      Exited (0) 16 minutes ago                          elegant_keldysh\n2a2b08d458c5        busybox             \"ps aux\"            20 minutes ago      Exited (0) 19 minutes ago                          \nb17136bc9389        busybox             \"cat /etc/passwd\"   22 minutes ago      Exited (0) 22 minutes ago                          gifted_archimedes\na475a7587143        busybox             \"ls\"                23 minutes ago      Exited (0) 23 minutes ago                          jovial_leavitt\n1febe609a9a9        busybox             \"echo hola\"         23 minutes ago      Exited (0) 23 minutes ago                          compassionate_spence\ndc64b0307514        busybox             \"sh\"                25 minutes ago      Exited (0) 24 minutes ago                          clever_lalande\n2a4808f37627        hello-world         \"/hello\"            About an hour ago   Exited (0) About an hour ago                       nostalgic_stallman\n31545996cff7        hello-world         \"/hello\"            About an hour ago   Exited (0) About an hour ago \n</code></pre> <p>Per a eliminar un contenidor, farem servir <code>docker rm</code>:</p> <pre><code># docker rm 5dde99182cec\n5dde99182cec\n</code></pre> <p>I per a eliminar una imatge, farem servir <code>docker rmi</code>:</p> <pre><code># docker rmi busybox\nUntagged: busybox:latest\nUntagged: busybox@sha256:cb63aa0641a885f54de20f61d152187419e8f6b159ed11a251a09d115fdff9bd\nDeleted: sha256:e1ddd7948a1c1e0b0c6b4f3b3d1f0e3f3b3b1f1b4a7d1b3b1b3b1b3b1b3b1b3b1\nDeleted: sha256:8c5a7da1afbc\n</code></pre>"},{"location":"u03/#dockerfile","title":"Dockerfile","text":"<p>Hem vist com descarregar imatges i crear contenidors a partir d'elles. I si volem crear les nostres pr\u00f2pies imatges, o ampliar imatges que ja existeixen? Per a a\u00e7\u00f2, farem servir un fitxer anomenat Dockerfile i la instrucci\u00f3 <code>docker build</code>.</p> <p>Un Dockerfile \u00e9s un fitxer de text que cont\u00e9 una s\u00e8rie d'instruccions que Docker ha d'executar per a crear una imatge. Aquestes instruccions s\u00f3n molt senzilles i permeten crear imatges personalitzades a partir d'imatges existents.</p> <p>Avantatges de crear imatges a partir d'un Dockerfile:</p> <ul> <li> <p>Podrem reproduir la imatge f\u00e0cilment ja que al Dockerfile tenim totes i cadascuna de les ordres necess\u00e0ries per a la construcci\u00f3 de la imatge. </p> </li> <li> <p>Podrem configurar el proc\u00e9s que s'executar\u00e0 per defecte als contenidors creats a partir de la nova imatge. Si volem canviar la imatge de base, aix\u00f2 \u00e9s extremadament senzill amb un Dockerfile.</p> </li> </ul> <p>Les principals instruccions que podem trobar en un Dockerfile s\u00f3n:</p> <ul> <li><code>FROM</code>: Indica la imatge de base a partir de la qual es crear\u00e0 la nova imatge.</li> <li><code>RUN</code>: Executa una instrucci\u00f3 en el sistema de fitxers de la imatge.</li> <li><code>COPY</code>: Copia fitxers des del sistema local a la imatge.</li> <li><code>ADD</code>: Similar a COPY, per\u00f2 permet copiar fitxers des d'una URL.</li> <li><code>CMD</code>: Especifica la comanda que s'executar\u00e0 per defecte en els contenidors creats a partir de la imatge.</li> <li><code>ENTRYPOINT</code>: Especifica la comanda que s'executar\u00e0 quan es llance el contenidor amb docker run</li> <li><code>EXPOSE</code>: Indica els ports que s'han d'exposar quan es llance el contenidor.</li> <li><code>VOLUME</code>: Indica els volums que s'han de crear quan es llance el contenidor.</li> <li><code>WORKDIR</code>: Indica el directori de treball per defecte.</li> <li><code>ENV</code>: Defineix variables d'entorn.</li> <li><code>ARG</code>: Defineix variables que es poden passar a la imatge en el moment de la construcci\u00f3.</li> <li><code>LABEL</code>: Afegeix metadades a la imatge.</li> <li><code>USER</code>: Indica l'usuari que s'ha d'utilitzar per a executar les ordres.</li> </ul> <p>Per exemple, anem a veure com serie m\u00e9s o menys un Dockerfile per a crear una imatge de node-red:</p> <pre><code>FROM nodered/node-red\n# Copy package.json to the WORKDIR so npm builds all\n# of your added nodes modules for Node-RED\nCOPY package.json .\nRUN npm install --unsafe-perm --no-update-notifier --no-fund --only=production\n# Copy _your_ Node-RED project files into place\n# NOTE: This will only work if you DO NOT later mount /data as an external volume.\n#       If you need to use an external volume for persistence then\n#       copy your settings and flows files to that volume instead.\nCOPY settings.js /data/settings.js\nCOPY flows_cred.json /data/flows_cred.json\nCOPY flows.json /data/flows.json\n# Expose the listening port of Node-RED\nEXPOSE 1880\n</code></pre> <p>Amb docker build, crearem la imatge a partir del Dockerfile:</p> <pre><code>docker build -t node-red .\n</code></pre> <p>I amb docker run, llan\u00e7arem el contenidor:</p> <pre><code>docker run -d -p 1880:1880 --name mynodered node-red\n</code></pre> <p>Qu\u00e9 significa -d i -p? </p> <p>-d significa que el contenidor s'executar\u00e0 en segon pla, \u00e9s a dir, en background.  -p significa que el port 1880 del contenidor es mapejar\u00e0 al port 1880 de la m\u00e0quina host.</p> <p>Podem provar si funciona accedint desde la URL a http://localhost:1880.</p>"},{"location":"u03/#volums","title":"Volums","text":"<p>Si eliminem un contenidor o el tornem a crear amb la mateixa imatge, perdrem totes les dades que h\u00e0gim creat dins del contenidor. Per a evitar a\u00e7\u00f2, farem servir volums.</p> <p>Un volum \u00e9s un directori que es pot compartir entre contenidors i amb el sistema host. Els volums s\u00f3n una eina molt \u00fatil per a persistir dades i compartir-les entre contenidors. </p> <p>En Linux els volums se guarden a <code>/var/lib/docker/volumes</code>. Els volums se solen utilitzar en els casos seg\u00fcents:</p> <ul> <li>Per compartir dades entre contenidors. Simplement hauran de fer servir el mateix volum.</li> <li>Per a c\u00f2pies de seguretat ja sigui perqu\u00e8 siguin usades posteriorment per altres contenidors o per moure aquests volums a altres hosts.</li> <li>Quan vull emmagatzemar les dades del meu contenidor en el sistema amfitri\u00f3 o fins i tot en un prove\u00efdor cloud.</li> </ul> <p>Per a gestionar volums tenim les seg\u00fcents comandes:</p> <ul> <li><code>docker volume create</code>: Crea un volum amb el nom que indiquem</li> <li><code>docker volume ls</code>: Llista els volums disponibles</li> <li><code>docker volume inspect</code>: Mostra informaci\u00f3 detallada d'un volum</li> <li><code>docker volume rm</code>: Elimina un volum</li> <li><code>docker volume prune</code>: Elimina tots els volums no utilitzats</li> </ul> <p>Anem a veure un xicotet exemple de com fer servir volums creant un miniservidor Apache:</p> <ul> <li>Primer creem el volum</li> </ul> <pre><code>docker volume create miweb\n</code></pre> <p>Ara creem un contenidor amb un servidor apache, montant el volum:</p> <pre><code>$ docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4\n</code></pre> <p>Amb a\u00e7\u00f2, hem creat un contenidor amb un servidor Apache que servir\u00e0 el contingut del volum <code>miweb</code> en el port 8080 de la m\u00e0quina host. El par\u00e0metre <code>dst</code> indica el directori on es muntar\u00e0 el volum dins del contenidor.</p> <p>Anem a crear un fitxer HTML dins del volum:</p> <pre><code>$ docker exec my-apache-app bash -c 'echo \"&lt;html&gt;&lt;head&gt;&lt;meta charset=\\\"UTF-8\\\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hola, m\u00f3n!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\" &gt; /usr/local/apache2/htdocs/index.html'\n</code></pre> <p>Ara podem accedir a la nostra web a trav\u00e9s de la URL http://localhost:8080 i veure qu\u00e8 mostra.</p> <p></p> <p>Si ara eliminem el contenidor amb <code>docker rm -f my-apache-app</code>, el volum no es veur\u00e0 afectat encara que ara <code>localhost:8080</code> mostrar\u00e0 un error perqu\u00e8 no hi ha cap Apache en funcionament. </p> <p>Anem a crear un altre contenidor i muntar el mateix volum, encara que ara utilitzarem l'opci\u00f3 <code>-v</code>:</p> <pre><code>$ docker run -d --name my-apache-app -v miweb:/usr/local/apache2/htdocs -p 8080:80 httpd:2.4\n</code></pre> <p>Com podeu comprovar, sense tornar a crear l'arxiu <code>index.html</code>, la web ja est\u00e0 disponible a http://localhost:8080.</p>"},{"location":"u03/annex/","title":"Docker Compose","text":"<p>Docker Compose \u00e9s una eina que permet definir i executar aplicacions amb varis contenidors. Docker Compose ens permet definir, crear i al\u00e7ar  un conjunt de contenidors a parti d'un \u00fanic arxiu de configuraci\u00f3 i amb una sola instrucci\u00f3.</p> <p>El primer pas \u00e9s definir un arxiu YAML per configurar els serveis de  l'aplicaci\u00f3. A continuaci\u00f3, amb una instrucci\u00f3 docker compose, es crea i posa  en marxa tot l'entorn des de la configuraci\u00f3. Aix\u00ed, podem treballar amb diferents serveis i volums, amb l'opci\u00f3 de definir una xarxa comuna per a tots ells.</p> <p>Amb Docker Compose podem:</p> <ul> <li>Definir, arrancar i parar serveis</li> <li>Veure l'estat dels serveis</li> <li>Veure els logs dels serveis en marxa</li> <li>Executar una instrucci\u00f3 en un serveis</li> </ul> <p>En general Docker Compose \u00e9s similar a Kubernetes pel que fa a muntar un entorn de treball amb diferents contenidors connectats. Docker Compose \u00e9s m\u00e9s senzill i est\u00e0 pensat per a entorns de desenvolupament i per a fer proves.</p> <p>Per a utilitzar Docker Compose cal tenir instal\u00b7lat Docker al nostre sistema. Per comprovar que tenim instal\u00b7lat Docker Compose podem executar la seg\u00fcent instrucci\u00f3:</p> <pre><code>docker-compose --version\n</code></pre> <p>Si no tenim instal\u00b7lat <code>docker-compose</code>, podem fer-ho amb la seg\u00fcent instrucci\u00f3:</p> <pre><code>sudo apt install docker-compose\n</code></pre> <p>De totes formes, en versions recents de Docker poder fer <code>docker compose</code> en lloc de <code>docker-compose</code>.</p>"},{"location":"u03/annex/#el-fitxer-docker-composeyml","title":"El fitxer docker-compose.yml","text":"<p>Com hem comentat, el primer pas per a utilitzar Docker Compose \u00e9s crear un arxiu de configuraci\u00f3 anomenat docker-compose.yml. Aquest arxiu \u00e9s un arxiu de configuraci\u00f3 YAML que cont\u00e9 la definici\u00f3 dels serveis, xarxes i volums que formen l'aplicaci\u00f3 que volem al\u00e7ar.</p> <p>L'estructura b\u00e0sica d'un arxiu docker-compose.yml \u00e9s la seg\u00fcent:</p> <pre><code>version: '3.8'\nservices:\n  servei1:\n    image: imatge1\n    ports:\n      - \"port_host:port_container\"\n    expose:\n      - \"port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\n  servei2:\n    image: imatge2\n    ports:\n      - \"port_host:port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\nnetworks:\n  xarxa1:\n    driver: bridge\n  xarxa2:\n    driver: bridge\n</code></pre> <ul> <li>version: Indica la versi\u00f3 de la sintaxi de Docker Compose que estem utilitzant.</li> <li>services: Cont\u00e9 la definici\u00f3 dels serveis que formen l'aplicaci\u00f3.</li> <li>volumes: Volums que formen l'aplicaci\u00f3 i mapeig entre el host i el contenidor.</li> <li>image: Les imatges que s'utilitzaran per a crear els contenidors.</li> <li>ports: Mapeig de ports entre el host i el contenidor.</li> <li>expose: Exposa un port del contenidor sense fer-lo accessible des de l'exterior.</li> <li>networks: Definici\u00f3 i configuraci\u00f3 de les xarxes.</li> <li>driver: Driver de la xarxa. La xarxa per defecte de Docker \u00e9s bridge.</li> </ul> <p>Podem utilitzar depends_on per a indicar que un servei dep\u00e8n d'un altre, de forma que el servei depenent no arrancar\u00e0 fins que arranque el servei del qual dep\u00e8n.</p> <pre><code>version: '3.8'\nservices:\n  servei1:\n    image: imatge1\n    ports:\n      - \"port_host:port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\n  servei2:\n    image: imatge2\n    ports:\n      - \"port_host:port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\n    depends_on:\n      - servei1\n</code></pre> <p>Com a alternativa a image, amb l'etiqueta build podem indicar la ruta on es troba el Dockerfile per a construir la imatge.</p> <p>Per exemple, si en la mateixa carpeta on tenim l'arxiu docker-compose.yml tenim un Dockerfile, podem fer:</p> <pre><code>version: '3.8'\nservices:\n  servei1:\n    build: .\n    ports:\n      - \"port_host:port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\n</code></pre> <p>Tamb\u00e9 podem crear variables d'entorn en els contenidors amb l'etiqueta environment.</p> <pre><code>version: '3.8'\nservices:\n  servei1:\n    image: imatge1\n    ports:\n      - \"port_host:port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\n    environment:\n      - VAR1=valor1\n      - VAR2=valor2\n</code></pre> <p>Amb l'etiqueta restart podem indicar com volem que es comporte el contenidor en cas de reinici. </p> <ul> <li>restart: no: No es reiniciar\u00e0 mai. Aix\u00f2 implica que si el contenidor es para, no es tornar\u00e0 a al\u00e7ar a no ser que ho fem manualment.</li> <li>restart: always: Es reiniciar\u00e0 sempre que es pare.</li> <li>restart: on-failure: Es reiniciar\u00e0 nom\u00e9s si el contenidor falla. </li> <li>restart: unless-stopped: Es reiniciar\u00e0 sempre que es pare, a no ser que el parem manualment.</li> </ul>"},{"location":"u03/annex/#comandes-basiques-de-docker-compose","title":"Comandes b\u00e0siques de Docker Compose","text":"<p>Un cop tenim l'arxiu de configuraci\u00f3 docker-compose.yml, podem utilitzar</p> <ul> <li>docker-compose up: Crea i al\u00e7a els contenidors especificats a l'arxiu de configuraci\u00f3.</li> <li>docker-compose down: Para i elimina els contenidors especificats a l'arxiu de configuraci\u00f3.</li> <li>docker-compose ps: Mostra l'estat dels contenidors especificats a l'arxiu de configuraci\u00f3.</li> <li>docker-compose logs: Mostra els logs dels contenidors especificats a l'arxiu de configuraci\u00f3.</li> <li>docker-compose exec: Executa una instrucci\u00f3 en un contenidor.</li> <li>docker-compose start: Arranca els contenidors (o el contenidor especificat)</li> <li>docker-compose stop: Para els contenidors (o el contenidor especificat) </li> <li>docker-compose restart: Reinicia els contenidors (o el contenidor especificat)   </li> <li>docker-compose build: Construeix les imatges especificades a l'arxiu de configuraci\u00f3.  </li> </ul>"},{"location":"u03/annex/#exemple-dus-de-docker-compose","title":"Exemple d'\u00fas de Docker Compose","text":"<p>Suposem que volem al\u00e7ar un entorn amb un servidor web i una base de dades MySQL/MariaDB.</p> <p>Creem un arxiu docker-compose.yml amb el seg\u00fcent contingut:</p> <pre><code>version: '3.8'\nservices:\n  webserver:\n    image: nginx:latest\n    ports:\n      - \"8080:80\"\n    volumes:\n      - ./web:/usr/share/nginx/html\n  db:\n    image: mariadb:latest\n    environment:\n      MYSQL_ROOT_PASSWORD: password\n      MYSQL_DATABASE: test\n      MYSQL_USER: user\n      MYSQL_PASSWORD: password\n    volumes:\n      - ./db:/var/lib/mysql\n</code></pre> <p>Si ara, des de la mateixa carpeta on tenim l'arxiu, fem:</p> <pre><code>docker-compose up\n</code></pre> <p>Podrem veure com se creen i s'alcen els contenidors. El servidor web estar\u00e0 disponible a l'adre\u00e7a http://localhost:8080.</p>"},{"location":"u03/annex/#escalar-serveis-amb-docker-compose","title":"Escalar serveis amb Docker Compose","text":"<p>Amb Docker Compose podem escalar serveis de forma senzilla. Per exemple, si volem tenir 3 inst\u00e0ncies del servei webserver, podem fer:</p> <pre><code>docker-compose up --scale webserver=3\n</code></pre> <p>Amb aquesta instrucci\u00f3, es crearan 3 inst\u00e0ncies del servei webserver.</p>"},{"location":"u03/annex/#exemple-dockeritzar-serveis-amb-python","title":"Exemple: dockeritzar serveis amb Python","text":"<p>En Aules teniu un arxiu anomenat api_con_dockerfile.zip que cont\u00e9 un exemple senzill de com dockeritzar un servei amb Python. Baixeu l'arxiu i descomprimiu-lo. Tindreu un fitxer docker.compose.yml amb el seg\u00fcent contingut:</p> <pre><code>version: \"3.7\"\nservices:\n\n  # API \n  api:\n    restart: always\n    container_name: api\n    build: ./folder/\n    ports:\n      - \"8010:8010\"\n    expose:\n      - \"8010\"\n    volumes:\n      - ./folder/data:/folder/data\n</code></pre> <p>El que fa el fitxer \u00e9s al\u00e7ar un contenidor amb un servei API que escolta pel port 8010. El servei est\u00e0 definit en un Dockerfile que es troba a la carpeta folder. El contingut del fitxer e\u015b el seg\u00fcent:</p> <pre><code>FROM python:3.9\n\nWORKDIR /folder\n\nADD . /folder\n\nRUN pip install -r requirements.txt\n\nEXPOSE 8010\n\nCMD [\"python\", \"-u\", \"/folder/script.py\"]\n\nLABEL MAINTAINER jclemente@prodevelop.es\n</code></pre> <p>El Dockerfile crea un contenidor amb Python 3.9, copia el contingut de la carpeta folder al contenidor, instal\u00b7la les depend\u00e8ncies del projecte, exposa el port 8010 i executa el script script.py que es troba a la carpeta folder. L'arxiu requirements.txt cont\u00e9 les depend\u00e8ncies del projecte. L'script script.py crea una API simple que escolta el port 8010 i que ofereix dos serveis: un GET en /getList i un POST en /postExample que, si li passem un par\u00e0metre <code>name</code>, el mostrar\u00e0 per pantalla. </p> <p>Alceu el contenidor i comproveu que els serveis funcionen correctament. El servei GET el podeu provar directament des del navegador. Per a provar el servei POST, podeu fer servir l'eina curl. Per exemple:</p> <pre><code>curl -X POST --header 'Content-Type:application/json' -d '{\"name\":\"Fidel\"}' http://localhost:8010/postExample \n</code></pre> <p>o b\u00e9 utilitzar una eina com Postman o Hoppscotch.</p> <p>En Windows \u00e9s possible que no funcione amb localhost. En aquest cas, podeu provar amb la IP de la m\u00e0quina o b\u00e9 amb host.docker.internal en lloc de localhost.</p>"},{"location":"u03/annex/#exemple-dockeritzar-node-red","title":"Exemple: dockeritzar Node-Red","text":"<p>Un altre exemple senzill \u00e9s el de dockeritzar Node-Red. Node-Red \u00e9s una eina de programaci\u00f3 visual per a IoT. Per a dockeritzar Node-Red, podem fer servir la imatge oficial de Node-Red.</p> <p>Creeu un arxiu docker-compose.yml amb el seg\u00fcent contingut:</p> <pre><code>services:\n  node-red:\n    image: nodered/node-red:latest\n    container_name: nodeRED\n    restart: unless-stopped\n    networks:\n      - net\n    ports:\n      - \"1881:1880\"\n    volumes:\n      - \"./node-red:/data\"\n\nnetworks:\n  net:\n    driver: bridge\n</code></pre> <p>Amb aquest arxiu, al\u00e7arem un contenidor amb Node-Red que escoltar\u00e0 pel port 1880. La carpeta data es mapejar\u00e0 amb la carpeta data del contenidor, de forma que les dades de Node-Red es guardaran en la carpeta data de la m\u00e0quina host. El port 1880 del contenidor se mapeja amb el port 1881 del sistema amfitri\u00f3. </p> <p>Podeu provar a accedir a Node-Red a trav\u00e9s del navegador a l'adre\u00e7a http://localhost:1881.</p> <p>En la seg\u00fcent unitat veurem a fons com utilitzar Node-Red.</p>"},{"location":"u04/","title":"Node-RED","text":"<p>Node-RED es una eina de programaci\u00f3 visual (de les anomenades \"no-Code\", encara que en este cas seria millor \"low-Code\") que permet connectar dispositius de hardware, APIs i serveis en l\u00ednia. Es basa en la programaci\u00f3 amb blocs, on cada bloc realitza una tasca espec\u00edfica. Aquests blocs s\u00f3n anomenats nodes i es poden connectar entre ells per crear un flux de dades. \u00c9s open-source i est\u00e0 desenvolupat inicialment per IBM.</p> <p></p> <p>Informaci\u00f3 en GitHub: Node-RED en GitHub</p> <p>P\u00e0gina oficial: P\u00e0gina oficial de Node-RED</p> <p>Documentaci\u00f3: Documentaci\u00f3 de Node-RED</p>"},{"location":"u04/#installacio-en-linux","title":"Instal\u00b7laci\u00f3 en Linux","text":"<p>Anem a veure els passos per instal\u00b7lar Node-RED en un sistema Linux. De totes formes en principi anem a treballar amb un Node-RED en Docker per evitar problemes de compatibilitat, versions, etc.</p> <p>Per a instal\u00b7lar Node-RED, primer cal tenir instal\u00b7lat Node.js. Si no el tenim instal\u00b7lat, podem descarregar-lo des de la p\u00e0gina oficial: Descarregar Node.js</p> <p>Podem comprobar si tenim NodeJS instal\u00b7lat, aix\u00ed com el gestor de paquets npm, amb les seg\u00fcents comandes:</p> <pre><code>node -v\nnpm -v\n</code></pre> <p>Una vegada tenim instal\u00b7lat node i npm, podem instal\u00b7lar Node-RED amb la seg\u00fcent comanda:</p> <pre><code>sudo npm install -g --unsafe-perm node-red\n</code></pre> <p>Per a executar Node-RED, simplement cal executar la comanda:</p> <pre><code>node-red\n</code></pre>"},{"location":"u04/#installacio-en-windows","title":"Instal\u00b7laci\u00f3 en Windows","text":"<p>Podeu trobar les instruccions per instal\u00b7lar Node-RED en Windows en la p\u00e0gina oficial de l'aplicaci\u00f3.</p> <p>Node-RED en Windows</p>"},{"location":"u04/#installacio-en-docker","title":"Instal\u00b7laci\u00f3 en Docker","text":"<p>Per a instal\u00b7lar Node-RED en un contenidor Docker, tenim 2 opcions:</p> <ul> <li>directament:</li> </ul> <pre><code>docker run -it -p 1880:1880 -v node-red-data:/data --name nodeRED nodered/node-red\n</code></pre> <ul> <li>utilitzant <code>docker-compose</code> (recomanable per a projectes una miqueta m\u00e9s complexos), crearem un arxiu <code>docker-compose.yml</code> amb el seg\u00fcent contingut:</li> </ul> <pre><code>services:\n   node-red:\n      image: nodered/node-red:latest\n      container_name: nodeRED\n      restart: unless-stopped\n      networks:\n         - net\n      ports:\n         - \"1881:1880\"\n      volumes:\n         - \"./node-red-data:/data\"\n\nnetworks:\n   net:\n      driver: bridge\n</code></pre> <p>(per evitar problemes de tabulacions, espais, etc. quan copieu i pegueu, teniu l'arxiu <code>docker-compose.yml</code> pujat a Aules)</p> <p>Ara, com ja sabeu, per crear i al\u00e7ar el contenidor haurem de fer, la primera vegada i en la mateixa carpeta on tenim el <code>docker-compose.yml</code>:</p> <pre><code>docker-compose up -d\n</code></pre> <p>A partir d'ah\u00ed, podem parar el contenidor i tornar-lo a iniciar amb <code>docker start nodeRED</code> i <code>docker stop nodeRED</code>.</p>"},{"location":"u04/#interficie-de-node-red","title":"Interf\u00edcie de Node-RED","text":"<p>Una vegada feta la instal\u00b7laci\u00f3, per comprovar que tenim Node-RED funcionant intentarem accedir amb el navegador al port que hem mapejat, en este cas el 1881:</p> <p>En Linux:</p> <pre><code>http://localhost:1881\n</code></pre> <p>o tamb\u00e9:</p> <pre><code>http://172.17.0.1:1881\n</code></pre> <p>En Windows:</p> <pre><code>http://&lt;IP_del_PC&gt;:1881\n</code></pre> <p>o tamb\u00e9:</p> <pre><code>http://localhost:1881\n</code></pre> <p>i si no funciona amb localhost en Windows, recordeu que podeu provar:</p> <pre><code>http://host.docker.internal:1881\n</code></pre> <p>Si tot ha anat b\u00e9, ens hauria de mostrar la interf\u00edcie de Node-RED.</p> <p></p> <p>Si Node-RED no arranca i ens mostra errors de permisos, mireu amb quin usuari ha creat la carpeta compartida. Potser ho ha fet com a root, i despr\u00e9s el vostre usuari no t\u00e9 permisos per a escriure en ella. En aquest cas, caldr\u00e0 canviar els permisos de la carpeta o modificar el nostre fitxer <code>docker-compose.yml</code> perqu\u00e8 l'usuari siga el nostre i no root:</p> <p><code>yaml    services:       node-red:          image: nodered/node-red:latest          container_name: nodeRED          restart: unless-stopped          networks:             - net          ports:             - \"1881:1880\"          volumes:             - \"./node-red-data:/data\"          user: \"1000:1000\"</code></p> <p>La l\u00ednia <code>user: \"1000:1000\"</code> significa que l'usuari que crear\u00e0 la carpeta compartida ser\u00e0 el que tinga l'ID 1000 i el grup tamb\u00e9 1000. Per a saber quin \u00e9s el vostre ID d'usuari, podeu fer <code>id -u</code> i per al grup <code>id -g</code>.</p>"},{"location":"u04/#components-de-node-red","title":"Components de Node-RED","text":"<p>Node-RED es basa en 3 components principals:</p> <ul> <li>Flows: S\u00f3n els programes que creem amb Node-RED. Estan formats per nodes connectats entre ells.</li> <li>Nodes: S\u00f3n els blocs que realitzen tasques espec\u00edfiques. Podem trobar nodes per interactuar amb dispositius de hardware, per connectar-se a serveis en l\u00ednia, per realitzar c\u00e0lculs, per afegir funcions en JavaScript, per connectar a bases de dades, etc.</li> <li>Dashboard: \u00c9s un node especial que ens permet crear una interf\u00edcie web per a controlar els nostres programes.</li> </ul> <p>En la pantalla principal podem veure 3 seccions:</p> <ul> <li>a la part esquerra, una paleta on trobem tots els nodes disponibles per a ser utilitzats.</li> <li>a la part central, la zona de treball on podem crear els nostres programes. \u00c9s l'anomenat Flow Editor, i all\u00ed crearem els nostres fluxes.</li> <li>a la part dreta, tenim la informaci\u00f3 dels nodes seleccionats, aix\u00ed com la consola de debug i altres opcions de configuraci\u00f3.</li> </ul>"},{"location":"u04/#nodes","title":"Nodes","text":"<p>Un node es un bloc b\u00e0sic que fa una tasca espec\u00edfica i, moltes vegades, predeterminada. Els nodes se connecten entre ells per a crear un flux de dades. Com hem comentat, els nodes disponibles podem trobar-los en la paleta de la part esquerra de la interf\u00edcie. De totes formes, m\u00e9s endavant veurem que podem instal\u00b7lar m\u00e9s nodes per a ampliar les funcionalitats de Node-RED.</p> <p>Els nodes poden posar-se en funcionament per algun event extern, o perqu\u00e8 reben un missatge d'un altre node. A la seua vegada, poden generar un nou missatge que ser\u00e0 enviat a un altre node. Un node pot tindre un port d'entrada i un o m\u00e9s ports d'eixida. </p> <p>En general crearem els nodes arrosegant-los des de la paleta fins a la zona de treball, i connectant-los entre ells amb les fletxes que apareixen quan arrossegem una fletxa des d'un port d'eixida a un port d'entrada.</p> <p>Per exemple, anem a fer un flux amb un node de tipus \"inject\", i un altre de tipus \"debug\". Despr\u00e9s els connectarem entre ells. </p> <p></p> <p>Si se fixeu, veureu un xicotet punt blau en cada node. Aix\u00f2 vol dir que el flux no est\u00e0 guardat (desplegat). Per a guardar el flux, cal fer clic en el bot\u00f3 de la part superior dreta, on diu \"Deploy\" o \"Instanciar\". Veureu que els punts blaus desapareixen.</p> <p>Alguns nodes, com el de tipus \"inject\", tenen un bot\u00f3 a l'esquerra que serveix per posar-lo en marxa si no est\u00e0 associat a cap event extern o a cap altre node. En el nostre exemple, si fem clic en el bot\u00f3 de l'inject, se posa en marxa el flux. En principi no veurem que haja passat res, per\u00f2 si en la part de l'esquerra anem al bot\u00f3 de debug i fem clic, veurem el resultat del flux. En este cas, un n\u00famero que representa el timestamp del moment en qu\u00e8 s'ha executat el flux.</p> <p></p>"},{"location":"u04/#missatges-i-payload","title":"Missatges i Payload","text":"<p>Els nodes de Node-RED es comuniquen entre ells enviant missatges. Un missatge est\u00e0 compost per 3 parts principals:</p> <ul> <li>msg.payload: \u00c9s la informaci\u00f3 continguda en el missatge</li> <li>msg.topic: \u00c9s el tema del missatge</li> <li>msg.any other property: Podem afegir altres propietats al missatge</li> </ul> <p>El payload \u00e9s la informaci\u00f3 principal que es transmet entre els nodes. Per exemple, si tenim un node que llegeix un sensor de temperatura, el valor de la temperatura seria el payload. El topic \u00e9s una cadena de text que ens permet classificar els missatges. Per exemple, si tenim un node que llegeix un sensor de temperatura, el topic podria ser \"temperatura\".</p> <p>Si fem clic en el node d'injecci\u00f3, veurem que podem modificar el tipus de missatge que envia. Per defecte, envia un timestamp amb la data i hora actuals, que e\u015b el n\u00famero que ens mostra al fer el debug. Per\u00f2 podem canviar-ho per a que envie un missatge de tipus string, un n\u00famero, un boole\u00e0, etc. modificant el camp \"Payload\" del missatge.</p> <p></p> <p>Si fem  clic en el node de debug, veurem que t\u00e9 una propietat Salida que per defecte mostrar\u00e0 el payload que li passa el node anterior.</p> <p></p> <p>Si en lloc de mostrar el timestamp tal qual volem mostrar la data i hora en format llegible, podem afegir un node de tipus function entre l'inject i el debug. Aquest node ens permetr\u00e0 modificar el missatge abans de passar-lo al node de debug. Per exemple, podem utilitzar el seg\u00fcent codi per a convertir el timestamp en una data i hora llegible:</p> <pre><code>var date = new Date(msg.payload);\nmsg.payload = date.toString();\nreturn msg;\n</code></pre> <p>Si torneu a fer el deploy i executeu el flux, haurieu de veure la data en un format m\u00e9s llegible.</p> <p></p>"},{"location":"u04/#importar-i-exportar-fluxos","title":"Importar i exportar fluxos","text":"<p>Node-RED ens permet importar i exportar els nostres fluxos. Aix\u00f2 ens permet compartir els nostres programes amb altres persones, aix\u00ed com fer c\u00f2pies de seguretat dels nostres programes. Els fluxos s\u00f3n exportats en format JSON, i podem importar-los des de la interf\u00edcie de Node-RED.</p> <p>Per a exportar un flux, cal fer clic en el bot\u00f3 de la part superior dreta, i seleccionar Exportar. Aix\u00f2 ens mostrar\u00e0 una finestra on podem seleccionar qu\u00e8 volem exportar. Podem exportar tot el flux, nom\u00e9s la selecci\u00f3 actual, o nom\u00e9s un node.</p> <p></p> <p>Tamb\u00e9 podem exportar un flux fent clic amb el bot\u00f3 dret del ratol\u00ed sobre el flux, el grup o el node que volem exportar, i seleccionant Exportar.</p> <p></p> <p>Per a importar un flux pr\u00e8viament guardat en format JSON, fem clic en el men\u00fa de la part superior dreta i seleccionem l'opci\u00f3 Importar. Haurem de seleccionar el fitxer JSON que cont\u00e9 el flux que volem importar i ens crear\u00e0 un flux nou en la zona de treball amb els nodes importats.</p> <p></p>"},{"location":"u04/#nodes-addicionals","title":"Nodes addicionals","text":"<p>Node-RED permet instal\u00b7lar nodes addicionals per a ampliar les funcionalitats de l'aplicaci\u00f3. Per a fer-ho, cal anar a la paleta de la part esquerra de la interf\u00edcie i fer clic en el bot\u00f3 de la part superior dreta, on diu Manage palette o Administrar paleta. Aix\u00f2 ens obrir\u00e0 una finestra on podem veure els nodes que tenim instal\u00b7lats (pestanya Nodos), aix\u00ed com els que podem instal\u00b7lar (pestanya Instalar). Per a instal\u00b7lar un node, cal anar a la pestanya Install o Instalar i buscar el node que volem instal\u00b7lar. Un cop trobat, fem clic en el bot\u00f3 Install i el node ser\u00e0 instal\u00b7lat. A partir d'ara, el node estar\u00e0 disponible en la paleta de nodes que tenim a la part esquerra de la pantalla de treball.</p> <p></p>"},{"location":"u04/#exercici-01","title":"Exercici 01","text":"<p>Intenteu fer un \"Hola, mundo!\". Recordeu que per veure el missatge haureu de tindre un node de debug, fer clic en el bot\u00f3 de debug que teniu a la part dreta de la pantalla, i llan\u00e7ar el primer node manualment. </p> <p>Modifiqueu el flux anterior per a que mostre tamb\u00e9, a m\u00e9s del \"Hola, mundo!\" la data actual. </p>"},{"location":"u04/#exercici-02","title":"Exercici 02","text":"<ul> <li> <p>Descarregueu el flux Basic nodes operations que trobareu a Aules i importeu-lo al vostre NodeRED.</p> </li> <li> <p>Intenteu fer el desplegament del flux. Vos donar\u00e0 un error perqu\u00e8 el flux importat inclou nodes que no teniu instal\u00b7lats.</p> </li> <li> <p>Intenteu instal\u00b7lar els nodes que falten i torneu a fer el desplegament a veure si ja no dona error.</p> </li> </ul>"},{"location":"u04/nodered-avan%C3%A7at/","title":"Node-RED avan\u00e7at","text":"<p>En esta part final de la unitat anem a veure algunes caracter\u00edstiques m\u00e9s avan\u00e7ades de Node-RED.</p>"},{"location":"u04/nodered-avan%C3%A7at/#altres-nodes-comuns","title":"Altres nodes comuns","text":"<p>Anem a veure alguns nodes de la secci\u00f3 \"Com\u00fan\" que no hav\u00edem tractat fins ara.</p>"},{"location":"u04/nodered-avan%C3%A7at/#complete","title":"Complete","text":"<p>El node <code>complete</code> permet marcar un missatge com a complet. Aix\u00f2 pot ser \u00fatil per indicar que s'ha acabat de processar un missatge, o per indicar que s'ha arribat al final d'una seq\u00fc\u00e8ncia de missatges.</p> <p>Com sabeu, ni ha nodes que no reaccionen a l'entrada de missatges fins que no reben un missatge <code>complete</code>. Aix\u00f2 \u00e9s \u00fatil per a processos que necessiten saber quan han acabat de rebre missatges. Ah\u00ed teniu una possible utilitat de <code>complete</code>. </p>"},{"location":"u04/nodered-avan%C3%A7at/#catch","title":"Catch","text":"<p>El node <code>catch</code> permet capturar errors que es produeixen en el flux (en la mateixa pestanya). Aix\u00f2 pot ser \u00fatil per gestionar errors, o per enviar missatges d'error a un node <code>debug</code> o a un node <code>email</code>.</p>"},{"location":"u04/nodered-avan%C3%A7at/#status","title":"Status","text":"<p>El node <code>status</code> permet mostrar l'estat d'altres nodes que pertanyen al mateix flux (en la mateixa pestanya) en la interf\u00edcie de Node-RED. Tamb\u00e9 podem saber quin node ha informat del seu estat, i quin estat ha informat. Una possible utilitat \u00e9s mostrar l'estat d'un sensor en la interf\u00edcie de Node-RED.</p>"},{"location":"u04/nodered-avan%C3%A7at/#comment","title":"Comment","text":"<p>El node <code>comment</code> permet afegir comentaris al flux. No generen cap acci\u00f3.</p>"},{"location":"u04/nodered-avan%C3%A7at/#link-in-i-link-out","title":"Link in i Link out","text":"<p>Els nodes <code>link in</code> i <code>link out</code> permeten connectar dos parts del flux que estan separades. Aix\u00f2 pot ser \u00fatil per connectar dos parts del flux que estan lluny l'una de l'altra, o per connectar dos fluxos diferents (en diferents pestanyes).</p> <p>Si hi ha m\u00e9s d'un node <code>link in</code> amb el mateix nom, tots rebran el missatge. Aix\u00f2 pot ser \u00fatil per connectar un node <code>link out</code> a m\u00e9s d'un node <code>link in</code>. Si volem separar els diferents fluxos, donarem diferents noms a cada parella <code>link in</code>-<code>link out</code>.</p>"},{"location":"u04/nodered-avan%C3%A7at/#link-call","title":"Link call","text":"<p>El node <code>link call</code> permet cridar un node <code>link in</code> des d'un altre node. Aix\u00f2 pot ser \u00fatil per cridar una part del flux des d'una altra part del mateix flux, o des d'un altre flux.</p>"},{"location":"u04/nodered-avan%C3%A7at/#altres-nodes-de-funcio","title":"Altres nodes de funci\u00f3","text":"<p>A m\u00e9s dels nodes de funci\u00f3 que ja hem vist, \u00e9s \u00fatil con\u00e8ixer els seg\u00fcents:</p>"},{"location":"u04/nodered-avan%C3%A7at/#template","title":"Template","text":"<p>El node <code>template</code> permet crear missatges a partir de plantilles. Aix\u00f2 ens permet crear missatges amb un format concret, o a partir de variables. Amb el node <code>template</code> crearem una plantilla que despr\u00e9s se completar\u00e0 amb els valors que li arriben per <code>payload</code>. </p> <p>Exemple: podem crear un node <code>template</code> amb el contingut <code>La temperatura actual \u00e9s {{payload}}\u00baC</code>, i connectar-lo a un node <code>debug</code>. Quan li arribe un missatge amb un valor de temperatura, el node <code>template</code> substituir\u00e0 <code>{{payload}}</code> pel valor de temperatura, i el node <code>debug</code> mostrar\u00e0 el missatge <code>La temperatura actual \u00e9s 25\u00baC</code>.</p> <p></p>"},{"location":"u04/nodered-avan%C3%A7at/#delay","title":"Delay","text":"<p>El node <code>delay</code> permet retardar l'enviament d'un missatge. Aix\u00f2 pot ser \u00fatil per esperar un temps determinat abans d'enviar un missatge, o per evitar enviar missatges massa r\u00e0pidament. Hi ha moltes opcions que podem configurar, aix\u00ed que recomanem que consulteu l'ajuda oficial de Node-RED. </p>"},{"location":"u04/nodered-avan%C3%A7at/#wait-paths","title":"Wait-paths","text":"<p>El node <code>wait-paths</code> permet esperar fins que arriben tots els missatges d'un grup, emesos per diferents fonts, per generar un \u00fanic missatge d'eixida. Aix\u00f2 pot ser \u00fatil per esperar fins que arriben totes les dades d'un grup de sensors, per exemple.</p> <p>Els missatges entrants han de tindre en la propietat <code>paths</code> una clau que l'identifica i un valor que s'envia. El node <code>wait-paths</code> espera fins que arriben tots els missatges amb la mateixa clau o amb les claus especificades, i quan arriben tots envia un \u00fanic missatge amb totes les claus i valors.</p> <p>Podem fer un exemple utilitzant el node <code>delay</code> per fer que els missatges arriben en moments diferents, i nodes <code>change</code> per afegir la clau <code>paths</code> als missatges. En l'exemple seg\u00fcent un <code>inject</code> envia una senyal que passa directament a un <code>change</code> que crea un path, per un costat, i per un altre costat la mateixa senyal s'envia a un altre <code>change</code> que estableix un altre path amb altres valors, per\u00f2 passant pr\u00e8viament per un <code>delay</code>. Aix\u00ed podem veure que fins que els dos paths especificats no arriben, el node <code>debug</code> no mostra res. </p> <p></p> <p></p> <p></p> <p></p> <p>L'exemple el teniu en el flux importat <code>Basic node &amp; operations</code> i per tant podeu provar el seu funcionament.</p>"},{"location":"u04/nodered-avan%C3%A7at/#data-generator","title":"Data generator","text":"<p>El node <code>data generator</code> permet generar dades aleat\u00f2ries. Aix\u00f2 pot ser \u00fatil per provar el flux amb dades fict\u00edcies, o per generar dades per a un node <code>chart</code>. L'advantatge d'aquest node respecte a <code>random</code> \u00e9s que podem generar dades de diferents tipus, com ara noms, text, dates, etc., fins i tot amb un significat concret (noms inventats, poblacions, pa\u00efsos, etc.)</p> <p>Per exemple, en un node <code>data generator</code> podem escriure la seg\u00fcent plantilla com a valor del <code>payload</code>:</p> <pre><code>{\n    \"name\": \"{{firstName}} {{lastName}}\",\n    \"work\": \"{{company}}\",\n    \"email\": \"{{email}}\",\n    \"age\": \"{{random.number(100)}}\",\n    \"city\": \"{{address.city}}\",\n    \"country\": \"{{address.country}}\"\n}\n</code></pre> <p>Aix\u00f2 generar\u00e0 un missatge amb un nom, una empresa, un correu electr\u00f2nic, una edat, una ciutat i un pa\u00eds aleatoris. Podeu veure el contingut del node <code>data generator</code> i la seua eixida en les seg\u00fcents imatges. </p> <p></p> <p></p>"},{"location":"u04/nodered-avan%C3%A7at/#nodes-analitzadors","title":"Nodes analitzadors","text":"<p>Anem a veure alguns nodes de la secci\u00f3 \"Analysers\" que poden ser \u00fatils per analitzar dades.</p>"},{"location":"u04/nodered-avan%C3%A7at/#csv","title":"CSV","text":"<p>Converteix de cadenes CSV a objectes JavaScript, i viceversa.</p>"},{"location":"u04/nodered-avan%C3%A7at/#json","title":"JSON","text":"<p>Converteix de cadenes JSON a objectes JavaScript, i viceversa.</p>"},{"location":"u04/nodered-avan%C3%A7at/#html","title":"HTML","text":"<p>Converteix de cadenes HTML a objectes JavaScript, i viceversa.</p>"},{"location":"u04/nodered-avan%C3%A7at/#xml","title":"XML","text":"<p>Converteix de cadenes XML a objectes JavaScript, i viceversa.</p>"},{"location":"u04/nodered-avan%C3%A7at/#yaml","title":"YAML","text":"<p>Converteix de cadenes YAML a objectes JavaScript, i viceversa.</p> <p>Podeu fer proves redirigint un node <code>inject</code> a un node <code>csv</code> amb un valor com <code>1,2,3,4,5</code>, per exemple, i veure com el converteix en un objecte JavaScript. Tamb\u00e9 podeu crear una plantilla en format JSON i passar-la a un node <code>json</code> per veure com la converteix en un objecte JavaScript. Al rev\u00e9s tamb\u00e9 funciona. </p> <p>En l'exemple del <code>data generator</code> que hem vist abans, podem veure que se genera un objecte JavaScript que se mostra directament en un <code>debug</code>, i per altra banda filtrem l'objecte a trav\u00e9s d'un node <code>json</code> abans de passar-lo a l'altre <code>debug</code>. Aix\u00ed, mostrem per una part l'objecte JavaScript original, i per altra part la conversi\u00f3 a json.</p> <p></p> <p></p> <p>En este moment podeu intentar fer l'exercici 1 que trobareu al final del document.</p>"},{"location":"u04/nodered-avan%C3%A7at/#arrancar-i-parar-fluxos-amb-variables-de-flux","title":"Arrancar i parar fluxos amb variables de flux","text":"<p>Quan vam veure com crear variables dins d'un missatge, coment\u00e0rem tamb\u00e9 que se poden crear variables de flux. Eixes variables s\u00f3n visibles per tot el flux, i poden ser utilitzades, entre altres coses, per controlar l'execuci\u00f3 del flux.</p> <p>Una forma t\u00edpica de fer-ho \u00e9s utilitzar un node <code>inject</code> per enviar un missatge amb valor <code>true</code>, i un altre que envie un missatge <code>false</code>. Els dos nodes <code>inject</code> envien el seu valor a un node <code>change</code> que el llegir\u00e0 i ser\u00e0 el que canviar\u00e0 el valor de la variable de flux. </p> <p></p> <p>Despr\u00e9s, en un altre flux de dades dins del mateix grup, podem utilitzar un node <code>switch</code> per preguntar si la variable de flux \u00e9s <code>true</code> o <code>false</code>, i permetre que continue el flux o no. Podem fer que si la variable \u00e9s <code>true</code> el flux continue per l'eixida 1 del <code>switch</code>, i que si \u00e9s <code>false</code> no continue per cap eixida. </p> <p></p> <p>En este moment podeu intentar fer l'exercici 2 que trobareu al final del document.</p>"},{"location":"u04/nodered-avan%C3%A7at/#nodes-de-xarxa","title":"Nodes de xarxa","text":"<p>Anem a veure alguns nodes relacionats amb la comunicaci\u00f3 amb altres dispositus o serveis. </p>"},{"location":"u04/nodered-avan%C3%A7at/#http-request","title":"HTTP request","text":"<p>El node <code>http request</code> permet fer peticions HTTP a altres servidors. Aix\u00f2 pot ser \u00fatil per obtenir dades d'una API, per enviar dades a un servidor (method PUT, POST), o per rebre dades d'un servidor (GET). Tamb\u00e9, amb el m\u00e8tode DELETE, per eliminar dades. </p> <p>Per a que funcione, hem d'especificar la URL del servidor, el m\u00e8tode HTTP (GET, POST, PUT, DELETE), i opcionalment les dades a enviar. Podem connectar-nos a endpoints creats per nosaltres amb Node-RED, o a qualsevol altre servidor que tinga una API HTTP.</p> <p>Per exemple, hi ha una API que ens permet obtenir les coordenades de la ISS (Estaci\u00f3 Espacial Internacional). Podem utilitzar el node <code>http request</code> per obtenir les coordenades de la ISS, i despr\u00e9s utilitzar-les per mostrar-les en un node <code>debug</code> o en un node <code>ui_text</code>.</p> <p>L'adre\u00e7a \u00e9s <code>http://api.open-notify.org/iss-now.json</code>.</p> <p>Aix\u00ed, el node <code>http request</code> quedaria aix\u00ed:</p> <p></p> <p>Podem passar el response a trav\u00e9s d'un filtre JSON (converteix el JSON rebut a un objecte JavaScript) i el mostrem amb un node <code>debug</code>.</p> <p></p> <p>Tamb\u00e9 podr\u00edem mostrar les dades en forma gr\u00e0fica, per\u00f2 aix\u00f2 ho veurem m\u00e9s endavant.</p>"},{"location":"u04/nodered-avan%C3%A7at/#http-response","title":"HTTP response","text":"<p>El node <code>http response</code> permet enviar respostes HTTP a clients que han fet una petici\u00f3 HTTP. Aix\u00f2 pot ser \u00fatil per crear una API HTTP amb Node-RED, o per respondre a peticions HTTP d'altres servidors.</p> <p>Per enviar peticions a un node <code>http_response</code> necessitem un node <code>http in</code> que ser\u00e0 el nostre endpoint al que li podrem enviar peticions des del navegador, Postman, curl, o similar.</p>"},{"location":"u04/nodered-avan%C3%A7at/#http-in","title":"HTTP in","text":"<p>El node <code>http in</code> permet crear un endpoint HTTP al que es poden fer peticions HTTP. Aix\u00ed podem crear la nostra API amb Node-RED. </p> <p>Anem a veure un exemple senzill amb <code>http in</code> i <code>http response</code>.</p> <p>Creem un node <code>http in</code> amb la seg\u00fcent configuraci\u00f3:</p> <ul> <li>Method: GET</li> <li>URL: /test</li> </ul> <p>Ara connectem el node <code>http in</code> a un node <code>template</code> amb contingut HTML. En el <code>payload</code> podem posar, per exemple:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;&lt;title&gt;Prova Node-RED&lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Hola! Benvingut a la meua API generada amb Node-RED&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Finalment, connectem el node <code>template</code> a un node <code>http response</code> que ser\u00e0 el que tornar\u00e0 la resposta al client. En el node <code>http response</code> no cal configurar res, ja que la resposta ja est\u00e0 configurada en el node <code>template</code>, per\u00f2 podem afegir un codi d'estat i unes cap\u00e7aleres, si volem. </p> <p>El resultat se veuria aix\u00ed:</p> <p></p> <p>Fixeu-vos que, a difer\u00e8ncia del node <code>inject</code>, no podem llan\u00e7ar manualment el node <code>http in</code>. Ho hem de fer des d'un navegador o un programa tipus Postman, curl o similar. Recordeu que li hav\u00edem donat el nom <code>test</code> al endpoint. Aix\u00ed, hem d'accedir a l'adre\u00e7a <code>http://localhost:1881/test</code> des del navegador i veurem qu\u00e8 ens torna el node <code>http response</code>.</p> <p>Haur\u00edem de veure:</p> <p></p>"},{"location":"u04/nodered-avan%C3%A7at/#nodes-darxius","title":"Nodes d'arxius","text":"<p>Anem a veure alguns nodes de la secci\u00f3 <code>almacenamiento</code> que poden ser \u00fatils per llegir i escriure arxius.</p>"},{"location":"u04/nodered-avan%C3%A7at/#escribir-archivo","title":"Escribir archivo","text":"<p>El node <code>escribir archivo</code> permet escriure dades en un arxiu. Podem afegir informaci\u00f3 al final de l'arxiu, o sobreescriure totalment el seu contingut. </p> <p></p>"},{"location":"u04/nodered-avan%C3%A7at/#leer-archivo","title":"Leer archivo","text":"<p>El node <code>leer archivo</code> permet llegir dades d'un arxiu. Se pot tornar tot el contingut de l'arxiu en una cadena, un missatge diferent per cada l\u00ednia de l'arxiu, o b\u00e9 un objecte (o un stream d'objectes) de tipus <code>Buffer</code>.</p> <p></p> <p>Pots intentar fer una prova generant un conjunt de dades aleat\u00f2ries, guardant-les en un arxiu, i despr\u00e9s llegint-lo i mostrant-lo en un node <code>debug</code>.</p> <p>Ara ja pots fer la resta d'exercicis que trobar\u00e0s a continuaci\u00f3.</p>"},{"location":"u04/nodered-avan%C3%A7at/#exercicis","title":"Exercicis","text":""},{"location":"u04/nodered-avan%C3%A7at/#exercici-01","title":"Exercici 01","text":"<p>Imaginem que tenim 2 estacions meteorol\u00f2giques que comuniquen dades de manera independent en un mateix instant de temps. Volem guardar les dades de les dues estacions en un sol document JSON i mostrar-lo amb un node <code>debug</code></p> <p>La primera estaci\u00f3 envia les seg\u00fcents dades:</p> <ul> <li>NO, NO2, NOx, SO2, Humitat, Temperatura, Velocitat del vent, Direcci\u00f3 del vent.</li> </ul> <p>La segona estaci\u00f3 envia nom\u00e9s dues dades: </p> <ul> <li>CO i CO2. </li> </ul> <p>Les dades seran generades aleat\u00f2riament amb el node <code>data generator</code>. Tots els valors poden tindre decimals i un valor m\u00ednim de 0 i un m\u00e0xim de 50. Cada estaci\u00f3 enviar\u00e1 valors nous a intervals de 0.5 segons.</p> <p>Tots dos conjunts tindran un camp <code>Data</code> que ser\u00e0 l'input del payload i que haurem de construir a partir del <code>timestamp</code> del injector .</p> <p>Hem de juntar tots dos conjunts de dades en un sol utilitzant el node <code>join</code> i aplicant tot el que hem vist.</p>"},{"location":"u04/nodered-avan%C3%A7at/#exercici-02","title":"Exercici 02","text":"<p>Fent \u00fas de les variables de flux, modifica l'exercici anterior per poder iniciar, parar o reiniciar la injecci\u00f3 de dades. </p> <ul> <li> <p>Necessitarem tindre 2 fluxes de dades en un mateix grup.</p> </li> <li> <p>El primer flux de dades tindria els nodes <code>inject</code> per activar o desactivar el segon flux.</p> </li> <li> <p>El segon flux de dades seria el mateix que l'exercici anterior.</p> </li> <li> <p>En el primer flux de dades podem utilitzar un node <code>inject</code> per enviar un missatge <code>true</code> i un altre per enviar un missatge <code>false</code>. El valor s'hauria de guardar en una variable de flux.</p> </li> <li> <p>En el segon flux de dades pots utilizar el node <code>switch</code> per preguntar si la variable de flux \u00e9s <code>true</code> o <code>false</code> i permetre que continue el flux o no.</p> </li> </ul>"},{"location":"u04/nodered-avan%C3%A7at/#exercici-03","title":"Exercici 03","text":"<p>Instal\u00b7la el node <code>flightradar24</code> i busca informaci\u00f3 a veure com funciona. Podem demanar informaci\u00f3 dels vols que estan passant per la nostra zona? Com? Intenta fer-ho. Envia l'eixida a un node <code>debug</code> que mostre el resultat, i analitza les dades rebudes. </p>"},{"location":"u04/nodered-avan%C3%A7at/#exercici-04","title":"Exercici 04","text":"<p>Modifica el flux anterior per guardar en un arxiu <code>vols.txt</code> l'aeroport d'origen, el de dest\u00ed, el n\u00famero de vol, l'altitud i la velocitat.</p>"},{"location":"u04/nodered-dashboards/","title":"Node-RED Dashboards","text":"<p>En aquesta unitat veurem com crear interf\u00edcies gr\u00e0fiques amb Node-RED. Aix\u00f2 ens permetr\u00e0 crear panells de control per a dispositius IoT, per a sistemes de monitoratge, per a sistemes de control, etc.</p>"},{"location":"u04/nodered-dashboards/#introduccio","title":"Introducci\u00f3","text":"<p>Un dashboard \u00e9s una interf\u00edcie gr\u00e0fica que ens permet interactuar amb una aplicaci\u00f3 o simplement mostrar elements gr\u00e0fics. Aquesta interf\u00edcie pot ser molt senzilla o m\u00e9s complexa. En el cas de Node-RED, els dashboards ens permeten crear interf\u00edcies gr\u00e0fiques per a les nostres aplicacions per a interactuar amb elles de forma m\u00e9s visual, crear gr\u00e0fics o veure estad\u00edstiques o dades en temps real.</p>"},{"location":"u04/nodered-dashboards/#installacio-dels-nodes-de-node-red-dashboard","title":"Instal\u00b7laci\u00f3 dels nodes de Node-RED Dashboard","text":"<p>Per a poder utilitzar els dashboards de Node-RED, primer cal instal\u00b7lar els nodes necessaris. Per a fer-ho, anem a la pestanya de configuraci\u00f3 de Node-RED i seleccionem la opci\u00f3 de Administrar paleta o Manage palette. A la finestra que ens apareix, busquem el paquet node-red-dashboard i el seleccionem per a instal\u00b7lar-lo.</p> <p></p> <p>Una vegada feu clic en el bot\u00f3 d'instal\u00b7lar, es descarregar\u00e0 i instal\u00b7lar\u00e0 el paquet amb els nodes necessaris per a poder crear dashboards.A la part esquerra vos hauria d'apar\u00e8ixer una nova secci\u00f3 de nodes anomenada dashboard.</p> <p></p>"},{"location":"u04/nodered-dashboards/#creacio-dun-dashboard","title":"Creaci\u00f3 d'un dashboard","text":"<p>Per a crear un dashboard, hem de copiar al flux els nodes que volem que se mostren. Cada node pertany a un tab i a un grup. Els tabs s\u00f3n les pestanyes que apareixen a la part esquerra del dashboard i els grups serveixen per agrupar certs nodes d'una pestanya en un \u00fanic element visual.</p> <p>Anem a fer un exemple senzill creant un node de tipus gauge per mostrar els valors que van entrant al flux, per exemple amb un node random.</p>"},{"location":"u04/nodered-dashboards/#exemple-amb-un-grafic-tipus-gauge-medidor","title":"Exemple amb un gr\u00e0fic tipus gauge (medidor)","text":"<p>1 - Creem un node inject per posar en marxa el flux. Injectar\u00e0 el timestamp cada segon.</p> <p>2 - Creen un node random per a generar un valor aleatori entre -30 i 50. En el nom posarem \"Temperatura\" per poder-lo diferenciar quan tinguem m\u00e9s nodes random. El connectarem amb el node inject.</p> <p>3 - Creem un node gauge per a mostrar el valor de la temperatura. El connectarem amb el node random i li posarem en el camp Label el text \"Temperatura\" i en el tipus seleccionarem Gauge.</p> <p>4 - Hem de definir en quin tab i en quin grup volem que aparega el node gauge. Anem a la secci\u00f3 de propietats i en el camp Group tenim un bot\u00f3 per editar i un altre per afegir un grup nou. Anem a crear un tab que s'anomene Sensors i dins un grup que s'anomene Gr\u00e0fics. Les propietats del node quedarien tal com se veu en la seg\u00fcent imatge.</p> <p></p> <p>5 - Ara ja podem desplegar el flux. Ho fem i no se veu res. Aix\u00f2 \u00e9s perqu\u00e8 per a veure el dashboard hem d'anar a la URL [http://localhost:1881/ui].</p> <p>Recordeu canviar el vostre port si no \u00e9s el 1881, aix\u00ed com la IP si no \u00e9s localhost.</p> <p>6 - A la URL que hem posat, en el men\u00fa de l'esquerra seleccionem el tab Sensors i ens apareixer\u00e0 el gr\u00e0fic. Podem veure com en temps real ens va mostrant les temperatures que van entrant. </p> <p></p>"},{"location":"u04/nodered-dashboards/#afegint-mes-grafics-al-dashboard","title":"Afegint m\u00e9s gr\u00e0fics al dashboard","text":"<p>Si agafem el flux que hem creat, seleccionem tots els nodes i fem copiar-pegar, tindrem un altre flux exactament igual. Ara anem a modificar el node random per generar un valor entre 0 i 100 i li posarem el nom \"Humedad\". Tamb\u00e9 modificarem el node gauge per posar-li el nom \"Humedad\" i dir-li que els valors estaran entre 0 i 100. El nou node gauge tindr\u00e0 el mateix tab i el mateix grup que el primer. </p> <p>El resultat si despleguem i tornem a mostrar el dashboard ser\u00e0 el seg\u00fcent.</p> <p></p> <p>Si provem a posar els dos nodes gauge en grups diferents, se mostrarien en columnes diferents dins del tab Sensors.</p> <p>Si els pos\u00e0rem en dos tabs diferents, tindr\u00edem cada gauge en una pestanya diferent del dashboard.</p> <p></p>"},{"location":"u04/nodered-dashboards/#mes-nodes-de-dashboard","title":"M\u00e9s nodes de dashboard","text":"<p>Per explorar m\u00e9s nodes de tipus dashboard podeu descarregar d'Aules els arxius JSON que trobareu a la carpeta Exemples dashboard. Una vegada carregats en la vostra inst\u00e0ncia de NodeRED, els examinarem i comentarem a classe.</p>"},{"location":"u04/nodered-formularis/","title":"Node-RED Formularis","text":"<p>En aquesta unitat veurem m\u00e9s possibilitats per a crear Dashboards. Seguirem repassant els nodes m\u00e9s importants per a Dashboards, en veurem algun nou, i tamb\u00e9 aprendrem a crear formularis i elements interactius dins dels nostres Dashboards.</p> <p>Primer anem a veure alguns nodes m\u00e9s de Dashboards que encara no hem utilitzat.</p>"},{"location":"u04/nodered-formularis/#mes-nodes-per-a-dashboards","title":"M\u00e9s nodes per a Dashboards","text":"<p>Ja hem vist alguns nodes per a representar gr\u00e0fics i dades en els nostres Dashboards, com ara el Gauge, el Chart o Table. Anem a veuren alguns m\u00e9s:</p> <ul> <li>Text: ens permet mostrar text est\u00e0tic o din\u00e0mic en el nostre Dashboard. Podem utilitzar-lo per a mostrar missatges, instruccions o qualsevol altra informaci\u00f3 que vulguem compartir amb l'usuari.</li> </ul> <p>En l'exemple tenim un node Inject que envia un timestamp a un node Function que converteix el timestamp en una cadena de text amb la data actual. La cadena es passa al node Text, que la mostra en el Dashboard.</p> <p> </p> <ul> <li>Show Notification: este node ens permet mostrar notificacions emergents en el Dashboard. Podem utilitzar-lo per a alertar als usuaris sobre esdeveniments importants o canvis en les dades. Per defecte la notificaci\u00f3 se mostra en la part superior dreta del Dashboard, per\u00f2 amb la propietat Position ho podem canviar. </li> </ul> <p>Amb la propietat timeout podem definir quant de temps es mostrar\u00e0 la notificaci\u00f3 abans de desapar\u00e8ixer. Amb la propietat Allow Manual Dismissal podem permetre que l'usuari tanque la notificaci\u00f3 manualment amb un bot\u00f3.</p> <p>Per exemple, podem mostrar una notificaci\u00f3 quan una propietat supere un cert valor. En l'exemple tenim un node Inject que activa un node Random que genera un valor aleatori entre 0 i 10. El node Switch comprova si el valor \u00e9s major que 5. Si ho \u00e9s li passa el payload a un node Template que crea un missatge que s'envia al node Show Notification per a mostrar la notificaci\u00f3 en el Dashboard.</p> <p></p> <ul> <li> <p>Template: ens permet crear contingut HTML personalitzat per al nostre Dashboard. Podem utilitzar-lo per a dissenyar elements visuals m\u00e9s complexos o per a integrar components externs en el nostre Dashboard. Tamb\u00e9 per a crear estils que s'aplicaran (a tots els Dashboards o a una p\u00e0gina concreta).</p> </li> <li> <p>Markdown: permet mostrar contingut en format Markdown en el nostre Dashboard, convertint-lo autom\u00e0ticament a HTML. Aix\u00f2 \u00e9s \u00fatil per a mostrar documentaci\u00f3, instruccions o qualsevol altre contingut formatat de manera senzilla.</p> </li> <li> <p>Audio: ens permet reproduir fitxers d'\u00e0udio en el nostre Dashboard. Podem utilitzar-lo per a proporcionar retroalimentaci\u00f3 sonora o per a reproduir sons espec\u00edfics en resposta a esdeveniments.</p> </li> <li> <p>Progress: mostra una barra de progr\u00e9s en el Dashboard. Agafa el valor num\u00e8ric del payload i el representa com un percentatge en una barra de progr\u00e9s.</p> </li> <li> <p>ui Control: permet controlar diversos aspectes del Dashboard, com ara canviar la p\u00e0gina actual, mostrar o ocultar elements, o actualitzar el t\u00edtol del Dashboard.</p> </li> </ul>"},{"location":"u04/nodered-formularis/#layout","title":"Layout","text":"<p>Abans de continuar, \u00e9s important entendre com funciona el layout (disposici\u00f3) en els Dashboards de Node-RED. El layout es basa en una estructura de p\u00e0gines i grups que ens permet organitzar els elements del nostre Dashboard de manera clara i accessible. Com hem vist, cada Dashboard pot incloure m\u00faltiples p\u00e0gines, cada p\u00e0gina pot incloure diversos grups, i en cada grup podem incloure diversos elements: gr\u00e0fics, taules, formularis, etc.</p> <p>A banda d'aix\u00f2, si fem doble clic en un component del Dashboard, anem a editar el grup, i en les propietats del grup anem a editar la p\u00e0gina, trobarem que dins de les propietats de la p\u00e0gina (on posem el seu nom i el seu path) hi ha una pestanya anomenada Layout. Podem triar entre:</p> <ul> <li>Grid: \u00e9s el layout per defecte. Els elements es col\u00b7loquen en una quadr\u00edcula, i s'ajusten autom\u00e0ticament segons la mida de la finestra del navegador. Divideix la p\u00e0gina en 12 columnes del mateix ample, i els grups ajusten el seu ample ocupant un nombre definit d'estes columnes. Aix\u00f2 permet flexibilitat i adaptaci\u00f3 a diferents mides i resolucions de pantalla.</li> <li>Fixed: ens permet definir una mida fixa per als elements del Dashboard. Utilitza unes mides anomenades unitats, on cada unitat s\u00f3n 90px, per oferir un control m\u00e9s exacte de les posicions de cada element. Normalment s'utilitza en interf\u00edcies industrials.</li> <li>Tabs: ens permet organitzar els elements del Dashboard en pestanyes. Aix\u00f2 \u00e9s \u00fatil si tenim molts elements i volem mantenir el Dashboard net i organitzat.</li> <li>Notebook: ens permet crear un format de llibre de notes amb un ample m\u00e0xim de 1024px i centrat, on els elements es poden organitzar en seccions i subseccions. Aix\u00f2 \u00e9s \u00fatil per a presentacions o informes m\u00e9s complexos.</li> </ul>"},{"location":"u04/nodered-formularis/#theme","title":"Theme","text":"<p>Tamb\u00e9 podem, en les propietas de la p\u00e0gina, editar el tema (theme) del Dashboard. El tema defineix l'aparen\u00e7a visual del Dashboard, incloent colors, fonts i estils dels elements. Node-RED ofereix diversos temes predefinits, per\u00f2 tamb\u00e9 podem crear els nostres propis temes personalitzats. Directament des d'este apartat podem modificar colors de fons del dashboard, les p\u00e0gines i grups, aix\u00ed com l'alt de les files, el padding, els bordes, etc.</p> <p></p>"},{"location":"u04/nodered-formularis/#formularis-en-node-red","title":"Formularis en Node-RED","text":"<p>Els formularis s\u00f3n una part essencial de molts Dashboards, ja que permeten als usuaris introduir dades i interactuar amb l'aplicaci\u00f3. En Node-RED, podem crear formularis utilitzant diversos nodes de Dashboards que faciliten la creaci\u00f3 d'elements interactius. Podem utilitzar els components per separat, o crear formularis que integren diferents components.</p>"},{"location":"u04/nodered-formularis/#components-de-formulari","title":"Components de formulari","text":"<ul> <li>Dropdown: ens permet crear un desplegable amb opcions predefinides. L'usuari pot seleccionar una opci\u00f3 de la llista, i el valor seleccionat es passa com a payload al seg\u00fcent node.</li> </ul> <p>En l'exemple veureu un node Dropdown que permet triar una prov\u00edncia entre Val\u00e8ncia, Castell\u00f3 i Alacant, i torna el valor que associem a l'opci\u00f3 seleccionada. En l'exemple la mostrem en un node Debug, per\u00f2 podr\u00edem fer qualsevol altra cosa amb el valor seleccionat.</p> <p></p> <ul> <li> <p>Switch: ja l'hem vist en altres exemples. Ens permet crear un bot\u00f3 d'encesa i apagada que l'usuari pot utilitzar per a activar o desactivar una funci\u00f3. El valor del payload ser\u00e0 <code>true</code> quan el bot\u00f3 estiga activat i <code>false</code> quan estiga desactivat.</p> </li> <li> <p>Slider: ens permet crear un control lliscant que l'usuari pot utilitzar per a seleccionar un valor dins d'un rang espec\u00edfic. El valor seleccionat es passa com a payload al seg\u00fcent node. Podem definir el valor m\u00ednim, el m\u00e0xim, i el pas del control (d'un en un, de dos en dos, etc.).</p> </li> </ul> <p></p> <ul> <li>Button: ens permet crear un bot\u00f3 que l'usuari pot clicar per a activar una acci\u00f3. Quan polsem el bot\u00f3, s'envia un missatge amb un payload predefinit al seg\u00fcent node. Per exemple, podem utilitzar un bot\u00f3 per netejar un component de text o un gr\u00e0fic enviant un payload buit. </li> </ul> <p>Algunes dades del bot\u00f3 (i d'altres components) es poden canviar en temps d'execuci\u00f3 mitjan\u00e7ant missatges. Per exemple, podem canviar l'etiqueta del bot\u00f3 enviant un missatge amb la propietat <code>msg.label</code> que continga el nou text. Tamb\u00e9 podem canviar l'estat del bot\u00f3 (habilitat o deshabilitat) enviant un missatge amb la propietat <code>msg.enabled</code> amb valor <code>true</code> o <code>false</code>. Tamb\u00e9 podem canviar propietas com <code>label</code>, <code>buttonColor</code>, <code>textColor</code> o fins i tot aplicar una classe al bot\u00f3 utilitzant <code>msg.ui_update</code> i la propietat corresponent. En l'exemple teniu uns botons que canvien l'estat, el label i el color d'un altre bot\u00f3.</p> <p></p> <p>En el node change d'activaci\u00f3, modifiquem les seg\u00fcents propietats del bot\u00f3 principal:</p> <pre><code>msg.enabled = true\nmsg.ui_update.label = Activat\"\nmsg.ui_update.buttonColor = \"blue\"\n</code></pre> <p>En el node change de desactivaci\u00f3, modifiquem les seg\u00fcents propietats del bot\u00f3 principal:</p> <pre><code>msg.enabled = false\nmsg.ui_update.label = \"Desactivat\"\nmsg.ui_update.buttonColor = \"grey\"\n</code></pre> <p>Tamb\u00e9 se pot enviar un \u00fanic missatge a un bot\u00f3 amb m\u00e9s d'una propietat amb:</p> <pre><code>msg.ui_update = {\n    label: \"Nou Label\",\n    buttonColor: \"red\",\n    textColor: \"white\"\n}\n</code></pre> <p>Amb <code>msg.ui_update</code> podem canviar moltes propietats de quasi tots els components d'un Dashboard. Pots consultar l'ajuda en l\u00ednia de Node-RED per a saber quines propietats es poden canviar en cada component. S\u00f3n les que apareixen com a Dynamic properties.</p> <p></p> <ul> <li> <p>Text input: ens permet crear un camp de text on l'usuari pot introduir dades. El text introdu\u00eft es passa com a payload al seg\u00fcent node. Podem utilitzar-lo per a recollir informaci\u00f3 com noms, correus electr\u00f2nics, o qualsevol altra dada textual.</p> </li> <li> <p>Number input: similar al Text input, per\u00f2 nom\u00e9s permet introduir valors num\u00e8rics. Aix\u00f2 \u00e9s \u00fatil quan necessitem que l'usuari introdu\u00efsca nombres, com edats, quantitats o valors mesurats. Podem definir l\u00edmits m\u00ednims i m\u00e0xims, aix\u00ed com el pas entre valors.</p> </li> </ul> <p></p> <p>No hi ha nodes especials, com en HTML, per introduir textos espec\u00edfics com correus electr\u00f2nics, dates, contrasenyes, color pickers, etc. De totes formes, en les propietas del node Text input podem definir el tipus de dades que volem introduir en la propietat Mode. En la figura seg\u00fcent podeu veure els diferents tipus que podem triar.</p> <p></p> <ul> <li>File input: ens permet crear un camp on l'usuari pot seleccionar i pujar un fitxer des del seu dispositiu. El contingut del fitxer es passa com a payload al seg\u00fcent node, permetent-nos processar o analitzar el fitxer pujat.</li> </ul> <p></p> <p></p> <ul> <li>Radio group: ens permet crear un grup de botons d'opci\u00f3 on l'usuari pot seleccionar una \u00fanica opci\u00f3 d'una llista predefinida. El valor seleccionat es passa com a payload al seg\u00fcent node. \u00c9s el radio button d'HTML.</li> </ul> <p></p>"},{"location":"u04/nodered-formularis/#el-node-form","title":"El node form","text":"<p>Per a crear formularis m\u00e9s complexos, podem utilitzar el node Form. Este node ens permet agrupar diversos components de formulari en un \u00fanic formulari que l'usuari pot omplir i enviar. Quan l'usuari envia el formulari, tots els valors dels components s'envien com un objecte JSON en el payload.</p> <p></p> <p>Si definim controls de tipus dropdown en el formulari, les hem de declarar en la pestanya Dropdown options del node Form. All\u00ed hem d'afegir les opcions que tindr\u00e0 cada desplegable, amb el seu valor i la seua etiqueta.</p> <p></p> <p>En el Dashboard el formulari se veur\u00e0 aix\u00ed:</p> <p></p> <p>Quan enviem el formulari, el payload que rep el seg\u00fcent node \u00e9s un objecte JSON amb les propietats corresponents a cada camp del formulari:</p> <p></p>"},{"location":"u04/nodered-intermedi/","title":"Node-RED intermedi","text":"<p>Ara que ja sabem com funcionen els nodes i com podem crear un flux de dades senzill, anem a veure com podem fer coses m\u00e9s complexes amb Node-RED. Per fer-ho, analitzarem alguns exemples de fluxos que heu important des d'Aules amb l'arxiu <code>Basic nodes operations</code>.</p>"},{"location":"u04/nodered-intermedi/#nodes-de-sequencies","title":"Nodes de seq\u00fc\u00e8ncies","text":"<p>Els nodes de seq\u00fcencies permeten actuar sobre una seq\u00fc\u00e8ncia de missatges, o crear-ne una de nova. Aix\u00f2 ens permet fer coses com filtrar missatges, dividir-los en parts, o afegir-los a una llista.</p>"},{"location":"u04/nodered-intermedi/#split","title":"Split","text":"<p>El node <code>split</code> permet dividir un missatge en parts. Per exemple, si tenim un missatge amb un text que cont\u00e9 diverses paraules, podem dividir-lo en tantes parts com paraules hi hagi si especifiquem l'espai en blanc com a separador. Aix\u00f2 ens permetr\u00e0 actuar sobre cada paraula de forma independent.</p> <p>A m\u00e9s de l'espai en blanc, podem utilitzar qualsevol altre car\u00e0cter com a separador en l'apartat <code>Split using</code> o <code>Dividir usando</code> del node.</p> <p>A banda de text, tamb\u00e9 podem dividir un array en les seues parts, o un objecte en les seues propietats, tal com podeu veure a la imatge.</p> <p></p>"},{"location":"u04/nodered-intermedi/#join","title":"Join","text":"<p>El node <code>join</code> permet unir les parts d'un missatge en un \u00fanic missatge d'eixida. Per exemple, si tenim un array amb diverses parts, podem unir-les en un sol missatge.</p> <p>Tamb\u00e9 podem treballar amb <code>msg.parts</code>. El funcionament de <code>msg.parts</code> en NodeRED \u00e9s similar al de <code>msg.payload</code>, per\u00f2 en lloc de contenir el valor del missatge, cont\u00e9 informaci\u00f3 sobre la part del missatge que estem tractant. Aix\u00f2 ens permet, per exemple, unir les parts d'un missatge en un ordre diferent al que tenien inicialment. Tamb\u00e9 podem fer que el receptor del missatge espere a que li arriben totes les parts per executar alguna acci\u00f3.</p> <p>Ac\u00ed teniu un exemple d'\u00fas de <code>split</code> i <code>join</code>. El que fa el flux \u00e9s agafar una cadena, dividir-la en paraules, i enviar el resultat per un costat a un node <code>debug</code> que mostrar\u00e0 per pantalla els diferents missatges que li arriben (les diferents paraules), i per altre costat li envia el mateix resultat a un node <code>join</code> que torna a juntar les paraules i les envia a un altre <code>Debug</code> que mostra la frase reconstru\u00efda. </p> <p></p> <p>Una altra utilitat de <code>join</code>, com hem comentat, \u00e9s unificar diferents missatges en un \u00fanic missatge. Se pot fer de manera autom\u00e0tica o manual. Per exemple, si tenim un sensor que ens envia la temperatura i la humitat en dos missatges diferents, podem utilitzar <code>join</code> per unir-los en un sol missatge. Veiem un exemple:</p> <p></p> <p>En este flux, tres nodes <code>inject</code> envien una dada diferent cadascun. Amb la etiqueta <code>topic</code> definim el nom de la propietat del missatge que contindr\u00e0 la dada. Despr\u00e9s, el node <code>Join</code> uneix els tres missatges en un sol missatge, i el node <code>debug</code> mostra el resultat. Fixeu-vos que el node <code>join</code> sap que ha d'esperar fins que li arriben els 3 missatges abans d'unir-los i enviar-los al node <code>debug</code>.</p> <p></p>"},{"location":"u04/nodered-intermedi/#sort","title":"Sort","text":"<p>El node <code>sort</code> permet ordenar les propietats d'un missatge, o una seq\u00fc\u00e8ncia de missatges. L'ordre pot ser ascendent o descendent. Se poden definir molts criteris d'ordenaci\u00f3 diferents, o tamb\u00e9 utilitzar <code>msg.parts</code> per ordenar els missatges. Veiem un exemple molt senzill on el node <code>inject</code> envia un JSON amb un array de n\u00fameros, i el node <code>sort</code> els ordena. En les propietats del node <code>sort</code> podem veure com estem utilitzant com a clau d'ordenaci\u00f3 el valor de l'element. </p> <p></p>"},{"location":"u04/nodered-intermedi/#batch","title":"Batch","text":"<p>El node <code>batch</code> permet crear seq\u00fc\u00e8ncies de missatges seguint certes regles. Hi ha tres formes de seq\u00fcenciar els missatges:</p> <ul> <li>per quantitat de missatges: agrupa missatges en seq\u00fc\u00e8ncies d'una longitud determinada</li> <li>per intervals de temps: agrupa els missatges que arriben en un determinat interval de temps</li> <li>concatenar seq\u00fc\u00e8ncies: agrupa distintes seq\u00fc\u00e8ncies en una sola</li> </ul> <p>A continuaci\u00f3 podeu veure un exemple on els nodes <code>join</code>, <code>batch</code>, <code>split</code> i <code>sort</code> treballen de manera conjunta amb unes seq\u00fc\u00e8ncies de n\u00fameros que envien dos nodes <code>inject</code>.</p> <p></p>"},{"location":"u04/nodered-intermedi/#nodes-de-funcio","title":"Nodes de funci\u00f3","text":"<p>Els nodes de funci\u00f3 ens permeten executar codi JavaScript o fer altres operacions sobre els missatges que passen pel flux. Aix\u00f2 ens permet fer moltes coses, com modificar el missatge, filtrar-lo, o crear-ne de nous. Hem vist abans un exemple amb el qual convertiem un <code>timestamp</code> en una data llegible. Aix\u00f2 ho hem fet amb el node <code>function</code></p> <p>Exemple igualment senzill: tenim un sensor que ens envia la temperatura i la humitat en dos missatges diferents. Volem que si la temperatura \u00e9s superior a 30\u00baC, s'envie un missatge d'alerta. Per fer-ho, utilitzarem un node <code>function</code> que comprovar\u00e0 si la temperatura \u00e9s superior a 30\u00baC, i si ho \u00e9s, enviar\u00e0 un missatge d'alerta.</p> <p>La funci\u00f3 seria aix\u00ed:</p> <pre><code>if (msg.payload.temperature &gt; 30) {\n    return {payload: \"Alerta: temperatura superior a 30\u00baC\"};\n}\n</code></pre> <p>De totes maneres, a banda del node <code>function</code> hi ha altres dins del grup Funci\u00f3n. Anem a veure alguns dels m\u00e9s importants.</p>"},{"location":"u04/nodered-intermedi/#switch","title":"Switch","text":"<p>El node <code>switch</code> ens permet fer bifurcacions en el flux segons el valor d'una propietat del missatge. Per exemple, si tenim un sensor que ens envia la temperatura i la humitat, podem utilitzar <code>switch</code> per enviar un missatge d'alerta si la temperatura \u00e9s superior a 30\u00baC, i un altre si la humitat \u00e9s superior al 70%.</p> <p>Per fer aix\u00f2 anem a necessitar tamb\u00e9 el node <code>Change</code>.</p>"},{"location":"u04/nodered-intermedi/#change","title":"Change","text":"<p>El node <code>change</code> ens permet canviar les propietats d'un missatge. Per exemple, el nostre cas anterior, podem afegir una propietat <code>alert</code> al missatge si la temperatura \u00e9s superior a 30\u00baC o si la humitat \u00e9s superior al 70%. Tamb\u00e9 podem canviar el valor d'una propietat, o eliminar-la. Fins i tot podem, si ens interessa, modificar el valor de <code>Payload</code>.</p> <p>El node <code>Change</code> del nostre exemple quedaria aix\u00ed:</p> <p>Ara podem combinar els nodes <code>Switch</code> i <code>Change</code> per enviar un missatge d'alerta si la temperatura \u00e9s superior a 30\u00baC o si la humitat \u00e9s superior al 70%, o simplement mostrar els valors si s\u00f3n normals. </p> <p></p> <p>El <code>Switch</code> de la temperatura t\u00e9 dues eixides: </p> <ul> <li>la 1 si el valor \u00e9s major que 30, i la 2 si no ho \u00e9s. La 1 porta al node <code>Change</code> que afegeix la propietat <code>alert</code> al missatge, i finalment el node <code>debug</code> mostra l'alerta. La 2 porta directament al node <code>debug</code> que mostra el missatge transformat en un JSON llegible.</li> </ul> <p></p> <p>El <code>Switch</code> de la humitat t\u00e9 dues eixides:</p> <ul> <li>la 1 si el valor \u00e9s major que 70, i la 2 si no ho \u00e9s. La 1 porta al node <code>Change</code> que afegeix la propietat <code>alert</code> al missatge, i finalment el node <code>debug</code> mostra l'alerta. La 2 porta directament al node <code>debug</code> que mostra el missatge transformat en un JSON llegible.</li> </ul> <p>L'esquema \u00e9s el mateix que hem vist per la temperatura.</p>"},{"location":"u04/nodered-intermedi/#random","title":"Random","text":"<p>El node <code>random</code> ens permet generar valors aleatoris. Aix\u00f2 pot ser \u00fatil per simular sensors, o per fer proves, com anem a fer a continuaci\u00f3. </p> <p>En l'exemple anterior de la temperatura i la humitat, si volem saber qu\u00e8 passa al canviar els valors d'entrada hem d'editar el node <code>inject</code> cada vegada. Utilitzant un node <code>random</code>, podem fer que el node d'injecci\u00f3 li envie una senyal al <code>random</code> i que este genere els valors aleat\u00f2riament. A m\u00e9s, com sabem, podem saber que el node <code>inject</code> envie una senyal cada cert temps per a que se generen els valors.</p> <p>El nostre exemple anterior, utilitzant nodes <code>random</code> per generar els valors, quedaria aix\u00ed:</p> <p></p> <p>El node <code>random</code> nom\u00e9s genera valors num\u00e8rics. Per a generar altres tipus de valors, podem utilitzar el node <code>data-generator</code>, que segurament haurem d'instal\u00b7lar des de la paleta de la dreta. </p> <p>Amb <code>data-generator</code> podem generar dades amb sentit, textos que tinguen un significat. Per exemple, li podem dir que genere noms ficticis, adreces i poblacions inventades, i tamb\u00e9 numeros que estiguen dins d'un rang determinat. Ac\u00ed teniu un exemple de generador de dades d'una persona:</p> <p></p> <p></p> <p></p>"},{"location":"u05/","title":"Introducci\u00f3","text":"<p>En esta unitat veurem qu\u00e8 \u00e9s Fiware, com funciona i com podem utilitzar-lo per a desenvolupar aplicacions que utilitzen dades obertes. En primer lloc, anem a veure alguns conceptes b\u00e0sics que necessitem con\u00e8ixer o repassar.</p>"},{"location":"u05/#broker-de-dades","title":"Broker de dades","text":"<p>Un broker de dades \u00e9s un component de software que permet als desenvolupadors de software accedir a dades de diferents fonts. El broker de dades actua com a intermediari entre la font on estan les dades que necessitem i les aplicacions que volen accedir a elles.</p> <p>Exemples de brokers de dades s\u00f3n Orion o Kafka. Orion \u00e9s un broker de dades que permet als desenvolupadors accedir a dades obertes de diferents fonts, com ara sensors, xarxes socials o bases de dades. Kafka \u00e9s un altre broker de dades que permet als desenvolupadors accedir a dades en temps real. </p> <p>El funcionament d'un broker de dades se basa, en general, en la subscripci\u00f3 a les fonts de dades a les quals volem tindre acc\u00e9s. Podrem accedir a les dades de v\u00e0ries formes: </p> <ul> <li>Subscripci\u00f3 a dades en temps real: el broker de dades ens notificar\u00e0 quan hi haja noves dades disponibles.</li> <li>Consulta de dades: el broker de dades ens permetr\u00e0 realitzar consultes a les dades que estan disponibles, o descarregar-les.</li> </ul> <p>En el nostre m\u00f2dul estudiarem com utilitzar Orion per a accedir a dades obertes. En el m\u00f2dul de Sistemes Big Data veureu Kafka, encara que potser nosaltres tamb\u00e9 farem alguna pr\u00e0ctica per entendre com funciona.</p>"},{"location":"u05/#topic","title":"T\u00f2pic","text":"<p>Un t\u00f2pic \u00e9s una categoria o un canal al qual es poden subscriure els usuaris per rebre missatges o dades relacionades amb aquest tema. Els t\u00f2pics s'utilitzen en sistemes de missatgeria i brokers de dades per organitzar i distribuir la informaci\u00f3 de manera eficient. Per exemple, en un sistema de monitoratge ambiental, podr\u00edem tenir diferents t\u00f2pics per a cada tipus de sensor, com ara un t\u00f2pic per a sensors de temperatura, un altre per a sensors d'humitat, etc. El t\u00f2pic podria tamb\u00e9 estar relacionat amb una ubicaci\u00f3 geogr\u00e0fica espec\u00edfica, com ara una ciutat concreta.</p>"},{"location":"u05/#api-repas-rapid","title":"API. Rep\u00e0s r\u00e0pid.","text":"<p>Com ja sabeu, una API (Application Programming Interface) \u00e9s un conjunt d'eines que permeten als desenvolupadors de software interactuar amb un sistema de software. Les APIs poden ser de molts tipus, per\u00f2 en general permeten als desenvolupadors realitzar les operacions b\u00e0siques (CRUD: Create, Read, Update, Delete) sobre un repositori de dades, oferint-les en forma de serveis web.</p>"},{"location":"u05/#ngsiv2-i-ngsi-ld","title":"NGSIv2 i NGSI-LD","text":"<p>NGSI (Next Generation Service Interface) \u00e9s un est\u00e0ndard per a la gesti\u00f3 de dades de context en sistemes d'informaci\u00f3. Hi ha dues versions principals d'este est\u00e0ndard: NGSIv2 i NGSI-LD. </p> <ul> <li>NGSIv2 \u00e9s la versi\u00f3 original i es basa en el model de dades JSON. Esta versi\u00f3 \u00e9s \u00e0mpliament utilitzada en moltes aplicacions i sistemes d'informaci\u00f3. La informaci\u00f3 est\u00e0 organitzada en entitats, atributs i metadades opcionals. T\u00e9 suport per GEOJSON per a la representaci\u00f3 de dades geoespacials, i tamb\u00e9 per a la gesti\u00f3 de temps.</li> </ul> <p></p> <ul> <li>NGSI-LD \u00e9s una versi\u00f3 m\u00e9s recent que es basa en el model de dades JSON-LD (JSON for Linked Data).Esta versi\u00f3 est\u00e0 dissenyada per a ser m\u00e9s flexible i representar relacions entre les entitats utilitzant grafs. Aix\u00f2 permetre la integraci\u00f3 amb altres sistemes d'informaci\u00f3 basats en dades enlla\u00e7ades.</li> </ul> <p>En Orion Context Broker es pot utilitzar tant NGSIv2 com NGSI-LD per a gestionar les dades de context. La tria entre una versi\u00f3 o una altra dependr\u00e0 dels requisits espec\u00edfics de l'aplicaci\u00f3 que estem desenvolupant.</p>"},{"location":"u05/#ontologia-de-les-dades","title":"Ontologia de les dades","text":"<p>Una ontologia de les dades \u00e9s una descripci\u00f3 formal de les dades que permet als desenvolupadors de software entendre qu\u00e8 representen les dades i com estan relacionades entre elles. \u00c9s un concepte similar al de esquema o model en bases de dades relacionals, per\u00f2 m\u00e9s flexible i pot descriure relacions m\u00e9s complexes entre les dades. </p> <p>La ontologia de les dades, en contextos on la informaci\u00f3 \u00e9s compartida, permet establir un llenguatge com\u00fa entre diferents sistemes i aplicacions. Aix\u00f2 facilita la interoperabilitat i la integraci\u00f3 de dades de diferents fonts. Principalment una ontologia defineix un model sem\u00e0ntic que inclou:</p> <ul> <li>Entitats: els objectes o conceptes que es volen representar.</li> <li>Atributs: les propietats o caracter\u00edstiques de les entitats.</li> <li>Relacions: les connexions entre les entitats.</li> <li>Regles: les restriccions o condicions que s'apliquen a les entitats, atributs i relacions.</li> </ul>"},{"location":"u05/#fiware","title":"FIWARE","text":"<p>FIWARE \u00e9s una plataforma de codi obert, impulsada per la Uni\u00f3 Europea, per al desenvolupament i el desplegament global d'aplicacions relacionades amb IoT (Internet of Things). </p> <p>P\u00e0gina web de FIWARE</p> <p>Es tracta d'una iniciativa que defineix un conjunt universal de est\u00e0ndards per a la gesti\u00f3 de dades de context. Aix\u00f2 implica definir, com hem comentat abans, una ontologia de les dades. Aix\u00ed se facilita el desenvolupament de solucions per a diferents dominis, com per exemple Smart Cities, Smart Industry, Smart Agrifood i Smart Energy.</p> <p></p>"},{"location":"u05/#arquitectura-de-fiware","title":"Arquitectura de FIWARE","text":"<p>La plataforma FIWARE est\u00e0 formada per diferents components que permeten als desenvolupadors accedir a dades de context de diferents fonts. Aquests components es poden agrupar en tres capes:</p> <ul> <li>Capa de dades: en aquesta capa es troben els brokers de dades que permeten als desenvolupadors accedir a dades de context de diferents fonts. Com a broker de dades de FIWARE es fa servir Orion Context Broker (OCB).</li> <li>Capa de processament: en aquesta capa es troben els components que permeten als desenvolupadors processar les dades de context. Aquests components poden ser Cygnus o Stardog.</li> <li>Capa d'aplicaci\u00f3: en aquesta capa es troben els components que permeten als desenvolupadors desenvolupar aplicacions que utilitzen les dades de context. Aquests components poden ser Wirecloud o Keyrock.</li> <li>Capa de gesti\u00f3: en aquesta capa es troben els components que permeten als administradors gestionar la plataforma FIWARE. Aquests components poden ser Orion-LD o Keyrock.</li> </ul> <p></p>"},{"location":"u05/#exemples-darquitectures-fiware","title":"Exemples d'arquitectures FIWARE","text":""},{"location":"u05/#smart-data-models","title":"Smart Data Models","text":"<p>Els Smart Data Models s\u00f3n una part fonamental de FIWARE. Es tracta d'una col\u00b7lecci\u00f3 de models de dades que defineixen com representar les dades de context en diferents dominis. Aquests models de dades estan definits en forma de ontologies, un concepte que, com hem vist, permet als desenvolupadors entendre el significat de les dades.</p> <p>Les ontologies dels Smart Data Models se basen en un llenguatge anomenat JSON Schema, que permet descriure l'estructura de les dades i les restriccions que han de complir. En el context de FIWARE i Smart Data Models, un JSON Schema defineix els atributs i les propietats que han de tenir les entitats que formen part del model de dades. En certs casos, cal definir dos atributs obligatoris per a les entitats:</p> <ul> <li>id: un identificador \u00fanic per a l'entitat.</li> <li>type: el tipus d'entitat</li> </ul> <p>Cada element dins de l'entitat pot tindre diversos atributs que venen definits, si volem utilitzar est\u00e0ndars validats per Fiware, per una ontologia. En general se demanen els seg\u00fcents atributs b\u00e0sics:</p> <ul> <li>name</li> <li>type</li> <li>description</li> <li>value </li> <li>location (ubicaci\u00f3 geogr\u00e0fica)</li> <li>dateObserved (data i hora d'observaci\u00f3)</li> </ul> <p>De totes formes, si volem utilitzar un model de dades est\u00e0ndar hem de seguir les seues especificacions. No cal utilitzar-les totes, nom\u00e9s les que necessitem (a banda de les obligat\u00f2ries). La idea \u00e9s que qualsevol informaci\u00f3 que compartim seguint un model de dades est\u00e0ndar siga comprensible per a qualsevol altre desenvolupador que utilitze el mateix model. I el mateix quan nosaltres actuem com a consumidors.</p> <p>La definici\u00f3 d'un model de dades intel\u00b7ligent inclou quatre elements: </p> <ul> <li>l'esquema o representaci\u00f3 t\u00e8cnica del model que defineix els tipus de dades t\u00e8cniques i l'estructura. Se poden afegir propietats noves, pr\u00f2pies, a un esquema que ja existeix.</li> <li>l'especificaci\u00f3 d'un document escrit per a lectors humans</li> <li>una URI amb una URL de treball amb dades b\u00e0siques sobre l'atribut o l'entitat</li> <li>exemples de les c\u00e0rregues \u00fatils per a les versions NGSIv2 i NGSI-LD</li> </ul> <p>Tots els models de dades s\u00f3n p\u00fablics i de naturalesa lliure de drets d'autor. La modalitat de llic\u00e8ncia atorga 3 drets als usuaris:</p> <ul> <li>\u00das gratu\u00eft</li> <li>Modificaci\u00f3 gratu\u00efta</li> <li>Compartici\u00f3 gratu\u00efta de les modificacions</li> </ul> <p>Cat\u00e0leg de Smart Data Models</p> <p>Fiware Data-Models actualitzats</p>"},{"location":"u05/#estructura-dun-smart-data-model","title":"Estructura d'un Smart Data Model","text":"<p>Els Smart Data Models s'agrupen en temes. Cada tema pot pert\u00e0nyer a un domini o a m\u00e9s d'un. Els dominis representen sectors o contexts on s'utilitzen els models de dades. </p> <p>Un Smart Data Model est\u00e0 format per diferents elements:</p> <ul> <li>Context Model: es una descripci\u00f3 formal de les entitats que formen part del model de dades.</li> <li>Data Model: \u00e9s una descripci\u00f3 formal dels atributs que formen part de les entitats, incloent un identificador \u00fanic, el seus tipus, valors i possibles restriccions.</li> </ul> <p>Els Data Model estan codificats, com hem comentat, seguint un JSON Schema. Un esquema ens permet descriure l'estructura de les dades i les restriccions que han de complir. Els models estan normalment disponibles en repositoris de GitHub. </p> <p>Per exemple, des del seg\u00fcent enlla\u00e7 podem accedir al Smart Data Model de Vehicle:</p> <p>Vehicle Smart Data Model</p> <p>Des d'este enlla\u00e7 podem accedir al Smart Data Model de Weather Observed:</p> <p>Weather Observed Smart Data Model</p>"},{"location":"u05/#orion-context-broker-ocb","title":"Orion Context Broker (OCB)","text":"<p>Orion Context Broker (OCB) \u00e9s un broker de dades que permet als desenvolupadors accedir a dades de context de diferents fonts. OCB \u00e9s un dels components m\u00e9s importants de FIWARE i es fa servir en moltes aplicacions que utilitzen dades de context. Com qualsevol broker, OCB permet als desenvolupadors subscriure's a les dades de context que els interessen i rebre notificacions quan hi haja noves dades disponibles.</p> <p>OCB permet la publicaci\u00f3 d'informaci\u00f3 de context per part de entitats productores (per exemple, sensors IoT o aplicacions que els facen servir). Altres entitats consumidores poden consultar esta informaci\u00f3 mitjan\u00e7ant subscripcions per rebre notificacions quan hi haja canvis en la informaci\u00f3 de context, o amb una freq\u00fc\u00e8ncia determinada.</p> <p></p>"},{"location":"u05/#funcionament-especific-dorion","title":"Funcionament espec\u00edfic d'Orion","text":"<p>Orion utilitza un model de dades anomenat NGSI (Next Generation Service Interface). Este model de dades defineix com representar les dades de context i com accedir a elles. Permet realitzar operacions com ara:</p> <ul> <li>registrar aplicacions de productors de context (per exemple, un nou sensor IoT)</li> <li>actualitzar la informaci\u00f3 de context</li> <li>consultar la informaci\u00f3 de context</li> <li>subscriure's a canvis en la informaci\u00f3 de context</li> </ul> <p>Un principi fonamental d'OCB \u00e9s la separaci\u00f3 entre productors i consumidors. \u00c9s a dir, els productors publiquen dades de context sense preocupar-se de qui les consumir\u00e0, i els consumidors accedeixen a les dades de context sense preocupar-se de qui les ha publicat. El principal avantatge \u00e9s que l'emisor i el receptor de les dades no han d'estar connectats directament.</p> <p>El servidor OCB sempre est\u00e0 escoltant, generalment a trav\u00e9s del port 1026. Per a interactuar amb ell, podem fer servir eines com Postman, cURL o qualsevol altre client HTTP que ens permeta realitzar peticions RESTful. Aix\u00ed, si tenim el broker en funcionament podem accedir a veure llistats d'entitats, crear noves entitats, realizar consultes, etc.</p> <p>OCB no \u00e9s una base de dades, sin\u00f3 un broker de dades. Aix\u00f2 significa que les dades que s'hi emmagatzemen poden ser temporals i poden ser esborrades quan el broker es reinicia, a menys que s'utilitze un connector per a una base de dades externa com MongoDB. En general nom\u00e9s se guarda l'estat actual de les dades de context d'una entitat, no els canvis al llarg del temps. Per exemple, si actuem com a productors, no \u00e9s bona pr\u00e0ctica crear entitats noves per a cada lectura d'un sensor, sin\u00f3 actualitzar l'entitat existent amb les noves dades.</p> <p>Per exemple, si alcem un servidor OCB de forma local i volem veure totes les entitats que tenim en el broker, podem fer una petici\u00f3 GET a la seg\u00fcent URL:</p> <pre><code>http://localhost:1026/v2/entities\n</code></pre> <p>Recordeu canviar el vostre port si no \u00e9s el 1026, aix\u00ed com la IP si no \u00e9s localhost.</p> <p>Ens dir\u00e0, l\u00f2gicament, que no hi ha cap entitat encara. Podem provar Esta petici\u00f3 ens retornar\u00e0 un llistat de totes les entitats que tenim en el broker. Podem crear noves entitats fent una petici\u00f3 POST a la mateixa URL, enviant les dades de l'entitat en format JSON.</p> <p>Fins fa uns mesos se podien fer proves utilitzant el n\u00favol de Fiware, pero ara l'adre\u00e7a no est\u00e0 disponible i no he trobat alternatives nom\u00e9s que amb m\u00e0quines virtuals en el n\u00favol. Per tant, instal\u00b7larem Orion de forma local utilitzant Docker amb un fitxer docker-compose.yml que trobareu a Aules.</p> <p>Despr\u00e9s veurem com utilitzar Orion amb MongoDB i Node-RED amb un exemple pr\u00e0ctic. </p>"},{"location":"u05/#enllacos-dinteres","title":"Enlla\u00e7os d'inter\u00e8s","text":"<p>https://www.esmartcity.es/comunicaciones/i-congreso-ciudades-inteligentes-fiware</p> <p>https://www.ciudadesdelfuturo.org.ar</p> <p>https://www.fiware.org/smart-data-models/</p> <p>https://github.com/smart-data-models</p> <p>https://telefonicaiotcb.docs.apiary.io/#</p> <p>https://oriontourguide.docs.apiary.io/</p>"},{"location":"u06/","title":"Introducci\u00f3","text":"<p>MQTT \u00e9s un protocol de missatgeria lleugera que es va desenvolupar per a dispositius amb recursos limitats, com ara sensors. Aquest protocol \u00e9s molt popular en el m\u00f3n de l'Internet of Things (IoT) perqu\u00e8 permet als dispositius enviar i rebre missatges de forma eficient i fiable. </p> <p>El seu avantatge respecte a altres protocols similars \u00e9s que \u00e9s molt senzill i consumeix molt pocs recursos, cosa que el fa ideal per a dispositius amb poca pot\u00e8ncia de processament i poca mem\u00f2ria. A m\u00e9s, MQTT utilitza un model de comunicaci\u00f3 Pub/Sub (Publicar/Suscribir), que permet una gran flexibilitat i escalabilitat en la comunicaci\u00f3 entre dispositius.</p> <p>No hem de confondre MQTT, que \u00e9s un protocol de missatgeria, amb Orion, que \u00e9s un broker de dades. MQTT \u00e9s un protocol que defineix com es comuniquen els dispositius, mentre que Orion \u00e9s una plataforma que pot utilitzar diferents protocols de comunicaci\u00f3, incl\u00f2s MQTT, per a gestionar i processar les dades dels dispositius.</p> <p>A m\u00e9s, MQTT no sap res d'entitats ni del context, nom\u00e9s envia i rep missatges per t\u00f2pics. \u00c9s el broker, com per exemple Orion, el que s'encarrega de gestionar les entitats i el context associat a cada missatge.</p> <p>Anem a veure primer alguns conceptes associats als protocols de comunicaci\u00f3 / missatgeria.</p>"},{"location":"u06/#protocols-de-comunicacio-iot","title":"Protocols de comunicaci\u00f3 IOT","text":"<p>IoT (Internet of Things) \u00e9s un concepte molt d'actualitat en els darrers anys. Fa refer\u00e8ncia a la interconnexi\u00f3 digital d'objectes quotidians amb Internet. Aquests objectes poden ser des de electrodom\u00e8stics fins a vehicles, passant per qualsevol tipus de sensor o dispositiu electr\u00f2nic.</p> <p>Els protocols de comunicaci\u00f3 s\u00f3n els encarregats de definir com s'han de comunicar els dispositius. Un protocol de comunicaci\u00f3 estableix les regles que han de seguir els dispositius per a comunicar-se entre ells i poder intercanviar informaci\u00f3.</p> <p>Algunes caracter\u00edstiques desitjables per a un protocol de comunicaci\u00f3 s\u00f3n:</p> <ul> <li>Efici\u00e8ncia: que siga r\u00e0pid, que permete gran quantitat de comunicacions simult\u00e0nies i minimitze tant les dimensions dels missatges com el consum de recursos.</li> <li>Escalabilitat: que se puguen afegir o retirar dispositius sense que el comportament del sistema es veja afectat.</li> <li>Escasa depend\u00e8ncia: que la depend\u00e8ncia entre els dispositius siga la menor possible.</li> <li>Interoperabilitat: que siga compatible amb diferents dispositius i sistemes.</li> <li>Seguretat: hem de tindre en compte que tant els dispositius com les comunicacions entre ells funcionen a trav\u00e9s de la xarxa i per tant poden ser vulnerables a atacs.</li> <li>Acc\u00e9s senzill als dispositius: ha de ser f\u00e0cil connectar-se als dispositius i controlar-los. S'han de preveure problemes amb adreces din\u00e0miques, DHCP, poc ample de banda, etc.</li> </ul> <p>Hi ha molts protocols de comunicaci\u00f3 com per exemple un que ja coneixeu, HTTP. Un dels m\u00e9s populars en l'\u00e0mbit de l'IoT \u00e9s MQTT (Message Queuing Telemetry Transport).</p>"},{"location":"u06/#solucions-a-la-comunicacio-iot","title":"Solucions a la comunicaci\u00f3 IoT","text":"<p>Una possible soluci\u00f3 als problemes que ens podem trobar al treballar en un entorn IoT \u00e9s utilitzar un servei de notificacions centralitzat. Aix\u00f2 ho hem vist, per exemple, al parlar de Brokers de dades, d'Orion i tamb\u00e9 de Kafka, per\u00f2 que pot ser tamb\u00e9 un element f\u00edsic del sistema. Se tracta d'externalitzar la infraestructura m\u00e9s costosa, cosa que cada vegada \u00e9s m\u00e9s com\u00fa en les empreses. </p> <p></p> <p>En este esquema un servidor central s'encarrega de rebre els missatges de tots els dispositius emisors i lliurar-los als receptors. El servidor t\u00e9 una adre\u00e7a / domini conegut per tots els dispositius, que nom\u00e9s se comuniquen amb ell. Aix\u00ed assegurem l'escalabilitat del sistema i la independ\u00e8ncia entre els dispositius.</p>"},{"location":"u06/#metodologies-de-comunicacio-publishsubscribe","title":"Metodologies de comunicaci\u00f3: Publish/Subscribe","text":"<p>El patr\u00f3 Publish/Subscribe, o Pub/Sub, se basa en l'esquema que acabem de veure: els diferents agents (emisors/publisher i receptors/subscriber) no es coneixen entre ells, sin\u00f3 que es comuniquen a trav\u00e9s d'un intermediari (broker). Els receptors informen al broker dels missatges que volen rebre i el broker s'encarrega de lliurar-los. Els emisors s\u00f3n els que publiquen els missatges que despr\u00e9s el broker distribueix als receptors.</p> <p>La forma en qu\u00e8 se distribueixen els missatges pot ser de diferents maneres.</p>"},{"location":"u06/#cua-de-missatges-message-queue","title":"Cua de missatges (message queue)","text":"<p>El broker genera una cua de missatges \u00fanica per cadascun dels clients (receptors/subscribers). Els missatges se discriminaran utilitzant l'identificador \u00fanic de cada client. La cua mant\u00e9 els missatges fins que s\u00f3n lliurats als clients. Aix\u00f2 permet que els clients puguen rebre missatges encara que no estiguen connectats en el moment que es produeixen. Exemple d'este tipus de comunicaci\u00f3 serien serveis com ara Telegram o WhatsApp. </p> <p></p>"},{"location":"u06/#servei-de-missatgeria-message-service","title":"Servei de missatgeria (message service)","text":"<p>El broker distribueix directament als clients connectats. Els missatges se filtren per diferents criteris. Els missatges que s'han enviat mentre el client est\u00e0 desconnectat se perden. Un exemple seria un xat en temps real, on quan entrem a la sala no rebem els missatges que s'han enviat abans de connectar-nos.</p> <p></p> <p>MQTT \u00e9s un exemple de protocol Pub/Sub que utilitza la metodologia message queue. Un altre protocol similar seria AMQP (Advanced Message Queuing Protocol), encara que no seria tan lleuger com MQTT i per tant s'utilitza menys en IoT i m\u00e9s en entorns empresarials.</p>"},{"location":"u06/#mqtt","title":"MQTT","text":"<p>MQTT (Message Queuing Telemetry Transport) \u00e9s, com hem comentat, un protocol de missatgeria lleugera que es va desenvolupar per a dispositius amb recursos limitats, com ara sensors. Funciona seguint el protocol M2M2 (Machine to Machine), que se basa en el model de comunicaci\u00f3 Pub/Sub i en la pila TCP/IP. \u00c9s de tipus Message Queue. MQTT va ser creat per IBM en 1999, i posteriorment (2010) se va alliberar i finalment s'ha convertit en un est\u00e0ndar obert.</p>"},{"location":"u06/#com-funciona-mqtt","title":"Com funciona MQTT","text":"<p>Com hem vist, el funcionament de MQTT se basa en el patr\u00f3 Pub/Sub i en l'exist\u00e8ncia d'un broker central que rep, selecciona i distribueix els missatges. </p> <p>Els missatges s'organitzen en t\u00f2pics disposats de forma jer\u00e0rquica. Un client envia missatges a certs t\u00f2pics, i uns altres se poden subscriure a aquests t\u00f2pics per a rebre els missatges. MQTT utilitza, per defecte, el port 1883. Si funciona sobre TLS (MQTTs amb claus de comunicaci\u00f3 segura) utilitza el port 8883. </p>"},{"location":"u06/#topics","title":"T\u00f2pics","text":"<p>Un t\u00f2pic \u00e9s un filtre que utilitza MQTT per a distribuir els missatges. Cada t\u00f2pic s'identifica per una cadena UTF-8 amb una longitud m\u00e0xima de 65536 car\u00e0cters. Els noms dels t\u00f2pics s\u00f3n case sensitive, que com ja sabeu vol dir que distingeix entre maj\u00fascules i min\u00fascules. Per tant els t\u00f2pics casa i Casa serien diferents.</p> <p>Els t\u00f2pics s'organitzen de forma jer\u00e0rquica, separats per barres inclinades (/). Per exemple, el t\u00f2pic <code>casa/sensor/temperatura</code> indica que el missatge es refereix a la temperatura d'un sensor d'una casa. Els t\u00f2pics poden tindre molts subt\u00f2pics, i cada subt\u00f2pic tamb\u00e9 pot dividir-se en altres subt\u00f2pics.</p> <p></p> <p>El broker accepta qualsevol t\u00f2pic. Si no existeix, se crea en eixe instant. Cada publicaci\u00f3 s'envia a un t\u00f2pic, per\u00f2 els clients se poden subscriure a un o m\u00e9s t\u00f2pics (fins i tot si no exiteix el t\u00f2pic, en funci\u00f3 de com ho tenim configurat). Per a subscriure's a m\u00faltiples t\u00f2pics a la vegada s'utilitzen els comodins o wildcards. Hi ha dos opcions:</p> <ul> <li>+: substitueix un nivell del t\u00f2pic. Per exemple, <code>casa/sensor/+/temperatura</code> permet subscriure's a qualsevol sensor de temperatura d'una casa. Un altre exemple: <code>casa/sala/+</code> permet subscriure's a qualsevol subt\u00f2pic dins de <code>casa/sala</code>, per\u00f2 no als subt\u00f2pics de nivell inferior, perqu\u00e8 + nom\u00e9s substitueix un nivell.</li> </ul> <p></p> <ul> <li>#: substitueix tots els nivells del t\u00f2pic. Per exemple, <code>casa/#</code> permet subscriure's a qualsevol t\u00f2pic de la casa, siga del nivell que siga. El s\u00edmbol # nom\u00e9s es pot utilitzar al final del t\u00f2pic.</li> </ul> <p>L\u00f2gicament no se pot posar + al principi, perqu\u00e8 no tendria sentit. Si no sabem el t\u00f2pic inicial no es podem subscriure. En cas de posar # al principi ens subscriuriem a tots els t\u00f2pics, i aix\u00f2 pot ser un problema de seguretat, inefic\u00e8ncia i rendiment.</p> <p></p>"},{"location":"u06/#mqtt-i-qos","title":"MQTT i QoS","text":"<p>MQTT permet especificar el nivell de qualitat de servei (QoS) que es vol per a cada missatge. Aix\u00f2 permet adaptar la comunicaci\u00f3 a les necessitats de cada aplicaci\u00f3 i gestionar la toler\u00e0ncia a errors.</p> <p>Hi ha tres nivells de QoS:</p> <ul> <li>QoS 0: At most once. El missatge es lliura com a molt una vegada. No es garanteix que el missatge arribe al receptor, en cas d'errades. \u00c9s el m\u00e9s r\u00e0pid i menys fiable.</li> <li>QoS 1: At least once. El missatge es lliura com a m\u00ednim una vegada. Es garanteix que el missatge arribe al receptor, per\u00f2 pot arribar m\u00e9s d'una vegada amb la qual cosa certs missatges estaran duplicats. \u00c9s m\u00e9s lent i m\u00e9s fiable que QoS 0.</li> <li>QoS 2: Exactly once. El missatge es lliura exactament una vegada. \u00c9s el m\u00e9s lent per\u00f2 tamb\u00e9 el m\u00e9s fiable.</li> </ul>"},{"location":"u06/#seguretat","title":"Seguretat","text":"<p>Per a garantir la seguretat de les comunicacions, MQTT disposa de:</p> <ul> <li>Transport SSL/TLS (MQTTs) per a xifrar les comunicacions.</li> <li>Autenticaci\u00f3 per usuari i contrasenya, o amb certificat. </li> </ul>"},{"location":"u06/#avantatges-de-mqtt","title":"Avantatges de MQTT","text":"<p>Com hem vist abans, els protocols que utilitzen el patr\u00f3 Pub/Sub tenen avantatges comuns:</p> <ul> <li>Escalabilitat: es poden afegir o retirar clients sense afectar el sistema.</li> <li>Asincronia: els clients (l'emisor i el receptor) no han d'estar connectats al mateix temps.</li> <li>Desacoblament: els clients no es coneixen entre ells.</li> </ul> <p>Altres avantatges de MQTT:</p> <ul> <li>\u00c9s senzill i lleuger, f\u00e0cil d'implementar i utilitzar.</li> <li>Baix consum.</li> <li>No necessita un ample de banda elevat.</li> </ul>"},{"location":"u06/#principals-brokers-mqtt-de-codi-obert","title":"Principals brokers MQTT de codi obert","text":"<p>Hi ha molts brokers MQTT de codi obert. Alguns dels m\u00e9s populars s\u00f3n:</p> <ul> <li>Mosquitto: desenvolupat per la Eclipse Foundation. \u00c9s un dels m\u00e9s populars i utilitzats. \u00c9s lleuger i s'utilitza per a servidors de baixa pot\u00e8ncia.</li> <li>Mosca: desenvolupat per a Node.js en JavaScript. Se pot utilitzar com a m\u00f2dul de Node.js.</li> <li>Aedes: est\u00e0 escrit en Python i utilitza la biblioteca Asyncio.</li> <li>RabbitMQ: no \u00e9s exactament MQTT sino que funciona m\u00e9s com un protocol de missatgeria AMQP.</li> </ul>"},{"location":"u06/#exemple-dus-de-mqtt","title":"Exemple d'\u00fas de MQTT","text":"<p>Per a veure un exemple d'\u00fas de MQTT podem utilitzar el broker Mosquitto. Per a aix\u00f2, primer hem d'instal\u00b7lar-lo. En distribucions basades en Debian (com ara Ubuntu) es pot fer amb la comanda:</p> <pre><code>sudo apt-get install mosquitto\n</code></pre> <p>Un cop instal\u00b7lat, podem iniciar el broker amb la comanda:</p> <pre><code>sudo systemctl start mosquitto\n</code></pre> <p>A continuaci\u00f3, podem utilitzar el client de l\u00ednia de comandes mosquitto_pub per a publicar missatges i mosquitto_sub per a subscriure'ns a t\u00f2pics i rebre missatges. Per exemple, per a publicar un missatge al t\u00f2pic <code>casa/sensor/temperatura</code>:</p> <pre><code>mosquitto_pub -h localhost -t casa/sensor/temperatura -m \"25.5\"\n</code></pre> <p>I per a subscriure'ns al mateix t\u00f2pic i rebre els missatges:</p> <pre><code>mosquitto_sub -h localhost -t casa/sensor/temperatura\n</code></pre> <p>Amb aix\u00f2, cada vegada que publiquem un missatge al t\u00f2pic <code>casa/sensor/temperatura</code>, el client subscrit rebr\u00e0 el missatge i el mostrar\u00e0 per pantalla.</p> <p>Si no voleu o no podeu instal\u00b7lar el broker localment, ho feu en el contenidor que teniu penjat a Aules. A classe veurem el proc\u00e9s complet.</p> <p>L\u00f2gicament, tamb\u00e9 podem treballar amb el protocol MQTT des de qualsevol llenguatge de programaci\u00f3, utilitzant les biblioteques adequades. Per exemple, en Python podem utilitzar la biblioteca paho-mqtt per a publicar i subscriure'ns a t\u00f2pics MQTT. En Node-RED tamb\u00e9 tenim nodes espec\u00edfics per a treballar amb MQTT, que ens permeten integrar f\u00e0cilment aquest protocol en els nostres fluxos de dades. Veurem exemples de tot aix\u00f2 a classe.</p>"},{"location":"u07/","title":"STACK ELK (ELASTICSEARCH, LOGSTASH, KIBANA)","text":"<p>Elastic Stack o tamb\u00e9 conegut com ELK Stack \u00e9s una plataforma de codi obert desenvolupat per l'empresa Elastic. La plataforma permet la recopilaci\u00f3, l'arxivament, la visualitzaci\u00f3 i l'an\u00e0lisi de dades. Per a realitzar eixes funcions Elastic Stack inclou un sistema d'emmagatzematge distribu\u00eft, un motor de recerca i de processament, i un sistema de visualitzaci\u00f3. </p>"},{"location":"u07/#introduccio","title":"INTRODUCCI\u00d3","text":"<p>La plataforma ELK est\u00e0 formada per quatre components:</p> <ul> <li>Elasticsearch: \u00c9s un motor de recerca i an\u00e0lisi de dades distribu\u00eft i altament escalable. Permet emmagatzemar, buscar i analitzar grans volums de dades en temps real.</li> <li>Logstash: \u00c9s una eina d'ingesta, processament i transformaci\u00f3 de dades. Permet recopilar dades de diverses fonts, transformar-les i enviar-les a Elasticsearch.</li> <li>Kibana: \u00c9s una eina de visualitzaci\u00f3 de dades. Permet crear gr\u00e0fics, taules i mapes a partir de les dades emmagatzemades a Elasticsearch. Tamb\u00e9 permet interactuar amb les dades directament.</li> <li>Beats: S\u00f3n agents lleugers que recopilen dades de diverses fonts i les envien a Logstash o Elasticsearch.</li> </ul> <p>Podr\u00edem dir que Logstash \u00e9s l'eina que fa l'ingesta de dades, llegint de diferents fonts i amb diferents formats, processant les dades per guardar-les en Elasticsearch, i despr\u00e9s Kibana accedir\u00e0 a les dades per analitzar-les, representar-les gr\u00e0ficament, crear dashboards, etc.</p> <p>Una de les principals utilitats de Elastic Stack \u00e9s la gesti\u00f3 i an\u00e0lisi de <code>logs</code>, i de qualsevol fluxe de dades en general, en arquitectures de programari amb components diversos on la informaci\u00f3 no segueix un model unificat. Amb esta soluci\u00f3 podem implementar un sistema de gesti\u00f3 i de visualitzaci\u00f3 de la informaci\u00f3 senzill d'operar i efica\u00e7. Amb ELK podem, per exemple, realitzar consultes en temps real per a identificar r\u00e0pidament errors o comportaments en els nostres sistemes.</p> <p>En alguns esquemes, com el que veurem a continuaci\u00f3, trobareu un altre component anomenat X-Pack. X-Pack \u00e9s una extensi\u00f3 de Elastic Stack que proporciona funcionalitats addicionals com la seguretat, la monitoritzaci\u00f3, la gesti\u00f3 de registres etc. fent \u00fas en moltes ocasions d'eines de Machine learning. X-Pack \u00e9s una soluci\u00f3 de pagament, per\u00f2 Elastic ofereix una llic\u00e8ncia gratu\u00efta per a \u00fas no comercial.</p> <p></p>"},{"location":"u07/#arquitectura-delastic-elk","title":"ARQUITECTURA D'ELASTIC ELK","text":"<p>L'arquitectura d'Elastic ELK est\u00e0 formada per:</p> <ul> <li>Nodes</li> <li>Cl\u00fasters</li> <li>\u00cdndexs</li> <li>Documents</li> <li>Shards i r\u00e8pliques</li> </ul>"},{"location":"u07/#nodes","title":"Nodes","text":"<p>Un node \u00e9s una inst\u00e0ncia d'Elasticsearch que forma part d'un cluster. Cada node t\u00e9 un identificador \u00fanic, un nom, i pot tenir diferents rols. Els nodes en general s'encarreguen del tr\u00e0fic HTTP en la capa d'aplicaci\u00f3 i en la capa de transport per a comunicar-se amb altres nodes del cluster. </p>"},{"location":"u07/#tipus-de-nodes","title":"Tipus de nodes","text":"<p>Segons les seues funcionalitats, els nodes poden ser:</p> <ul> <li>Master-node. </li> <li>Data-node.</li> <li>Ingest-node.</li> <li>Coordinating-only-node.</li> </ul>"},{"location":"u07/#master-node","title":"Master-node","text":"<p>Els nodes Master s\u00f3n els responsables de la gesti\u00f3 del cluster. Aquest tipus de nodes s\u00f3n els encarregats de realitzar tasques com:</p> <ul> <li>Mantenir la informaci\u00f3 dels nodes que formen el cluster.</li> <li>Mantenir la informaci\u00f3 dels \u00edndexs i els shards.</li> <li>Crear i eliminar \u00edndexs.</li> <li>Decidir en quin node se guardar\u00e0 un nou shard.</li> </ul> <p>El Master-node, idealment, hauria d'estar en un equip dedicat amb alta disponibilitat i toler\u00e0ncia a fallades. </p>"},{"location":"u07/#data-node","title":"Data-node","text":"<p>Els nodes Data s\u00f3n els encarregats de guardar les dades. Aquests nodes s\u00f3n els que contenen els shards i les r\u00e8pliques dels \u00edndexs. Realitzan funcions com:</p> <ul> <li>Operacions CRUD sobre les dades emmagatzemades</li> <li>Operacions de recerca obre les dades</li> <li>Operacions d'agregaci\u00f3 sobre les dades</li> </ul> <p>Els Data-nodes consumeixen molts recursos. \u00c9s recomanable tamb\u00e9, per tant, que estiguen en equips dedicats que formen un sistema distribu\u00eft amb creixement horitzontal.</p>"},{"location":"u07/#ingest-node","title":"Ingest-node","text":"<p>Els nodes Ingest s\u00f3n els encarregats de processar les dades abans de ser emmagatzemades. \u00c9s a dir, abans d'indexar les dades. Aquests nodes poden realitzar tasques com:</p> <ul> <li>Filtrar les dades.</li> <li>Normalitzar les dades.</li> <li>Enriquir les dades.</li> </ul> <p>Tamb\u00e9 anem a necessitar alta capacitat de processament si treballem amb velocitats de centenars o milers de dades per segon. </p>"},{"location":"u07/#coordinating-only-node","title":"Coordinating-only-node","text":"<p>Els nodes Coordinating-only s\u00f3n els encarregats de rebre les peticions dels clients i de distribuir-les als nodes Data. Aquests nodes no emmagatzemen dades, per tant, no consumeixen molts recursos. Les seues tasques principals s\u00f3n:</p> <ul> <li>Distribuir les peticions als nodes Data.</li> <li>Distribuir les indexacions.</li> </ul> <p>Estos nodes s\u00f3n balancejadors de c\u00e0rrega per ajudar a descarregar de feina al Master-node, principalment. En principi, nom\u00e9s serien necessaris si treballem amb grans volums de dades i molts clients.</p> <p></p>"},{"location":"u07/#documents","title":"Documents","text":"<p>Un document \u00e9s la unitat b\u00e0sica d'informaci\u00f3 que es pot emmagatzemar en Elasticsearch. Un document \u00e9s una estructura JSON que cont\u00e9 les dades que volem emmagatzemar en format clau:valor com en qualsevol document JSON. A m\u00e9s de les dades que anem a emmagatzemar, Elasticsearch tamb\u00e9 guarda metadades sobre el document. Les metadades d'un document s\u00f3n:</p> <ul> <li>_index: L'\u00edndex on es guardar\u00e0 el document.</li> <li>_type: El tipus de document.</li> <li>_id: L'identificador \u00fanic del document.</li> </ul> <p>\u00c9s una cosa semblant al que hem vist en Fiware amb els data-models, encara que ac\u00ed les metadades se poden guardar expl\u00edcitament en el document o indicar-les quan fem una operaci\u00f3 amb el document, per exemple un POST per guardar-lo.</p>"},{"location":"u07/#indexs","title":"\u00cdndexs","text":"<p>Un \u00edndex \u00e9s una col\u00b7lecci\u00f3 de documents que tenen caracter\u00edstiques similars (un cat\u00e0leg de productes, una llista de clients, factures...) Hem de remarcar similars perqu\u00e8 no necess\u00e0riament han de tindre la mateixa estructura tots els documents d'un \u00edndex. Aix\u00ed, es tracta d'un concepte similar al que en MongoDB seria una col\u00b7lecci\u00f3, o en SQL una taula per\u00f2 sense una estructura fixa.</p> <p>Un \u00edndex pot contenir molts documents i cada document pot estar en un \u00edndex.</p>"},{"location":"u07/#types","title":"Types","text":"<p>Un type \u00e9s una manera de classificar els documents d'un \u00edndex. Un schema defineix els camps que formen el type, i de quin tipus s\u00f3n: string, integer, boolean, date... Un \u00edndex pot tindre diversos tipus.</p> <p>A partir de la versi\u00f3 7.0 de Elasticsearch els tipus han quedat obsolets.</p>"},{"location":"u07/#shards-i-repliques","title":"Shards i r\u00e8pliques","text":"<p>Un shard \u00e9s una part d'un \u00edndex. Elasticsearch divideix els \u00edndexs en shards per a poder distribuir-los en els nodes del cluster. Aix\u00ed les dades se poden processar de manera distribu\u00efda i paral\u00b7lela, repartint la c\u00e0rrega de computaci\u00f3 entre diferents nodes. </p> <p></p> <p>D'entrada, els shards no tenen redund\u00e0ncia, per tant si en cau un perdem les dades. Aix\u00f2 ho solucionem amb les r\u00e8pliques.</p> <p>Una r\u00e8plica \u00e9s una c\u00f2pia d'un shard. Elasticsearch permet crear r\u00e8pliques dels shards per a garantir la disponibilitat de les dades i la toler\u00e0ncia a fallades. D'esta manera, els \u00edndexs estan formats pels shards primaris i les seues corresponents r\u00e8pliques. Per millorar la disponibilitat, Elasticsearch distribueix les r\u00e8pliques en diferents nodes del cluster on estan els shards primaris. </p> <p></p> <p>En la seg\u00fcent imatge, vegem que si cau un node el sistema pot funcionar amb les r\u00e8pliques que tenim en els altres nodes.</p> <p></p> <p>El hardware recomanat per montar cl\u00fasters d'Elasticsearch \u00e9s:</p> <ul> <li>CPU: 16-32 cores. Millor m\u00e9s nuclis que CPUs m\u00e9s r\u00e0pides, perqu\u00e8 en realitat Elasticsearch \u00e9s molt intensiu en operacions d'entrada/sortida i no tant en \u00fas de CPU.</li> <li>RAM: m\u00ednim 16 GB, encara que amb 8 GB tamb\u00e9 podria funcionar amb una c\u00e0rrega mitjana.</li> <li>Disc: recomanable SSDs amb una alta tasa d'IOPS (Operacions d'entrada i eixida per segon). </li> <li>Xarxa: 1 Gbps com a m\u00ednim. Recomanable 10 Gbps. No se recomana utilitzar NAS (Network Attached Storage) per a emmagatzemar les dades.</li> </ul> <p>Nosaltres, com hem fet fins ara, treballarem amb contenidors Docker, i per tant no necessitarem preocupar-nos per les caracter\u00edstiques del hardware. Per\u00f2 \u00e9s important con\u00e8ixer-les per a poder dimensionar correctament el nostre cluster d'Elasticsearch quan el despleguem en un entorn de producci\u00f3.</p> <p>M\u00e9s informaci\u00f3 sobre Elastic Stack en la seua web oficial.</p>"},{"location":"u07/elk_practic/","title":"STACK ELK PR\u00c0CTIC","text":"<p>Anem a preparar un entorn de treball per a poder practicar els components principals de Elastic. Treballarem amb Docker per a desplegar els components d'Elastic i Kibana. L'arxiu docker-compose.yml que utilitzarem el teniu en Aules. De totes formes ac\u00ed podeu veure els principals serveis:</p> <pre><code>services:\n</code></pre> <p>Node-RED</p> <pre><code>  node-redELK:\n    container_name: nodeRED_ELK\n    environment:\n      SERVER_NAME: localhost\n      ELASTICSEARCH_URL: http://elasticsearch:9200/\n    image: nodered/node-red:latest\n    user: \"1000:0\"\n    restart: unless-stopped\n    volumes:\n      - \"./node-red:/data\"\n    ports:\n      - \"1880:1880\"\n    networks:\n      - elk\n</code></pre> <p>Elastic Search</p> <pre><code>  elasticsearch:\n    restart: always\n    image: docker.elastic.co/elasticsearch/elasticsearch:8.19.11\n    container_name: elasticsearch\n    environment:\n      - cluster.name=iestavernes\n      - discovery.type=single-node\n      - xpack.security.enabled=true\n      - ELASTIC_PASSWORD=tavernes\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    healthcheck:\n      test: curl --cacert /usr/share/elasticsearch/config/certs/ca/ca.crt -s https://localhost:9200 &gt;/dev/null; if [[ $$? == 52 ]]; then echo 0; else echo 1; fi\n      interval: 30s\n      timeout: 10s\n      retries: 5 \n    ports:\n      - '9200:9200'\n    networks:\n      - elk\n    user: \"1000:0\"\n    logging:\n      driver: 'json-file'\n      options:\n        max-size: '100m'\n        max-file: '10'\n</code></pre> <p>Kibana</p> <pre><code>  kibana:\n    restart: always\n    image: docker.elastic.co/kibana/kibana:8.19.11\n    user: \"1000:0\"\n    container_name: kibana\n    depends_on:\n      - elasticsearch\n    environment:\n      - SERVER_NAME=kibana.localhost\n      - ELASTICSEARCH_URL=http://elasticsearch:9200\n      - ELASTICSEARCH_HOST=elasticsearch\n      - ELASTICSEARCH_PORT=9200\n      - xpack.security.enabled=true\n      - ELASTICSEARCH_USERNAME=kibana_system\n      - ELASTICSEARCH_PASSWORD=tavernes\n      - SERVER_HOST=0.0.0.0\n      - NODE_OPTIONS=\"--max-old-space-size=3096\"\n    healthcheck:\n      test: curl --cacert /usr/share/elasticsearch/config/certs/ca/ca.crt -s https://localhost:5601 &gt;/dev/null; if [[ $$? == 52 ]]; then echo 0; else echo 1; fi\n      interval: 30s\n      timeout: 10s\n      retries: 5\n    ports:\n      - \"5601:5601\"\n    networks:\n      - elk\n</code></pre> <p>Networks</p> <pre><code>networks:\n  elk:\n    driver: bridge\n</code></pre> <p>Fixeu-vos que l'usuari per accedir als serveis, quan ho demane, \u00e9s elastic i la contrasenya tavernes. En principi hauriem de treballar amb altres usuarios, perqu\u00e8 elastic \u00e9s superusuari, per\u00f2 per veure com va tot ens anir\u00e0 b\u00e9. </p> <p>A m\u00e9s, tenim un Node-RED per a poder treballar amb dades. Aneu en compte amb els ports i els noms dels serveis que ja teniu en marxa d'altres contenidors que hem creat en classe. Podeu canviar l'arxiu docker-compose si \u00e9s necessari. Tamb\u00e9 podeu parar o eliminar contenidors que ja no aneu a utilitzar.</p>"},{"location":"u07/elk_practic/#desplegar-el-stack-elk","title":"Desplegar el stack ELK","text":"<p>Baixeu l'arxiu docker-compose-elk.yml que teniu a Aules. El copieu a una carpeta espec\u00edfica per treballar amb elk. Canvieu-li el nom a docker-compose.yml per si no voleu posar el nom cada vegada que executeu les comandes de docker compose.</p> <p>Alcem els contenidors com sempre:</p> <pre><code>docker-compose up -d\n</code></pre> <p>Si teniu problemes amb els permisos, recordeu que podeu crear la carpeta del volum (node-red) manualment abans d'executar el <code>docker compose</code>.</p> <p>Comprovem amb <code>docker ps</code> que tots els serveis estan en marxa i en estat <code>healty</code>. Si no \u00e9s aix\u00ed, podeu veure els logs del servei que no funciona correctament amb <code>docker compose logs &lt;nom-del-contenidor&gt;</code>.</p> <p>Quan tots els contenidors estiguen en marxa: executem les seg\u00fcents instruccions des de la consola:</p> <pre><code>docker compose exec elasticsearch bin/elasticsearch-reset-password -u elastic -i\ndocker compose exec elasticsearch bin/elasticsearch-reset-password -u kibana_system -i\n</code></pre> <p>En els dos casos, quan vos demane el password poseu <code>tavernes</code>. Aix\u00ed ja tindreu el password de l'usuari elastic i de l'usuari kibana_system.</p> <p>Este pas no hauria de ser necessari, per\u00f2 sembla ser que ara s'ha de fer aix\u00ed la primera vegada. </p>"},{"location":"u07/elk_practic/#comprovar-que-funciona","title":"Comprovar que funciona","text":"<p>De moment les \u00faniques comprovacions que podem fer e\u015b intentar accedir a Elastic i a Kibana des del navegador i veure si s'obrin les p\u00e0gines.</p> <p>Posa en el navegador <code>http://localhost:9200</code> per a accedir a Elastic. Posa usuari <code>elastic</code> i contrasenya <code>tavernes</code>. T'hauria d'apar\u00e9ixer alguna cosa com:</p> <p></p> <p>Ara entra en <code>http://localhost:5601</code> per a accedir a Kibana. L'usuari i la contrasenya haurien de ser igual (elastic i tavernes). Comprova que entres a la p\u00e0gina principal de Kibana.</p> <p></p>"},{"location":"u07/elk_practic/#elastic-des-de-node-red","title":"Elastic des de Node-RED","text":"<p>En aules tamb\u00e9 teniu un arxiu JSON (<code>Node-RED Elasticsearch.json</code>) per a explicar com funciona Elastic i veure alguns exemples.</p>"},{"location":"u07/elk_practic/#elastic-des-de-kibana","title":"Elastic des de Kibana","text":"<p>Dins de Kibana treballarem amb el dev-tools, que est\u00e0 accessible des de la barra lateral esquerra amb una icona que t\u00e9 forma de clau anglesa. Aquesta eina ens permet fer consultes a Elastic i veure els resultats. La pantalla se veu aix\u00ed:</p> <p></p> <p>Des d'esta pantalla provarem les peticions que enviem a la base de dades d'Elastic. Teniu en aules un arxiu anomenat Queries_elasticsearch.txt amb algunes consultes que anem a provar. </p>"},{"location":"u07/elk_practic/#exemples-de-queries","title":"Exemples de queries","text":"<p>Estes queries que anem a veure se poden fer des de Kibana, escrivint-les tal qual al dev-tools, o des de Node-RED tal com teniu en l'exemple que heu importat. Tamb\u00e9 es poden fer alguns GETs directament des del navegador, i tamb\u00e9 podrieu utilitzar eines com Postman, curl o Hoopscotch per a fer proves.</p> <p>Anem a Kibana (localhost:5601), en el men\u00fa de l'esquerra aneu a Management i Dev-Tools, i proveu les seg\u00fcents operacions:</p> <p>Llistar els indexs que tenim en Elastic</p> <p>Des del dev-tools executem la seg\u00fcent comanda:</p> <pre><code>GET /_cat/indices\n</code></pre> <p>Veurem el resultat.</p> <p>Tamb\u00e9 obtenim el mateix resultat si executem la petici\u00f3 des de la url d'elastic: http://localhost:9200/_cat/indices</p> <p>Crear un \u00edndex nou</p> <pre><code>PUT /exam?pretty\n</code></pre> <p>Si ara torn\u00e0rem a executar la consulta <code>GET /_cat/indices</code> veur\u00edem que tenim un nou \u00edndex anomenat exam.</p> <p>Crear un \u00edndex amb certes caracter\u00edstiques</p> <p>En este cas anem a especificar quants shards i r\u00e8pliques volem que tinga el nou \u00edndex.</p> <pre><code>PUT /facebook?pretty\n{\n  \"settings\" : {\n    \"index\" : {\n      \"number_of_shards\" : 3,\n      \"number_of_replicas\" : 2 \n    }\n  }\n}\n</code></pre> <p>Si ara fem un <code>GET /facebook/_settings</code> veurem les caracter\u00edstiques de l'\u00edndex.</p> <p>Un altre \u00edndex</p> <pre><code>PUT instagram\n{\n  \"settings\" : {\n      \"number_of_shards\" : 3,\n      \"number_of_replicas\" : 2\n  }\n}\n</code></pre> <p>Eliminar un \u00edndex</p> <pre><code>DELETE /instagram\n</code></pre> <p>Si intentem eliminar un \u00edndex que no existeix, per exemple fent <code>DELETE /twitter</code>, ens donar\u00e0 un error.</p> <p>Crear un \u00edndex amb propietats</p> <p>A m\u00e9s de la propietat <code>settings</code> tamb\u00e9 podem afegir una propietat <code>mappings</code> per a definir els camps que tindr\u00e0 l'\u00edndex. No \u00e9s necessari, per\u00f2 si volem definir noms i tipus de dades dels camps ho farem de la seg\u00fcent forma:</p> <pre><code>PUT prueba\n{\n  \"settings\" : {\n      \"number_of_shards\" : 1\n  },\n  \"mappings\" : {\n    \"properties\" : {\n        \"age\" : { \"type\" : \"long\" },\n        \"name\": { \"type\": \"text\"}\n    }\n  }\n}\n</code></pre> <p>Si ara fem un <code>GET /prueba/_mapping</code> veurem les propietats de l'\u00edndex.</p> <p>Veure l'estat d'un \u00edndex</p> <pre><code>GET /prueba/_stats\n</code></pre> <p>Afegir un document a un \u00edndex</p> <pre><code>POST /facebook/_doc\n{\n  \"nick\": \"Hannon\",\n  \"email\": \"joselito@gmail.com\"\n}\n</code></pre> <p>Consultar els documents d'un \u00edndex</p> <pre><code>GET /facebook/_search\n</code></pre> <p>Per defecte nom\u00e9s se mostren 10 documents de l'index. A m\u00e9s no se sap si s\u00f3n els 10 primers o els 10 \u00faltims, ho fa en funci\u00f3 de l'indexaci\u00f3 interna (els 10 primers documents que recupere).</p> <p>Si volem veure una quantitat major ho farem de la seg\u00fcent forma:</p> <pre><code>GET /facebook/_search?size=1000\n</code></pre> <p>Recuperar l'\u00faltim document afegit</p> <p>Com que no sabem quan demanem una quantitat de documents quins ens va a mostrar, podem demanar per exemple els \u00faltims que hem afegit. Per aix\u00f2 farem servir un <code>timestamp</code> que no se crea autom\u00e0ticament, per tant l'haurem d'incloure quan afegim documents. Ja veurem com fer-ho. Demanem ordre descendent i nom\u00e9s un document.</p> <pre><code>GET /facebook/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"timestamp\": \"desc\"\n    }\n  ],\n  \"size\": 1\n}\n</code></pre> <p>Podem canviar la propietat \"size\" per demanar m\u00e9s documents.</p> <p>Consultar un document concret</p> <p>Haur\u00edem de saber l'id del document que volem consultar. Per exemple, si volem consultar el document amb id 1 de l'\u00edndex facebook:</p> <pre><code>GET /facebook/_doc/1\n</code></pre> <p>Teniu en compte que Elastic, com que no definim nosaltres l'id manualment, el crea autom\u00e0ticament i li assigna un valor alfanum\u00e8ric aleatori. Per tant, el document amb id 1 no existir\u00e0. Mireu quin id li ha assignat Elastic al document que hem afegit i torneu a provar la consulta amb l'id correcte.</p> <p>Consultar documents per condici\u00f3</p> <p>Tamb\u00e9 podem consultar els documents que compleixen una condici\u00f3:</p> <pre><code>GET /facebook/_search\n{\n  \"query\": {\n    \"match\": {\n      \"nick\": \"Hannon\"\n    }\n  }\n}\n</code></pre> <p>Amb versions anteriors d'Elastic se podia utilitzar les query string en la URL per fer consultes senzilles. </p> <pre><code>GET /facebook/_search?q=nick:Hannon\n</code></pre> <p>Ara b\u00e9, amb les \u00faltimes versions d'Elastic ha quedat obsolet l'\u00fas de les query string.</p> <p>Consultar els documents que tinguen un camp determinat (sense importar el valor)</p> <pre><code>GET /facebook/_search\n{\n  \"query\": {\n    \"exists\": {\n      \"field\": \"nick\"\n    }\n  }\n}\n</code></pre> <p>Quants documents t\u00e9 un \u00edndex</p> <pre><code>GET /exam/_count\n</code></pre> <p>Quants documents d'un \u00edndex compleixen una condici\u00f3</p> <pre><code>GET /facebook/_count\n{\n  \"query\": {\n    \"match\": {\n      \"nick\": \"Hannon\"\n    }\n  }\n}\n</code></pre> <p>M\u00e9s complex:</p> <pre><code>GET /exam/_count\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"match_phrase\": {\n            \"type\": \"WeatherObserved\"\n          }\n        },\n        {\n          \"range\":{\n            \"date\": {\n              \"gte\": \"01/01/2022 00:30:00\",\n              \"lte\": \"11/01/2022 21:00:00\"\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Tamb\u00e9 podem contar quants documents tenen una propietat determinada utilitzant <code>exists</code> com hem vist abans:</p> <pre><code>GET /facebook/_count\n{\n  \"query\": {\n    \"exists\": {\n      \"field\": \"nick\"\n    }\n  }\n}\n</code></pre> <p>Eliminar un document</p> <pre><code>DELETE /facebook/_doc/1\n</code></pre> <p>Eliminar tots els documents d'un \u00edndex</p> <pre><code>DELETE /facebook/_delete_by_query\n{\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n</code></pre> <p>Modificar un document d'un \u00edndex</p> <pre><code>POST /facebook/_update/1\n{\n  \"doc\": {\n    \"nick\": \"Hannon\",\n    \"email\": \"hannon@gmail.com\"\n  }\n}\n</code></pre> <p>Modificar un camp d'un document</p> <pre><code>POST /facebook/_update/1\n{\n  \"doc\": {\n    \"nick\": \"Hannon\"\n  }\n}\n</code></pre>"}]}