{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CE IA i Big Data Curs 25/26","text":""},{"location":"#big-data-aplicat","title":"Big Data Aplicat","text":"<ul> <li>0. Presentaci\u00f3</li> <li>1. Introducci\u00f3 a Big Data</li> <li>2. Elements i arquitectura Big Data</li> <li>3.1 Rep\u00e0s Docker</li> <li>3.2 Docker Compose</li> <li>4.1 Introducci\u00f3 a Node-RED</li> <li>4.2 Node-RED intermedi</li> </ul>"},{"location":"documents/","title":"Presentaci\u00f3 del m\u00f2dul Big Data Aplicat (BDA)","text":"Professor: Fidel Oltra Contacte: jf.oltralandete@edu.gva.es"},{"location":"documents/#descripcio-del-modul-bda","title":"Descripci\u00f3 del m\u00f2dul BDA","text":"<p>El m\u00f2dul de Big Data Aplicat (BDA) forma part del Curs d'Especialitzaci\u00f3 en IA i Big Data (IABD) i t\u00e9 una durada de 120 hores. El m\u00f2dul est\u00e0 dissenyat per proporcionar als estudiants els coneixements i habilitats necessaris per gestionar, processar i analitzar grans volums de dades utilitzant tecnologies i eines de Big Data.</p>"},{"location":"documents/#temporalitzacio","title":"Temporalitzaci\u00f3","text":"<p>4 hores a la setmana al llarg de 30 setmanes.</p> <p>Dilluns: 16:25 - 18:15  Dimecres: 16:25 - 18:15</p>"},{"location":"documents/#objectius","title":"Objectius","text":"<p>Els objectius generals del Curs d'Especialitzaci\u00f3 en IA i Big Data se concreten, en cada m\u00f2dul, en els seus Resultats d'Aprenentatge (RA) i Criteris d'Avaluaci\u00f3 (CA) que se detallen en la programaci\u00f3 del m\u00f2dul.</p> <p>Els Resultats d'Aprenentatge (RA) espec\u00edfics del m\u00f2dul BDA s\u00f3n:</p> <ul> <li> <p>RA1: Gestiona solucions a problemes proposats, utilitzant sistemes d\u2019emmagatzematge i eines associades al centre de dades.</p> </li> <li> <p>RA2: Gestiona sistemes d\u2019emmagatzematge i l\u2019ampli ecosistema al voltant facilitant el processament de grans quantitats de dades sense errors i de forma r\u00e0pida.</p> </li> <li> <p>RA3: Genera mecanismes d\u2019integritat de les dades, comprovant\u2010ne el manteniment en els sistemes de fitxers distribu\u00efts i valorant la sobrec\u00e0rrega que comporta en el tractament de les dades.</p> </li> <li> <p>RA4: Realitza el seguiment de la monitoritzaci\u00f3 d\u2019un sistema, assegurant la fiabilitat i l\u2019estabilitat dels serveis que es proveeixen.</p> </li> <li> <p>RA5: Valida les t\u00e8cniques de Big Data per transformar una gran quantitat de dades en informaci\u00f3 significativa, facilitant la presa de decisions de negocis.</p> </li> </ul>"},{"location":"documents/#competencies-professionals","title":"Compet\u00e8ncies professionals","text":"<ul> <li> <p>b) Desenvolupar i implementar sistemes d\u2019intel\u00b7lig\u00e8ncia artificial que faciliten la presa de decisions \u00e0gils dins d\u2019un negoci gestionant i explotant dades massives.</p> </li> <li> <p>c) Gestionar la transformaci\u00f3 digital necess\u00e0ria a les organitzacions per a la consecuci\u00f3 de l\u2019efici\u00e8ncia empresarial mitjan\u00e7ant el tractament de dades.</p> </li> <li> <p>h) Integrar sistemes d\u2019explotaci\u00f3 de grans volums de dades aplicant solucions de Big Data.</p> </li> <li> <p>i) Implantar les funcionalitats, processos i sistemes de decisions empresarials aplicant\u2010hi t\u00e8cniques de Big Data.</p> </li> <li> <p>j) Executar el sistema d\u2019explotaci\u00f3 de dades segons les necessitats d\u2019\u00fas i les condicions de seguretat establertes assegurant el compliment dels principis legals i \u00e8tics.</p> </li> <li> <p>k) Configurar les eines que es fan servir per construir solucions Big Data i d\u2019Intel\u00b7lig\u00e8ncia Artificial.</p> </li> <li> <p>l) Gestionar de manera eficient les dades, la informaci\u00f3 i la seua representaci\u00f3 per transformar\u2010les en coneixement.</p> </li> </ul>"},{"location":"documents/#continguts","title":"Continguts","text":"<p>Els continguts d\u2019aquest m\u00f2dul professional, segons estableix el curr\u00edculum vigent, s\u00f3n els seg\u00fcents:</p> <ul> <li> <p>C1. Gesti\u00f3 de solucions amb sistemes d\u2019emmagatzematge i eines del centre de dades per resoldre problemes.</p> </li> <li> <p>C2. Gesti\u00f3 de sistemes d\u2019emmagatzematge i ecosistemes Big Data.</p> </li> <li> <p>C3. Generaci\u00f3 de mecanismes d\u2019integritat de les dades. Comprovaci\u00f3 de manteniment de sistemes de fitxers.</p> </li> <li> <p>C4. Monitoritzaci\u00f3, optimitzaci\u00f3 i soluci\u00f3 de problemes.</p> </li> <li> <p>C5. Validaci\u00f3 de t\u00e8cniques Big Data en la presa de decisions a intel\u00b7lig\u00e8ncia de negocis BI.</p> </li> </ul>"},{"location":"documents/#unitats-de-programacio","title":"Unitats de programaci\u00f3","text":"<p>UP01: Introducci\u00f3 a Big Data. Arquitectura. Entorn de treball. UP02: Node-RED UP03: Fiware. Topologia de les dades. Br\u00f3kers. UP04: MQTT. UP05: Stack ELK. UP06: Altres bases de dades NoSQL. UP07: Desenvolupament. Visualitzaci\u00f3.</p>"},{"location":"documents/#metodologia","title":"Metodologia","text":"<ul> <li> <p>Apunts, exemples, pr\u00e0ctiques i documentaci\u00f3 en la plataforma Aules.</p> </li> <li> <p>Aprenentatge basat en Reptes (ABR) i Projectes (ABP), mitjan\u00e7ant el desenvolupament primer de reptes m\u00e9s concrets i, m\u00e9s endavant, de projectes intermodulars reals complets, proposats, sempre que siga possible, en col\u00b7laboraci\u00f3 amb empreses i organitzacions.</p> </li> <li> <p>Aprenentatge col\u00b7laboratiu, en els propis projectes i reptes, que s'abordaran mitjan\u00e7ant el treball en equip i amb eines de gesti\u00f3 de projectes.</p> </li> <li> <p>Classe invertida (Flipped Classroom), on l'alumnat treballa els continguts pel seu compte, i aprofita els problemes que va trobant al llarg del desenvolupament dels projectes i reptes, o en la resoluci\u00f3 d'exercicis, per preguntar a l'aula els seus dubtes. La classe per tant esdev\u00e9 un espai de resoluci\u00f3 de dubtes i d'aplicaci\u00f3 pr\u00e0ctica dels continguts.</p> </li> </ul>"},{"location":"u01/","title":"Introducci\u00f3 a Big Data","text":""},{"location":"u01/#que-es-big-data","title":"Qu\u00e8 \u00e9s Big Data?","text":"<p>Big Data \u00e9s un terme que fa refer\u00e8ncia a la gesti\u00f3 i an\u00e0lisi de volums de dades que, pel seu tamany, complexitat o velocitat d'entrada, no poden ser tractats de manera convencional amb eines tradicionals. Aquestes dades poden ser de diferents tipus, com ara text, imatges, \u00e0udio, v\u00eddeo, etc. </p> <p>El terme Big Data s'associa normalment a les anomenades \"tres V\" (que de vegades s\u00f3n 4):</p> <ul> <li> <p>Volum: Fa refer\u00e8ncia a la quantitat de dades que es generen i emmagatzemen. A m\u00e9s quantitat, m\u00e9s necessitem de sistemes diferents als tradicionals.</p> </li> <li> <p>Velocitat: Fa refer\u00e8ncia a la rapidesa amb qu\u00e8 es generen i es processen les dades. Amb el creixement de l'anomenat IOT (Internet de les Coses) les dades arriben quasi de manera instant\u00e0nia i s'han de llegir i tractar de manera igualment r\u00e0pida.</p> </li> <li> <p>Varietat: Fa refer\u00e8ncia a la diversitat de formats en qu\u00e8 es poden presentar les dades. La informaci\u00f3 pot arribar des de fonts molt diferents i amb formats diversos: text no estructurat, imatges, \u00e0udio, correus electr\u00f2nics, etc.</p> </li> <li> <p>Veracitat: Fa refer\u00e8ncia a la qualitat de les dades. Les dades poden ser incorrectes, incompletes o no actualitzades. Aix\u00f2 pot ser un problema a l'hora de prendre decisions basades en aquestes dades.</p> </li> </ul> <p></p>"},{"location":"u01/#per-que-es-important-el-big-data","title":"Per qu\u00e8 \u00e9s important el Big Data?","text":"<p>El Big Data \u00e9s important perqu\u00e8 permet a les empreses i organitzacions millorar la seva presa de decisions, ja que permet analitzar grans quantitats de dades i extreure'n coneixement. Aix\u00f2 pot ser \u00fatil per a moltes coses, com ara:</p> <ul> <li>Millorar la presa de decisions: Les empreses poden utilitzar les dades per prendre decisions m\u00e9s informades i basades en evid\u00e8ncies.</li> <li>Millorar la relaci\u00f3 amb els clients: Les empreses poden utilitzar les dades per entendre millor les necessitats dels clients i oferir-los productes i serveis m\u00e9s personalitzats.</li> <li>Millorar l'efici\u00e8ncia operativa: Les empreses poden utilitzar les dades per identificar \u00e0rees on poden millorar l'efici\u00e8ncia i reduir els costos.</li> <li>Identificar oportunitats de negoci: Les empreses poden utilitzar les dades per identificar noves oportunitats de negoci i millorar la seva competitivitat.</li> </ul>"},{"location":"u01/#exemples-de-sectors-o-situacions-on-es-aconsellable-utilitzar-big-data","title":"Exemples de sectors o situacions on \u00e9s aconsellable utilitzar Big Data","text":"<p>El Big Data \u00e9s \u00fatil en molts sectors i situacions diferents. Algunes de les \u00e0rees on el Big Data pot ser especialment \u00fatil s\u00f3n:</p> <ul> <li>Salut: El Big Data pot ser utilitzat per millorar el diagn\u00f2stic i el tractament de malalties, aix\u00ed com per predir epid\u00e8mies i identificar tend\u00e8ncies de salut.</li> <li>Finances: El Big Data pot ser utilitzat per predir tend\u00e8ncies del mercat, identificar oportunitats d'inversi\u00f3 i detectar frau.</li> <li>Xarxes socials: El Big Data pot ser utilitzat per analitzar el comportament dels usuaris en les xarxes socials i millorar la segmentaci\u00f3 dels clients, identificar oportunitats de negoci, millorar la relaci\u00f3 amb els clients o possibles clients, etc.</li> <li>Transport: El Big Data pot ser utilitzat per millorar la planificaci\u00f3 del transport, predir la congesti\u00f3 del tr\u00e0nsit, optimitzar les rutes de transport, etc.</li> <li>IoT: El Big Data pot ser utilitzat per analitzar les dades generades per dispositius connectats a Internet i millorar la seva efici\u00e8ncia i seguretat, aprofitant al m\u00e0xim la informaci\u00f3 rebuda.</li> </ul> <p>Aix\u00f2 s\u00f3n nom\u00e9s alguns exemples, per\u00f2 el Big Data pot ser \u00fatil en molts altres sectors i situacions.</p>"},{"location":"u01/#conceptes-relacionats-amb-big-data","title":"Conceptes relacionats amb Big Data","text":"<p>Alguns conceptes relacionats amb els sistemes de Big Data s\u00f3n:</p> <ul> <li>Escalabilitat (horitzontal vs vertical)</li> <li>Divideix i vencer\u00e0s (MapReduce)</li> <li>SQL vs NoSQL</li> <li>Cloud Computing (on premise)</li> </ul>"},{"location":"u01/#escalabilitat-horitzontal-vs-vertical","title":"Escalabilitat horitzontal vs vertical","text":"<ul> <li> <p>Escalabilitat vertical: Consisteix en augmentar la capacitat d'un sistema afegint m\u00e9s recursos a un \u00fanic node. Aix\u00f2 pot ser \u00fatil per a sistemes que no poden ser dividits en parts m\u00e9s petites, per\u00f2 t\u00e9 un l\u00edmit en la quantitat de recursos que es poden afegir a un \u00fanic node. </p> </li> <li> <p>Escalabilitat horitzontal: Consisteix en augmentar la capacitat d'un sistema afegint m\u00e9s nodes al sistema. Aix\u00f2 permet augmentar la capacitat del sistema de manera m\u00e9s flexible i escalable, ja que es poden afegir m\u00e9s nodes a mesura que es necessiti.</p> </li> </ul> <p>En un sistema que escala verticalment, s'han d'ampliar els components del sistema (CPU, mem\u00f2ria, disc dur, etc.) per augmentar la capacitat del sistema. Esta soluci\u00f3 \u00e9s cara i t\u00e9 l\u00edmits. En canvi, en un sistema que escala horitzontalment, podem simplement afegir o treure nodes al sistema per augmentar o disminuir la seua capacitat. L'escalabilitat vertical \u00e9s m\u00e9s econ\u00f2mica i no t\u00e9 l\u00edmits mentre puguem continuar afegint nodes. </p> <p></p> <p>En general, els sistemes de Big Data utilitzen l'escalabilitat horitzontal per aconseguir la capacitat necess\u00e0ria per processar grans quantitats de dades.</p>"},{"location":"u01/#divideix-i-venceras-mapreduce","title":"Divideix i vencer\u00e1s (MapReduce)","text":"<p>MapReduce \u00e9s un model de programaci\u00f3 i un sistema de processament distribu\u00eft dissenyat per processar grans quantitats de dades de manera eficient. El model de programaci\u00f3 MapReduce consisteix en dues fases:</p> <ul> <li>Map: En aquesta fase, les dades s\u00f3n dividides en parts m\u00e9s petites i processades de manera paral\u00b7lela i distribu\u00efda en diferents nodes del sistema.</li> <li>Reduce: En aquesta fase, els resultats de la fase Map s\u00f3n combinats i processats per obtenir el resultat final.</li> </ul> <p>El model de programaci\u00f3 MapReduce \u00e9s molt eficient per processar grans quantitats de dades de manera distribu\u00efda i escalable. Aquest model \u00e9s utilitzat en molts sistemes de Big Data, com ara Hadoop i Spark. A m\u00e9s permet redistribuir les dades entre les unitats de treball en cas de fallada d'un node.</p> <p></p>"},{"location":"u01/#sql-vs-nosql","title":"SQL vs NoSQL","text":"<ul> <li>SQL: SQL (Structured Query Language) \u00e9s un llenguatge de programaci\u00f3 utilitzat per gestionar bases de dades relacionals. SQL \u00e9s un llenguatge molt potent i flexible que permet realitzar consultes complexes i eficients sobre les dades. En general s'utilitza la categoria \"bases de dades SQL\" per fer refer\u00e8ncia a les bases de dades relacionals.</li> </ul> <p>Exemples de bases de dades SQL: </p> <pre><code>- MySQL / MariaDB\n- PostgreSQL\n- Oracle\n- SQL Server\n</code></pre> <p>Avantatges de les bases de dades SQL:</p> <pre><code>- Estructura de dades clara i definida\n- Permeten relacions entre les dades\n- Suport per a transaccions ACID (Atomicitat, Consist\u00e8ncia, A\u00efllament, Durabilitat)\n- Suport per a consultes SQL\n- Asseguren la integritat i consist\u00e8ncia de les dades\n</code></pre> <ul> <li>NoSQL: NoSQL \u00e9s un terme gen\u00e8ric que fa refer\u00e8ncia a bases de dades no relacionals. Les bases de dades NoSQL s\u00f3n dissenyades per gestionar grans quantitats de dades de manera eficient i escalable. S'utilitzen sovint en sistemes de Big Data per emmagatzemar i processar grans quantitats de dades. A difer\u00e8ncia de les bases de dades SQL o relacionals, en les bases de dades NoSQL s'ofereixen diferents models de dades i no cal un esquema predefinit per establir com s'estructuran i relaciona la informaci\u00f3.</li> </ul> <p>Exemples de bases de dades NoSQL:</p> <pre><code>- MongoDB\n- Cassandra\n- HBase\n- Redis\n- Elasticsearch\n- CouchDB\n- Neo4j\n</code></pre> <p>Avantatges de les bases de dades NoSQL:</p> <pre><code>- Escalabilitat horitzontal\n- Flexibilitat en l'emmagatzematge de dades\n- Rendiment i velocitat\n- Suport per a dades no estructurades\n- Suport per a sistemes distribu\u00efts\n</code></pre> <p>Hem de tenir en compte que en les bases de dades NoSQL les dades no tenen una estructura fixa i definida, i \u00e9s m\u00e9s complicat establir relacions entre les dades. Aix\u00f2 pot ser un avantatge o un inconvenient segons les necessitats del projecte.</p> <p>Teorema CAP </p> <p>El teorema CAP \u00e9s un principi fonamental en el disseny de sistemes distribu\u00efts que estableix que \u00e9s impossible garantir simult\u00e0niament Consist\u00e8ncia, Disponibilitat i Toler\u00e0ncia a particions en un sistema distribu\u00eft. Aix\u00f2 significa que en un sistema distribu\u00eft nom\u00e9s es poden garantir dos dels tres aspectes abans esmentats.</p> <p>https://www.ibm.com/es-es/topics/cap-theorem</p> <p></p> <p>BBDD CP (Consistency and Partition Tolerance)</p> <p>Ofereixen consist\u00e8ncia i toler\u00e0ncia a la partici\u00f3 sacrificant la disponibilitat. Aix\u00f2 significa que en cas de partici\u00f3 de la xarxa, el sistema es mant\u00e9 consistent, per\u00f2 pot ser que no estiga disponible per a totes les peticions perqu\u00e8 els nodes no consistents no estaran disponibles fins que se solucione el problema. Un exemple seria MongoDB.</p> <p>BBDD AP (Availability and Partition Tolerance)</p> <p>Ofereixen disponibilitat i toler\u00e0ncia a la partici\u00f3 sacrificant la consist\u00e8ncia. Aix\u00f2 significa que en cas de partici\u00f3 de la xarxa, el sistema es mant\u00e9 disponible per a totes les peticions, per\u00f2 pot ser que no estiga consistent fins que se solucione el problema perqu\u00e8 uns nodes poden tornar versions m\u00e9s antigues de les dades. Un exemple seria Cassandra.</p> <p>BBDD CA (Consistency and Availability)</p> <p>Ofereixen consist\u00e8ncia i disponibilitat en tots els nodes. Ara b\u00e9, no funcionar\u00e0 b\u00e9 si hi ha una partici\u00f3 entre 2 o m\u00e9s nodes del sistema, de manera que la toler\u00e0ncia a la partici\u00f3 no est\u00e0 garantida. Un exemple seria una base de dades relacional.</p> <p>https://www.genbeta.com/desarrollo/nosql-clasificacion-de-las-bases-de-datos-segun-el-teorema-cap</p>"},{"location":"u01/#models-nosql","title":"Models NoSQL","text":"<p>Dins de les tecnologies NoSQL hi ha diferents tipus de models:</p> <ul> <li>Document: Aquest model emmagatzema les dades en documents en un format similar a un JSON o XML. Cada document pot tenir diferents camps i valors, i no cal un esquema predefinit per definir com s'estructuren les dades. Exemples: MongoDB, CouchDB.</li> <li>Clau-valor: Aquest model emmagatzema les dades en parelles clau-valor, on cada clau est\u00e0 associada a un valor. Aquest model \u00e9s molt eficient per recuperar dades per clau. Exemples: Redis, DynamoDB.</li> <li>Columnar: Aquest model emmagatzema les dades en columnes en lloc de files, el que permet recuperar dades de manera eficient. Aquest model \u00e9s \u00fatil per a bases de dades anal\u00edtiques. Exemples: Cassandra, HBase.</li> <li>Graf: Aquest model emmagatzema les dades com a nodes i relacions entre els nodes. Aquest model \u00e9s \u00fatil per a bases de dades que necessiten representar relacions complexes entre les dades. Exemples: Neo4j, ArangoDB.</li> </ul> <p>Els tres darrers models que hem enumerat, el Clau-valor, el Columnar i el Graf, s\u00f3n models d'agregaci\u00f3.</p> <p>Models d'agregaci\u00f3</p> <p>Els models d'agregaci\u00f3 se basen en la noci\u00f3 d'agregaci\u00f3: una col\u00b7lecci\u00f3 d'objectes/entitats relacionats que volem tractar com una \u00fanica entitat a efectes de acc\u00e9s, manipulaci\u00f3, control de la consist\u00e8ncia i concurr\u00e8ncia, i distribuci\u00f3 de les dades. En les bases de dades relacionals podem fer JOIN per recuperar informaci\u00f3 de les diferents taules on est\u00e0 la informaci\u00f3 que hem repartit entre elles. En les bases de dades NoSQL, com no tenim relacions, hem de fer servir models d'agregaci\u00f3 per aconseguir el mateix efecte. </p> <p>T\u00e8cniques d'agregaci\u00f3 m\u00e9s comuns</p> <ul> <li>Embedding: En aquest model, les dades relacionades s'emmagatzemen juntes en un \u00fanic document. Aix\u00f2 permet recuperar les dades relacionades amb una sola consulta. Aquest model \u00e9s \u00fatil per dades que es consulten juntes amb freq\u00fc\u00e8ncia.</li> <li>Referencing: En aquest model, les dades relacionades s'emmagatzemen en documents separats i s'estableixen relacions entre els documents mitjan\u00e7ant refer\u00e8ncies. Aix\u00f2 permet gestionar les dades relacionades de manera independent i mantenir la consist\u00e8ncia de les dades. Aquest model \u00e9s \u00fatil per dades que es consulten de manera independent.</li> </ul> <p>El model Clau-valor tamb\u00e9 se considera un model d'agregaci\u00f3. La clau s'extreu del domini de l'aplicaci\u00f3 (un nom d'usuari, una adre\u00e7a de correu electr\u00f2nic, un NIF...), mentre que el valor associat en general pot agafar qualsevol format (pot ser un bloc de dades, una col\u00b7lecci\u00f3, un objecte...) i la seua interpretaci\u00f3 ser\u00e0 responsabilitat de l'aplicaci\u00f3.</p> <p></p> <p>Model d'agregaci\u00f3 documental </p> <p>\u00c9s com una extensi\u00f3 del model Clau-valor. Els documents tenen una estructura interna (document) que en general estar\u00e0 formada per combinacions d'estructures Clau-valor. Una estructura aix\u00ed facilita l'acc\u00e9s a les dades des de les aplicacions, per\u00f2 \u00e9s menys flexible que el model Clau-valor pur ja que les dades estan m\u00e9s estructurades. A m\u00e9s, les consultes s\u00f3n m\u00e9s complexes.</p> <p>Exemples d'este model s\u00f3n CouchDB o Elastic.</p> <p>Veiem per exemple un carro de la compra utilitzant un model documental:</p> <p></p> <p>Model d'agregaci\u00f3 per columnes</p> <p>Apareix agafant com a precursor el model BigTable de Google. El model t\u00e9 forma de matriu, per\u00f2 no a l'estil d'una base de dades relacional. Ac\u00ed les files s\u00f3n agregacions de dades accessibles mitjan\u00e7ant una clau, i les columnes representen atributs de l'agregaci\u00f3 en format tripleta nom-valor-timestamp. D'alguna manera \u00e9s com girar 90 graus a l'esquerra un model documental. </p> <p></p> <p>\u00c9s un model eficient en sistemes distribu\u00efts, ja que permet distribuir les dades per columnes i no per files. Aix\u00f2 permet escalar les dades de manera independent i distribu\u00efda. Un exemple d'este model \u00e9s Cassandra.</p> <p>Avantatges dels models d'agregaci\u00f3</p> <ul> <li>Efici\u00e8ncia: Permeten recuperar les dades relacionades amb una sola consulta, el que millora el rendiment de l'aplicaci\u00f3.</li> <li>Escalabilitat: Permeten escalar les dades relacionades de manera independent i distribu\u00efda.</li> </ul> <p>Problema dels models d'agregaci\u00f3</p> <p>El principal problema \u00e9s que poden haver objectes repartits entre diferents agregats. Hem de prendre mesures per garantir la consist\u00e8ncia de les dades en aquests casos.</p>"},{"location":"u01/#cloud-computing-on-premise","title":"Cloud Computing (on premise)","text":"<p>El Cloud Computing \u00e9s un model de distribuci\u00f3 de recursos inform\u00e0tics que permet l'acc\u00e9s a serveis i recursos a trav\u00e9s d'Internet. Aquest model ofereix una gran flexibilitat i escalabilitat, ja que els recursos es poden ajustar segons les necessitats de l'usuari.</p> <p>En el context del Big Data, el Cloud Computing juga un paper important. Les empreses i organitzacions que treballen amb grans volums de dades poden utilitzar el Cloud Computing per emmagatzemar, processar i analitzar aquestes dades de manera eficient i escalable. En el cas de Cloud de tercers, el prove\u00efdor de serveis Cloud es fa c\u00e0rrec de la infraestructura i els recursos necessaris per processar les dades, la qual cosa permet a les empreses centrar-se en l'an\u00e0lisi de les dades i la presa de decisions. El cost inicial no \u00e9s molt alt i l'obsolesc\u00e8ncia i la escalabilitat s\u00f3n responsabilitat del prove\u00efdor.</p> <p>El Cloud Computing utilitza normalment un n\u00favol de tercers. Tot i aix\u00f2, una opci\u00f3 popular en el Cloud Computing \u00e9s el model \"on premise\". Aquest model permet a les empreses tenir els seus propis servidors f\u00edsics i infraestructura de Cloud Computing dins de les seves pr\u00f2pies instal\u00b7lacions. Aix\u00f2 ofereix un major control i seguretat sobre les dades, ja que no es dep\u00e8n de tercers per gestionar-les. L'escalabilitat pot ser vertical (afegir m\u00e9s recursos a un \u00fanic node) o tamb\u00e9 horitzontal (comprar m\u00e9s servidors). El cost inicial \u00e9s m\u00e9s alt que en el model de n\u00favol p\u00fablic, encara que a llarg termini pot ser m\u00e9s econ\u00f2mic en certs casos perqu\u00e8 no se paga per \u00fas una vegada feta la inversi\u00f3 inicial.</p> <p>Utilitzar el Cloud Computing \"on premise\" en el context del Big Data permet a les empreses tenir un acc\u00e9s r\u00e0pid i eficient a les seves dades, aix\u00ed com una gran capacitat de processament i emmagatzematge. A m\u00e9s, aquest model permet una millor integraci\u00f3 amb altres sistemes i aplicacions empresarials. El model ofereix flexibilitat, escalabilitat i control sobre les dades.</p>"},{"location":"u01/#tipus-de-dades","title":"Tipus de dades","text":"<p>Quan treballem amb tecnologies Big Data podem fer \u00fas de dades que arriben des de diferents fonts i en diferents formats. En general, podem classificar les dades d'entrada en dues categories principals: estructurades, semiestructurades i no estructurades.</p>"},{"location":"u01/#dades-estructurades","title":"Dades estructurades","text":"<p>Les dades estructurades s\u00f3n dades de les quals coneixem el format. No necess\u00e0riament han de ser bases de dades relacionals, podem ser no relacionals amb un format definit i fixe, fulls de c\u00e0lcul, documents XML o JSON, etc.</p>"},{"location":"u01/#dades-semiestructurades","title":"Dades semiestructurades","text":"<p>Les dades semiestructurades s\u00f3n dades que tenen certa estructura i format, per\u00f2 eixe format pot variar d'un element a un altre. Un exemple d'aquest tipus de dades s\u00f3n els documents XML o JSON, on cada element pot tenir diferents camps i valors.</p>"},{"location":"u01/#dades-no-estructurades","title":"Dades no estructurades","text":"<p>Les dades no estructurades s\u00f3n dades de les quals no coneixem el format. Poden ser imatges, \u00e0udio, v\u00eddeo, text sense format fixe, etc.</p>"},{"location":"u01/#utilitzacio-de-les-dades","title":"Utilitzaci\u00f3 de les dades","text":""},{"location":"u01/#hipotesis-de-causalitat","title":"Hip\u00f2tesis de causalitat","text":"<p>Les hip\u00f2tesis de causalitat s\u00f3n afirmacions que estableixen una relaci\u00f3 de causa-efecte entre dos o m\u00e9s variables. Aquestes hip\u00f2tesis s\u00f3n importants per entendre com les dades estan relacionades i com podem utilitzar-les per prendre decisions.</p> <p>Les hip\u00f2tesis de causalitat s'utilitzen en estad\u00edstica. Se validen o se rebutjen en funci\u00f3 de les an\u00e0lisis fetes a diferents mostres de dades, i dels resultats que s'hagen obt\u00e9s.</p> <p>Un exemple: </p>"},{"location":"u01/#analisi-predictiu","title":"An\u00e0lisi predictiu","text":"<p>L'an\u00e0lisi predictiu \u00e9s una t\u00e8cnica que utilitza dades hist\u00f2riques per predir resultats futurs. Aquesta t\u00e8cnica s'utilitza en molts \u00e0mbits, com ara el m\u00e0rqueting, la salut, les finances, etc. L'an\u00e0lisi predictiu es basa en algoritmes d'aprenentatge autom\u00e0tic i intel\u00b7lig\u00e8ncia artificial per predir resultats futurs a partir de dades hist\u00f2riques.</p> <p>En Intel\u00b7lig\u00e8ncia Artificial en general no se formulen hip\u00f2tesis, sino que se busquen correlacions, tend\u00e8ncies o patrons. </p>"},{"location":"u01/#analisi-descriptiu","title":"An\u00e0lisi descriptiu","text":"<p>L'an\u00e0lisi descriptiu \u00e9s una t\u00e8cnica que utilitza dades per descriure i resumir les caracter\u00edstiques d'una poblaci\u00f3 o mostra. Aquesta t\u00e8cnica s'utilitza per entendre millor les dades i identificar tend\u00e8ncies, patrons i relacions entre les dades.</p>"},{"location":"u01/#tipus-de-processament","title":"Tipus de processament","text":"<p>Per processar les dades tenim dos formes principals de fer-ho: batch processing i stream processing.</p>"},{"location":"u01/#batch-processing","title":"Batch processing","text":"<p>El batch processing \u00e9s un m\u00e8tode de processament en qu\u00e8 les dades s\u00f3n processades en blocs o lots. Aquest m\u00e8tode \u00e9s \u00fatil per processar grans quantitats de dades de manera eficient i escalable. Els processos de batch processing s\u00f3n normalment planificats i executats en intervals regulars, com ara cada dia o cada setmana, en forma de tasques programades.</p> <p>Algunes caracter\u00edstiques principals del batch processing:</p> <ul> <li>No requereix interacci\u00f3 amb els usuaris</li> <li>\u00c9s ideal per a tasques repetitives i previsibles</li> <li>\u00c9s \u00fatil per processar grans quantitats de dades</li> <li>Pot ser m\u00e9s eficient que el processament en temps real per a tasques que no requereixen una resposta immediata</li> <li>S'executa regularment (cada x temps, una vegada al dia, etc.)</li> </ul> <p>Un exemple de batch processing podria ser l'enviament de correus electr\u00f2nics autom\u00e0tics a tots els clients que han realitzat una compra en una botiga en l\u00ednia cada dia a les 12:00, una felicitaci\u00f3 d'aniversari a tots els clients que compleixen anys cada dia a les 9:00, etc.</p>"},{"location":"u01/#stream-processing","title":"Stream processing","text":"<p>El stream processing \u00e9s un m\u00e8tode de processament en qu\u00e8 les dades s\u00f3n processades a mesura que arriben. Aquest m\u00e8tode \u00e9s \u00fatil per processar dades en temps real i respondre r\u00e0pidament a canvis en les dades. Els processos de stream processing s\u00f3n normalment continuats i en temps real, i poden ser utilitzats per a tasques com ara la detecci\u00f3 d'anomalies, la monitoritzaci\u00f3 de sistemes, la generaci\u00f3 de recomanacions, etc.</p> <p>Caracter\u00edstiques principals:</p> <ul> <li>Les dades s\u00f3n processades a mesura que arriben</li> <li>Les dades s'estan processant continuament</li> <li>\u00c9s \u00fatil per a tasques que requereixen una resposta immediata</li> </ul> <p>Un exemple de stream processing podria ser la detecci\u00f3 d'anomalies en temps real en un sistema de control de tr\u00e0nsit, la generaci\u00f3 de recomanacions en temps real en una botiga en l\u00ednia, la recepci\u00f3 i an\u00e0lisi d'informaci\u00f3 que arriba via MQTT, etc.</p> <p>MQTT \u00e9s un protocol de missatgeria que s'utilitza per a la comunicaci\u00f3 entre dispositius IoT. Aquest protocol permet enviar i rebre missatges en temps real i \u00e9s molt eficient per a la comunicaci\u00f3 entre dispositius connectats a Internet. M\u00e9s informaci\u00f3 a https://mqtt.org/.</p>"},{"location":"u02/","title":"Elements i arquitectura d'una plataforma Big Data","text":""},{"location":"u02/#plataformes-big-data","title":"Plataformes Big Data","text":"<p>Una Plataforma Big Data \u00e9s un sistema capa\u00e7 de gestionar i processar grans volums de dades. Algunes caracter\u00edstiques importants (encara que no imprescindibles) d'una plataforma Big Data s\u00f3n:</p> <ul> <li>Computaci\u00f3 en temps real</li> <li>Escalabilitat (Cloud Computing, processament distribu\u00eft)</li> <li>Utilitzaci\u00f3 de solucions de Intel\u00b7lig\u00e8ncia Artificial per fer simulacions i predicci\u00f3 de resultats</li> <li>Suport de m\u00faltiples fonts i tipus de dades (estructurades, semiestructurades i no estructurades)</li> <li>En general, basada en tecnologies de codi obert i en certs est\u00e0ndards</li> </ul> <p>Hadoop est\u00e0 considerada com la primera plataforma Big Data generalista. Va ser creada per Yahoo! i est\u00e0 basada en el paper de Google sobre el sistema de fitxers distribu\u00eft GFS i el sistema de processament de dades MapReduce.</p> <p>M\u00e9s informaci\u00f3 sobre Hadoop</p>"},{"location":"u02/#arquitectura-big-data","title":"Arquitectura Big Data","text":"<p>Un model informacional tradicional en una organitzaci\u00f3 es basa en una arquitectura de quatre capes:</p> <ul> <li>Sistemes operacionals: una p\u00e0gina web, un ERP, un CRM, etc. Qualsevol font de dades de l'organitzaci\u00f3.</li> <li>ETL: proc\u00e9s d'extracci\u00f3, transformaci\u00f3, neteja i c\u00e0rrega de dades.</li> <li>Sistemes informacionals: datawarehouses, datamarts, etc. Bases de dades en general.</li> <li>Eines d'an\u00e0lisi i visualitzaci\u00f3: eines de BI, dashboards, informes, etc.</li> </ul> <p>Les arquitectures Big Data venen a solucionar alguns dels problemes dels sistemes tradicionals, com ara:</p> <ul> <li>La dificultat per a gestionar grans volums de dades.</li> <li>La dificultat per a gestionar dades no estructurades.</li> <li>La dificultat per a gestionar dades en temps real.</li> <li>La dificultat per a integrar dades de m\u00faltiples fonts.</li> </ul> <p>Una arquitectura Big Data, com veurem a continuaci\u00f3, est\u00e0 formada per diferents capes que permeten gestionar i processar grans volums de dades. El concepte de Data Warehouse evoluciona cap al concepte de Data Lake, on es poden emmagatzemar dades en el seu format original (estiguen estructurades o no), sense necessitat de transformar-les pr\u00e8viament. Aix\u00f2 permet una major flexibilitat i agilitat en el processament de les dades. El processament o la transformaci\u00f3 de les dades se pot fer en el moment que es necessiten, i no abans.</p> <p>Eixa transformaci\u00f3 de l'emmagatzematge de les dades, juntament amb les diferents t\u00e8cniques i eines de processament de dades espec\u00edfiques per a Big Data, permeten una gesti\u00f3 m\u00e9s eficient, \u00e0gil i escalable.</p>"},{"location":"u02/#on-premise-vs-cloud","title":"On-premise vs Cloud","text":"<p>Les plataformes Big Data es poden implementar de dues maneres principals:</p> <ul> <li>On-premise: La plataforma es desplega en els servidors de l'organitzaci\u00f3. Aquesta opci\u00f3 permet un major control sobre les dades i la seguretat, per\u00f2 requereix una inversi\u00f3 inicial m\u00e9s gran i un manteniment continu.</li> <li>Cloud: La plataforma es desplega en servidors al n\u00favol. Aquesta opci\u00f3 permet una major escalabilitat i flexibilitat, ja que es poden afegir o eliminar recursos segons les necessitats. A m\u00e9s, no requereix una inversi\u00f3 inicial tan gran, ja que es paga per \u00fas.</li> <li>H\u00edbrida: Una combinaci\u00f3 de les dues opcions anteriors. Algunes dades es poden emmagatzemar i processar en els servidors de l'organitzaci\u00f3, mentre que altres dades es poden emmagatzemar i processar en el n\u00favol. Aquesta opci\u00f3 permet un major control sobre les dades m\u00e9s sensibles, mentre que es pot aprofitar la flexibilitat i escalabilitat del n\u00favol per a altres dades.</li> </ul> <p>Segur que heu escoltat conceptes com:</p> <ul> <li>IaaS (Infrastructure as a Service): Prove\u00efment d'infraestructura inform\u00e0tica (servidors, emmagatzematge, xarxes, etc.) com un servei. L'organitzaci\u00f3 gestiona el sistema operatiu, les aplicacions i les dades.</li> <li>PaaS (Platform as a Service): Prove\u00efment d'una plataforma inform\u00e0tica (sistemes operatius, bases de dades, entorns de desenvolupament, etc.) com un servei. L'organitzaci\u00f3 nom\u00e9s gestiona les aplicacions i les dades.</li> <li>SaaS (Software as a Service): Prove\u00efment d'aplicacions inform\u00e0tiques (CRM, ERP, etc.) com un servei. L'organitzaci\u00f3 nom\u00e9s gestiona les dades.</li> </ul> <p></p>"},{"location":"u02/#capes-duna-arquitectura-big-data","title":"Capes d'una arquitectura Big Data","text":"<p>Una arquitectura Big Data est\u00e0 formada per diferents capes que permeten gestionar i processar grans volums de dades. Algunes de les capes m\u00e9s importants d'una arquitectura Big Data s\u00f3n:</p> <ul> <li>Capa d'adquisici\u00f3 i interconnexi\u00f3: Capa encarregada de recollir les dades des de les seves fonts d'origen.</li> <li>Capa de coneixement i emmagatzematge: Capa encarregada de guardar les dades i generar anal\u00edtiques a partir d'elles.</li> <li>Capa de interoperabilitat i integraci\u00f3: Capa encarregada de connectar els diferents components de la plataforma Big Data.</li> <li>Capa de serveis: Capa encarregada d'oferir serveis a trav\u00e9s d'una API, generalment.</li> <li>Capa de suport: Capa encarregada de donar suport als diferents components de la plataforma Big Data, gestionant aspectes com ara la seguretat, la monitoritzaci\u00f3, etc.</li> </ul> <p>Un esquema visual d'una arquitectura Big Data es pot veure a la figura seg\u00fcent:</p> <p></p>"},{"location":"u02/#capa-dadquisicio-i-interconnexio","title":"Capa d'adquisici\u00f3 i interconnexi\u00f3","text":"<p>La capa d'adquisici\u00f3 i interconnexi\u00f3 \u00e9s la capa encarregada de recollir les dades des de les seves fonts d'origen utilitzant protocols de comunicaci\u00f3 comuns. En aquesta capa tamb\u00e9 se fa la transformaci\u00f3 de les dades, si \u00e9s necessari, per a que quan entren a la plataforma ho facen amb el format establert. Aquesta capa pot incloure diferents components, com ara:</p> <ul> <li>Connectors: Components encarregats de connectar amb les diferents fonts de dades.</li> <li>Transformadors: Components encarregats de transformar les dades a un format com\u00fa.</li> <li>Validadors: Components encarregats de validar les dades abans de ser processades.</li> </ul>"},{"location":"u02/#capa-de-coneixement-i-emmagatzematge","title":"Capa de coneixement i emmagatzematge","text":"<p>La capa de coneixement i emmagatzematge \u00e9s la capa encarregada de guardar les dades en diferents sistemes gestors d'informaci\u00f3, i tamb\u00e9, si cal, de generar anal\u00edtiques a partir d'elles utilitzant t\u00e8cniques d'IA, regles, alertes, etc.</p>"},{"location":"u02/#capa-dinteroperabilitat-i-integracio","title":"Capa d'interoperabilitat i integraci\u00f3","text":"<p>La capa d'interoperabilitat i integraci\u00f3 \u00e9s la capa encarregada de connectar els diferents components de la plataforma Big Data, oferint interf\u00edcies o connectors que permeten l'acc\u00e9s a les dades de la plataforma. Aix\u00ed, podem construir serveis intel\u00b7ligents, connectar uns sistemes amb altres, o b\u00e9 preparar les dades per exposar-les a l'exterior. </p>"},{"location":"u02/#capa-de-serveis","title":"Capa de serveis","text":"<p>La capa de serveis ofereix diferents serveis a trav\u00e9s d'una API, com ara serveis d'an\u00e0lisi de dades, serveis de predicci\u00f3, serveis de recomanaci\u00f3, etc. Aquests serveis poden ser consumits per altres sistemes o per l'usuari final. Se poden fer \u00fas de components com ara:</p> <ul> <li>APIs: Interf\u00edcies de programaci\u00f3 d'aplicacions que permeten l'acc\u00e9s als serveis de la plataforma.</li> <li>Dashboards: Interf\u00edcies gr\u00e0fiques que permeten visualitzar les dades i els resultats obtinguts.</li> <li>GIS: Sistemes d'informaci\u00f3 geogr\u00e0fica que permeten visualitzar les dades en un mapa.</li> <li>Alarmes: Serveis que permeten enviar alarmes en funci\u00f3 de regles definides.</li> <li>Recomanadors: Serveis que permeten fer recomanacions en funci\u00f3 de les dades disponibles.</li> </ul>"},{"location":"u02/#capa-de-suport","title":"Capa de suport","text":"<p>La capa de suport \u00e9s la capa encarregada de donar suport als diferents components de la plataforma Big Data, gestionant aspectes com ara la seguretat, la monitoritzaci\u00f3, la gesti\u00f3 de l'escalabilitat, etc. Es tracta d'una capa transversal a tota la plataforma, la qual permet gestionar i administrar. Per exemple, pot incloure funcionalitats com ara: </p> <ul> <li>Seguretat: Gesti\u00f3 de l'acc\u00e9s a les dades i als serveis de la plataforma. Pot incloure la comprovaci\u00f3 i autoritzaci\u00f3 de les diferents fonts de dades i usuaris.</li> <li>Monitoritzaci\u00f3 i auditoria: Control de l'estat dels diferents components de la plataforma. L'auditoria permet registrar les accions realitzades pels usuaris i els sistemes.</li> <li>Gesti\u00f3 de l'escalabilitat: Gesti\u00f3 de la capacitat de processament i emmagatzematge de la plataforma. Per exemple, pot incloure la gesti\u00f3 de la c\u00e0rrega de treball i la distribuci\u00f3 de les dades.</li> <li>Gesti\u00f3 de l'administraci\u00f3: Gesti\u00f3 dels usuaris, dels permisos, dels logs, etc. </li> </ul> <p>Ara que ja hem vist les diferents capes i les seues funcions, podem mostrar un esquema m\u00e9s detallat d'una plataforma Big Data:</p> <p></p> <p>Les diferents capes:</p> <p>Capa d'adquisici\u00f3</p> <p></p> <p>Capa de coneixement i emmagatzematge</p> <p></p> <p>Capa d'interoperabilitat i integraci\u00f3</p> <p></p> <p>Capa de serveis</p> <p></p> <p>Capa de suport</p> <p></p>"},{"location":"u02/#flux-i-qualitat-de-les-dades","title":"Flux i qualitat de les dades","text":"<p>El flux de dades en el context de Big Data es refereix al moviment de dades des del seu origen fins al seu dest\u00ed. Les dades, i el seu processament, \u00e9s la part m\u00e9s important d'un sistema Big Data. La qualitat de les dades \u00e9s imprescindible per a obtenir resultats fiables, correctes i \u00fatils.</p>"},{"location":"u02/#fases-del-flux-de-dades","title":"Fases del flux de dades","text":"<ol> <li> <p>Ingesti\u00f3 de dades: Proc\u00e9s d'adquisici\u00f3 de dades des de les seves fonts d'origen. Aquestes dades poden ser estructurades, semiestructurades o no estructurades.</p> </li> <li> <p>Normalitzaci\u00f3 de dades: Proc\u00e9s de transformaci\u00f3 de les dades per a que siguin compatibles amb el sistema de gesti\u00f3 de dades. Dins del proc\u00e9s de normalitzaci\u00f3 podem tamb\u00e9 trobar la neteja de dades. La neteja consisteix en la identificaci\u00f3 i correcci\u00f3 d'errors en les dades. La normalitzaci\u00f3 de dades tamb\u00e9 pot incloure la transformaci\u00f3 de les dades a un format com\u00fa.</p> </li> <li> <p>Distribuci\u00f3 de dades: Proc\u00e9s de distribuci\u00f3 de les dades en els diferents nodes del sistema de processament.</p> </li> <li> <p>Emmagatzenament i an\u00e0lisi de les dades: Proc\u00e9s de guardar les dades en un sistema de fitxers distribu\u00eft i processar-les per a obtenir resultats.</p> </li> <li> <p>Presentaci\u00f3 i exposici\u00f3 de les dades: Proc\u00e9s de visualitzaci\u00f3 i exposici\u00f3 de les dades per a que siguin comprensibles pels usuaris i/o accessibles per altres sistemes.</p> </li> </ol> <p>Un esquema resumit de les diferents fases del flux de dades es pot veure a la figura seg\u00fcent:</p> <p></p>"},{"location":"u02/#ingesta-de-dades","title":"Ingesta de dades","text":"<p>La ingesta de dades \u00e9s el proc\u00e9s d'adquisici\u00f3 de dades des de les seves fonts d'origen. Les dades poden ser, com hem vist, estructurades, semiestructurades o no estructurades. Les dades poden provenir de diferents fonts, com ara:</p> <ul> <li>Bases de dades relacionals</li> <li>Fitxers de text</li> <li>Fitxers de logs</li> <li>Sensors</li> <li>Xarxes socials</li> <li>etc.</li> </ul> <p>La ingesta de dades ha de complir amb els protocols de seguretat i privacitat establerts en les diferents fonts de dades. S'han de seguir els protocols de comunicaci\u00f3n definits en cada cas. La ingesta de dades pot ser en temps real o en batch, com s'ha comentat abans.</p>"},{"location":"u02/#normalitzacio-de-dades","title":"Normalitzaci\u00f3 de dades","text":"<p>Les dades recollides s'han de normalitzar per a que siguin compatibles amb el sistema de gesti\u00f3 de dades. La normalitzaci\u00f3 de dades pot incloure la neteja de dades, la transformaci\u00f3 de dades a un format com\u00fa i la identificaci\u00f3 de dades duplicades.</p> <p>Hi ha est\u00e0ndars, com ara NGSI, que defineixen com s'han de normalitzar les dades per a que siguin compatibles amb els sistemes de gesti\u00f3 de dades. NGSI \u00e9s un protocol que utilitzen les APis dels components FIWARE per a normalitzar les dades. FIWARE \u00e9s una plataforma d'arquitectura oberta que permet la creaci\u00f3 de solucions IoT i Smart City.</p>"},{"location":"u02/#distribucio-de-dades","title":"Distribuci\u00f3 de dades","text":"<p>Les dades normalitzades s'han de distribuir en els diferents nodes del sistema de processament. La distribuci\u00f3 de dades es pot fer de forma centralitzada o distribu\u00efda. En sistemes distribu\u00efts, com ara Hadoop, les dades es distribueixen en els diferents nodes del sistema de processament.</p>"},{"location":"u02/#emmagatzematge-i-analisi-de-dades","title":"Emmagatzematge i an\u00e0lisi de dades","text":"<p>Les dades, una vegada normalitzades, s'emmagatzemen en el repositori de la plataforma corresponent. Diferents sistemes anal\u00edtics poden processar les dades per a obtenir resultats. Els resultats poden ser guardats en el repositori o exposats a trav\u00e9s d'una API. En el processament se poden buscar anomalies en funci\u00f3 de regles definides, alarmes, tend\u00e8ncies, etc. Aplicant models de IA es poden fer prediccions, recomanacions, o generar nou coneiximent.</p>"},{"location":"u02/#presentacio-i-exposicio-de-les-dades","title":"Presentaci\u00f3 i exposici\u00f3 de les dades","text":"<p>Els resultats obtinguts en el proc\u00e9s d'an\u00e0lisi de dades es poden visualitzar i exposar a trav\u00e9s d'una interf\u00edcie gr\u00e0fica. Les dades tamb\u00e9 es poden exposar a trav\u00e9s d'una API per a que altres sistemes puguin accedir-hi. La presentaci\u00f3 i exposici\u00f3 de les dades ha de ser el m\u00e9s intu\u00eftiva possible, clara i comprensible per a l'usuari final. L'objectiu \u00e9\u015b facilitar la presa de decisions basada en les dades i la gesti\u00f3 dels diferents serveis que s'ofereixen a partir de les dades resultants de l'an\u00e0lisi.</p>"},{"location":"u02/#qualitat-de-les-dades","title":"Qualitat de les dades","text":"<p>La qualitat de les dades es pot mesurar en funci\u00f3 de diferents aspectes:</p> <ul> <li>Precisi\u00f3: Les dades s\u00f3n correctes i exactes?</li> <li>Integritat: Les dades s\u00f3n coherents i consistents?</li> <li>Consist\u00e8ncia: Les dades s\u00f3n uniformes i homog\u00e8nies?</li> <li>Actualitat: Les dades s\u00f3n actuals i vigents?</li> <li>Completitud: Les dades s\u00f3n completes i no hi ha valors en blanc?</li> <li>Usabilitat: Les dades s\u00f3n f\u00e0cils d'entendre i utilitzar?</li> </ul>"},{"location":"u03/","title":"Rep\u00e0s Docker","text":"<p>En aquesta unitat farem un rep\u00e0s de la tecnologia de contenidors, les imatges i el funcionament b\u00e0sic de Docker. Aquesta unitat \u00e9s un rep\u00e0s dels coneixements que ja haur\u00edem d'haver adquirit en cursos anteriors, per la qual cosa no entrarem en massa detall. Si voleu aprofundir m\u00e9s en el tema, podeu consultar la documentaci\u00f3 oficial de Docker a https://docs.docker.com/get-started.</p> <p>Treballarem amb Docker en un entorn Linux, encara que tamb\u00e9 est\u00e0 disponible per a Windows i MacOS. Si treballeu en un altre Sistema Operatiu que no siga Linux podeu utilitzar Docker Desktop, que \u00e9s una aplicaci\u00f3 que permet utilitzar Docker en Windows i MacOS. Podeu descarregar-la des de https://www.docker.com/products/docker-desktop.</p>"},{"location":"u03/#contenidors","title":"Contenidors","text":"<p>Un contenidor \u00e9s una unitat d'execuci\u00f3 lleugera que inclou tot el necessari per a executar una aplicaci\u00f3. Amb els contenidors podem empaquetar i distribuir aplicacions juntament amb les seves depend\u00e8ncies. Els contenidors s\u00f3n una eina molt \u00fatil per a desplegar aplicacions de forma r\u00e0pida i eficient.Aix\u00f2 ens permetr\u00e0 tenir un entorn de desenvolupament id\u00e8ntic a l'entorn de producci\u00f3.</p> <p>Podr\u00edem dir que el contenidor \u00e9s tamb\u00e9 una tecnologia de virtualitzaci\u00f3. A difer\u00e8ncia d\u2019una m\u00e0quina virtual, el contenidor utilitza el sistema base de la m\u00e0quina anfitriona i actua com un entorn privat que comparteix recursos amb el sistema anfitri\u00f3 sense necessitat de virtualitzar tot el hardware.</p>"},{"location":"u03/#avantatges-de-lus-de-contenidors","title":"Avantatges de l'\u00fas de contenidors","text":"<ul> <li> <p>La flexibilitat. Els contenidors s\u00f3n lleugers i portables, i poden ser executats en qualsevol lloc. Fins i tot les aplicacions m\u00e9s complexes poden incloure's als contenidors. </p> </li> <li> <p>La consist\u00e8ncia. Els contenidors asseguren que les aplicacions funcionen de la mateixa manera en qualsevol entorn.</p> </li> <li> <p>La efici\u00e8ncia. Els contenidors permeten als desenvolupadors empaquetar i distribuir aplicacions juntament amb les seves depend\u00e8ncies.</p> </li> <li> <p>La portabilitat. Els contenidors poden ser desplegats i executats en qualsevol lloc, ja siga en un entorn local, en el n\u00favol o en un centre de dades.</p> </li> <li> <p>La seguretat. Els contenidors ofereixen un entorn segur per a executar aplicacions.</p> </li> <li> <p>L'escalabilitat. Els contenidors permeten escalar aplicacions de forma r\u00e0pida i eficient.</p> </li> <li> <p>La poca c\u00e0rrega que suposen per al sistema, al compartir el mateix kernel que el sistema anfitri\u00f3.</p> </li> <li> <p>La possibilitat d'actualitzar \"en calent\". \u00c9s a dir, sense haver de parar el servei.</p> </li> </ul>"},{"location":"u03/#imatges","title":"Imatges","text":"<p>Una imatge \u00e9s un paquet que cont\u00e9 tot el necessari per a executar una aplicaci\u00f3, incloent l'entorn d'execuci\u00f3, el codi, les llibreries, les depend\u00e8ncies, les dades i la configuraci\u00f3 (variables d'entorn, fitxers, etc.) Les imatges s\u00f3n immutables, \u00e9s a dir, no es poden modificar. Per a modificar una imatge, cal crear una nova imatge a partir de l\u2019original.</p>"},{"location":"u03/#imatges-i-contenidors","title":"Imatges i contenidors","text":"<p>Un contenidor \u00e9s una inst\u00e0ncia d'una imatge. Si una imatge cont\u00e9 tot el necessari per a executar una aplicaci\u00f3, el contenidor seria com una inst\u00e0ncia d'eixa aplicaci\u00f3 en execuci\u00f3. Una imatge \u00e9s un arxiu de nom\u00e9s lectura que cont\u00e9 un conjunt de capes que s\u00f3n utilitzades per a crear un sistema de fitxers. M\u00e9s endavant veurem com crear imatges, com utilitzar imatges ja creades, i sobretot com utilitzar-les per a crear contenidors.</p>"},{"location":"u03/#docker","title":"Docker","text":"<p>Docker \u00e9s una plataforma de codi obert que permet automatitzar el desplegament d'aplicacions dins de contenidors. Docker permet als desenvolupadors empaquetar, enviar i executar aplicacions com contenidors. Aix\u00f2 permet, com hem comentat abans, simular un entorn de producci\u00f3 sense haver de modificar ni configurar el nostre sistema operatiu anfitri\u00f3.</p> <p></p> <p>B\u00e0sicament, el que aconsegueix Docker \u00e9s oferir contenidors d'aplicacions que aprofiten les capacitats de virtualitzaci\u00f3 del sistema amfitri\u00f3 per poder executar processos i serveis de forma a\u00efllada. Es tracta d'un concepte paregut al de m\u00e0quina virtual, per\u00f2 que no requerix d'un sistema operatiu. En Linux, per exemple, Docker fa \u00fas de les caracter\u00edstiques d'a\u00efllament de recursos (CPU, mem\u00f2ria, xarxa...) del nucli del sistema, tals com els cgroups i els namespaces, de manera que podem tindre diversos contenidors compartint el mateix kernel de Linux, per\u00f2 cadascun amb restriccions d'acc\u00e9s a determinats recursos. Aix\u00ed, contenidors independents s'executen dins una mateixa inst\u00e0ncia de Linux, evitant la sobrec\u00e0rrega d'iniciar i mantenir m\u00e0quines virtuals (on cada m\u00e0quina cont\u00e9 tot el necessari per a fer anar un sistema operatiu complet).</p>"},{"location":"u03/#installacio-de-docker-en-linux","title":"Instal\u00b7laci\u00f3 de Docker en Linux","text":"<p>Per a instal\u00b7lar Docker en una distribuci\u00f3 Linux, cal seguir els seg\u00fcents passos:</p> <ol> <li>Actualitzar la llista de paquets disponible el sistema:</li> </ol> <pre><code>sudo apt-get update \n</code></pre> <ol> <li>Instal\u00b7lar els paquets necessaris per a que el sistema puga descarregar paquets a trav\u00e9s de HTTPS:</li> </ol> <pre><code>sudo apt-get install apt-transport-https ca-certificates curl software-properties-common\n</code></pre> <ol> <li>Afegir la clau GPG oficial de Docker:</li> </ol> <pre><code>sudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n</code></pre> <ol> <li>Afegir el repositori de Docker a la llista de repositoris del sistema:</li> </ol> <pre><code>echo \"deb [signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n</code></pre> <ol> <li>Actualitzar la llista de paquets disponible el sistema:</li> </ol> <pre><code>sudo apt-get update\n</code></pre> <ol> <li>Instal\u00b7lar la versi\u00f3 comunit\u00e0ria de Docker:</li> </ol> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <ol> <li>Comprovar que Docker s'ha instal\u00b7lat correctament:</li> </ol> <pre><code>sudo docker --version\nsudo docker run hello-world\n</code></pre> <p>En teoria ens hauria d'apar\u00e8ixer un missatge com el seg\u00fcent:</p> <pre><code>$ sudo docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\nd1725b59e92d: Pull complete \nDigest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre> <p>Com veiem, l'execuci\u00f3 de docker s'ha realitzat com a sudo. Si volem utilitzar docker per a altres usuaris, nom\u00e9s haurem de crear un grup docker (o comprovar si ja existeix) i afegir ahi els usuaris que el puguen utilitzar.</p> <p>Per altra banda, veiem com utilitzar docker per tal de llan\u00e7ar una imatge: <code>docker run</code>. En aquest cas, una imatge de prova anomenada hello-world.</p> <p>Com veiem, ens indica que no troba la imatge 'hello-world:latest' en local, pel que la descarrega de la llibrer\u00eda (pull). Una vegada descarregada ja ens mostra el missatge que comen\u00e7a amb \"Hello from Docker\", corresponent a aquesta imatge.</p> <p>Si tornem a llan\u00e7ar l'ordre, comprovarem com ja no realitza la desc\u00e0rrega sin\u00f2 que executa directament la imatge Hello World.</p> <p>Si no voleu fer sudo cada vegada, podeu afegir-vos al grup docker fent <code>sudo usermod -aG docker $USER</code>. Si treballeu amb els ordinadors del centre, ja esteu afegits al grup.</p>"},{"location":"u03/#docker-i-serveis","title":"Docker i serveis","text":"<p>El dimoni (daemon) de Docker \u00e9s el servei que gestiona la creaci\u00f3, execuci\u00f3 i distribuci\u00f3 de contenidors. L'ordre <code>docker</code> que hem vist anteriorment, \u00e9s el client de docker, que permet a l'usuari interactuar amb el sistema, encara que tamb\u00e9 hi ha altres aplicacions clints.</p> <p>Si volem que el servei de Docker s'inicie en arrancar el sistema (systemd), farem:</p> <pre><code>sudo systemctl enable docker\n</code></pre> <p>I si volem llevar-lo de l'inici:</p> <pre><code>sudo systemctl disable docker\n</code></pre> <p>Podem trobar m\u00e9s informaci\u00f3 sobre tot el que podem fer despr\u00e9s d'haver instal\u00b7lat Docker en: https://docs.docker.com/install/linux/linux-postinstall/#configure-docker-to-start-on-boot, aix\u00ed com documentaci\u00f3 per a la configuraci\u00f3 del servei de Docker per a que escolte determinats ports mitjan\u00e7ant el fitxer /etc/docker/daemon.json: https://docs.docker.com/install/linux/linux-postinstall/#configure-where-the-docker-daemon-listens-for-connections</p>"},{"location":"u03/#comandes-basiques-de-docker","title":"Comandes b\u00e0siques de Docker","text":"<p>A continuaci\u00f3, veurem algunes de les comandes b\u00e0siques de Docker:</p> <ul> <li><code>docker run</code>: Llan\u00e7a un contenidor a partir d'una imatge, tal com acabem de veure.</li> <li><code>docker create</code>: Crea un contenidor a partir d'una imatge, per\u00f2 no l'executa.</li> <li><code>docker ps</code>: Mostra els contenidors en execuci\u00f3.</li> <li><code>docker ps -a</code>: Mostra tots els contenidors, tant els que estan en execuci\u00f3 com els que no.</li> <li><code>docker images</code>: Mostra les imatges disponibles en el sistema.</li> <li><code>docker pull</code>: Descarrega una imatge de Docker Hub sense crear cap contenidor</li> <li><code>docker push</code>: Puja una imatge a Docker Hub.</li> <li><code>docker rmi</code>: Elimina una imatge.</li> <li><code>docker rm</code>: Elimina un contenidor.</li> <li><code>docker start</code>: Inicia un contenidor. Si el contenidor ja existeix, farem <code>docker start</code>, no <code>docker run</code> cada vegada</li> <li><code>docker stop</code>: Para un contenidor.</li> <li><code>docker restart</code>: Reinicia un contenidor.</li> <li><code>docker exec</code>: Executa una comanda en un contenidor en execuci\u00f3.</li> <li><code>docker logs</code>: Mostra els logs d'un contenidor.</li> <li><code>docker inspect</code>: Mostra informaci\u00f3 detallada d'un contenidor o imatge.</li> <li><code>docker cp</code>: Copia fitxers entre el sistema local i un contenidor.</li> <li><code>docker commit</code>: Crea una nova imatge a partir d'un contenidor en execuci\u00f3.</li> <li><code>docker build</code>: Construeix una imatge a partir d'un fitxer Dockerfile.</li> <li><code>docker-network</code>: Permet posar contenidors en xarxa.</li> <li><code>docker-attach</code>: Permet connectar-se a un contenidor en execuci\u00f3 i veure en el nostre terminal el que es mostra en el terminal del contenidor.</li> </ul> <p>Exemple: anem a vore com descarregar i llan\u00e7ar una imatge per a Docker de Busybox. Busybox no \u00e9s m\u00e9s que una utilitat que combina moltes eines est\u00e0ndards d'Unix i ordres de Linux en un sol fitxer.</p> <pre><code># docker pull busybox\nUsing default tag: latest\nlatest: Pulling from library/busybox\n8c5a7da1afbc: Pull complete \nDigest: sha256:cb63aa0641a885f54de20f61d152187419e8f6b159ed11a251a09d115fdff9bd\nStatus: Downloaded newer image for busybox:latest\n</code></pre> <p>Amb a\u00e7\u00f2 hem descarregat la imatge de busybox pe a Docker des del Docker Hub (https://hub.docker.com/explore/). </p> <p>Si volem comprovar que l'hem descarregat, podem executar <code>docker images</code>, que ens mostra les imatges que tenim baixades:</p> <pre><code># docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nhello-world         latest              4ab4c602aa5e        3 weeks ago         1.84kB\nbusybox             latest              e1ddd7948a1c        2 months ago        1.16MB\n</code></pre> <p>Ara anem a executar el contenidor amb <code>docker run</code>:</p> <pre><code># docker run busybox\n</code></pre> <p>Dos coses que podem veure: com que a tenim descarregada la imatge, no la torna a descarregar. Amb la imatge de busybox al sistema, Docker la busca, la carrega en un contenidor i executa al busybox les ordres que li passem. </p> <p>Segona cosa: com que en aquest cas no li hem passat cap ordre, aparentment, no far\u00e0 res.</p> <p>Ara anem a executar una instrucci\u00f3 dins del contenidor:</p> <pre><code># docker run busybox echo \"Hola m\u00f3n!\"\nHola m\u00f3n!\n</code></pre> <p>O tamb\u00e9:</p> <pre><code># docker run busybox ls\nbin\ndev\netc\nhome\nproc\nroot\nsys\ntmp\nusr\nvar\n</code></pre> <p>O fins i tot veure l'arxiu d'usuaris:</p> <pre><code># docker run busybox cat /etc/passwd\nroot:x:0:0:root:/root:/bin/sh\ndaemon:x:1:1:daemon:/usr/sbin:/bin/false\nbin:x:2:2:bin:/bin:/bin/false\nsys:x:3:3:sys:/dev:/bin/false\nsync:x:4:100:sync:/bin:/bin/sync\nmail:x:8:8:mail:/var/spool/mail:/bin/false\nwww-data:x:33:33:www-data:/var/www:/bin/false\noperator:x:37:37:Operator:/var:/bin/false\nnobody:x:65534:65534:nobody:/home:/bin/false\n</code></pre> <p>Per veure els contenidors que tenim en execuci\u00f3, podem utilitzar <code>docker ps</code>:</p> <pre><code># docker ps\nCONTAINER ID    IMAGE       COMMAND       CREATED          STATUS           PORTS   NAMES\nd4018e11cc64    busybox     \"sleep 10\"    5 seconds ago    Up 4 seconds             elegant_keldysh\n</code></pre> <p>Si executem l'ordre <code>sh</code> dins del contenidor, podem interactuar amb ell:</p> <pre><code># docker exec -it d4018e11cc64 sh\n/ # ls\nbin   dev   etc   home  proc  root  sys   tmp   usr   var\n/ # exit\n</code></pre> <p>amb <code>docker run -it imatge</code> el contenidor se crea a partir de la imatge, se queda en funcionament i no se tanca</p> <p>amb <code>docker run -it -rm imatge</code> el contenidor se crea, se queda en funcionament i quan el tanquem, se borra</p> <p>Amb l'opci\u00f3 -a de docker ps podem obtindre tots els contenidors que s'han creat en la sessi\u00f3 actual:</p> <pre><code># docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                        \n5dde99182cec        busybox             \"sh\"                2 minutes ago       Exited (0) 2 minutes ago                           festive_ride\nd4018e11cc64        busybox             \"sleep 10\"          16 minutes ago      Exited (0) 16 minutes ago                          elegant_keldysh\n2a2b08d458c5        busybox             \"ps aux\"            20 minutes ago      Exited (0) 19 minutes ago                          \nb17136bc9389        busybox             \"cat /etc/passwd\"   22 minutes ago      Exited (0) 22 minutes ago                          gifted_archimedes\na475a7587143        busybox             \"ls\"                23 minutes ago      Exited (0) 23 minutes ago                          jovial_leavitt\n1febe609a9a9        busybox             \"echo hola\"         23 minutes ago      Exited (0) 23 minutes ago                          compassionate_spence\ndc64b0307514        busybox             \"sh\"                25 minutes ago      Exited (0) 24 minutes ago                          clever_lalande\n2a4808f37627        hello-world         \"/hello\"            About an hour ago   Exited (0) About an hour ago                       nostalgic_stallman\n31545996cff7        hello-world         \"/hello\"            About an hour ago   Exited (0) About an hour ago \n</code></pre> <p>Per a eliminar un contenidor, farem servir <code>docker rm</code>:</p> <pre><code># docker rm 5dde99182cec\n5dde99182cec\n</code></pre> <p>I per a eliminar una imatge, farem servir <code>docker rmi</code>:</p> <pre><code># docker rmi busybox\nUntagged: busybox:latest\nUntagged: busybox@sha256:cb63aa0641a885f54de20f61d152187419e8f6b159ed11a251a09d115fdff9bd\nDeleted: sha256:e1ddd7948a1c1e0b0c6b4f3b3d1f0e3f3b3b1f1b4a7d1b3b1b3b1b3b1b3b1b3b1\nDeleted: sha256:8c5a7da1afbc\n</code></pre>"},{"location":"u03/#dockerfile","title":"Dockerfile","text":"<p>Hem vist com descarregar imatges i crear contenidors a partir d'elles. I si volem crear les nostres pr\u00f2pies imatges, o ampliar imatges que ja existeixen? Per a a\u00e7\u00f2, farem servir un fitxer anomenat Dockerfile i la instrucci\u00f3 <code>docker build</code>.</p> <p>Un Dockerfile \u00e9s un fitxer de text que cont\u00e9 una s\u00e8rie d'instruccions que Docker ha d'executar per a crear una imatge. Aquestes instruccions s\u00f3n molt senzilles i permeten crear imatges personalitzades a partir d'imatges existents.</p> <p>Avantatges de crear imatges a partir d'un Dockerfile:</p> <ul> <li> <p>Podrem reproduir la imatge f\u00e0cilment ja que al Dockerfile tenim totes i cadascuna de les ordres necess\u00e0ries per a la construcci\u00f3 de la imatge. </p> </li> <li> <p>Podrem configurar el proc\u00e9s que s'executar\u00e0 per defecte als contenidors creats a partir de la nova imatge. Si volem canviar la imatge de base, aix\u00f2 \u00e9s extremadament senzill amb un Dockerfile.</p> </li> </ul> <p>Les principals instruccions que podem trobar en un Dockerfile s\u00f3n:</p> <ul> <li><code>FROM</code>: Indica la imatge de base a partir de la qual es crear\u00e0 la nova imatge.</li> <li><code>RUN</code>: Executa una instrucci\u00f3 en el sistema de fitxers de la imatge.</li> <li><code>COPY</code>: Copia fitxers des del sistema local a la imatge.</li> <li><code>ADD</code>: Similar a COPY, per\u00f2 permet copiar fitxers des d'una URL.</li> <li><code>CMD</code>: Especifica la comanda que s'executar\u00e0 per defecte en els contenidors creats a partir de la imatge.</li> <li><code>ENTRYPOINT</code>: Especifica la comanda que s'executar\u00e0 quan es llance el contenidor amb docker run</li> <li><code>EXPOSE</code>: Indica els ports que s'han d'exposar quan es llance el contenidor.</li> <li><code>VOLUME</code>: Indica els volums que s'han de crear quan es llance el contenidor.</li> <li><code>WORKDIR</code>: Indica el directori de treball per defecte.</li> <li><code>ENV</code>: Defineix variables d'entorn.</li> <li><code>ARG</code>: Defineix variables que es poden passar a la imatge en el moment de la construcci\u00f3.</li> <li><code>LABEL</code>: Afegeix metadades a la imatge.</li> <li><code>USER</code>: Indica l'usuari que s'ha d'utilitzar per a executar les ordres.</li> </ul> <p>Per exemple, anem a veure com serie m\u00e9s o menys un Dockerfile per a crear una imatge de node-red:</p> <pre><code>FROM nodered/node-red\n# Copy package.json to the WORKDIR so npm builds all\n# of your added nodes modules for Node-RED\nCOPY package.json .\nRUN npm install --unsafe-perm --no-update-notifier --no-fund --only=production\n# Copy _your_ Node-RED project files into place\n# NOTE: This will only work if you DO NOT later mount /data as an external volume.\n#       If you need to use an external volume for persistence then\n#       copy your settings and flows files to that volume instead.\nCOPY settings.js /data/settings.js\nCOPY flows_cred.json /data/flows_cred.json\nCOPY flows.json /data/flows.json\n# Expose the listening port of Node-RED\nEXPOSE 1880\n</code></pre> <p>Amb docker build, crearem la imatge a partir del Dockerfile:</p> <pre><code>docker build -t node-red .\n</code></pre> <p>I amb docker run, llan\u00e7arem el contenidor:</p> <pre><code>docker run -d -p 1880:1880 --name mynodered node-red\n</code></pre> <p>Qu\u00e9 significa -d i -p? </p> <p>-d significa que el contenidor s'executar\u00e0 en segon pla, \u00e9s a dir, en background.  -p significa que el port 1880 del contenidor es mapejar\u00e0 al port 1880 de la m\u00e0quina host.</p> <p>Podem provar si funciona accedint desde la URL a http://localhost:1880.</p>"},{"location":"u03/#volums","title":"Volums","text":"<p>Si eliminem un contenidor o el tornem a crear amb la mateixa imatge, perdrem totes les dades que h\u00e0gim creat dins del contenidor. Per a evitar a\u00e7\u00f2, farem servir volums.</p> <p>Un volum \u00e9s un directori que es pot compartir entre contenidors i amb el sistema host. Els volums s\u00f3n una eina molt \u00fatil per a persistir dades i compartir-les entre contenidors. </p> <p>En Linux els volums se guarden a <code>/var/lib/docker/volumes</code>. Els volums se solen utilitzar en els casos seg\u00fcents:</p> <ul> <li>Per compartir dades entre contenidors. Simplement hauran de fer servir el mateix volum.</li> <li>Per a c\u00f2pies de seguretat ja sigui perqu\u00e8 siguin usades posteriorment per altres contenidors o per moure aquests volums a altres hosts.</li> <li>Quan vull emmagatzemar les dades del meu contenidor en el sistema amfitri\u00f3 o fins i tot en un prove\u00efdor cloud.</li> </ul> <p>Per a gestionar volums tenim les seg\u00fcents comandes:</p> <ul> <li><code>docker volume create</code>: Crea un volum amb el nom que indiquem</li> <li><code>docker volume ls</code>: Llista els volums disponibles</li> <li><code>docker volume inspect</code>: Mostra informaci\u00f3 detallada d'un volum</li> <li><code>docker volume rm</code>: Elimina un volum</li> <li><code>docker volume prune</code>: Elimina tots els volums no utilitzats</li> </ul> <p>Anem a veure un xicotet exemple de com fer servir volums creant un miniservidor Apache:</p> <ul> <li>Primer creem el volum</li> </ul> <pre><code>docker volume create miweb\n</code></pre> <p>Ara creem un contenidor amb un servidor apache, montant el volum:</p> <pre><code>$ docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4\n</code></pre> <p>Amb a\u00e7\u00f2, hem creat un contenidor amb un servidor Apache que servir\u00e0 el contingut del volum <code>miweb</code> en el port 8080 de la m\u00e0quina host. El par\u00e0metre <code>dst</code> indica el directori on es muntar\u00e0 el volum dins del contenidor.</p> <p>Anem a crear un fitxer HTML dins del volum:</p> <pre><code>$ docker exec my-apache-app bash -c 'echo \"&lt;html&gt;&lt;head&gt;&lt;meta charset=\\\"UTF-8\\\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hola, m\u00f3n!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\" &gt; /usr/local/apache2/htdocs/index.html'\n</code></pre> <p>Ara podem accedir a la nostra web a trav\u00e9s de la URL http://localhost:8080 i veure qu\u00e8 mostra.</p> <p></p> <p>Si ara eliminem el contenidor amb <code>docker rm -f my-apache-app</code>, el volum no es veur\u00e0 afectat encara que ara <code>localhost:8080</code> mostrar\u00e0 un error perqu\u00e8 no hi ha cap Apache en funcionament. </p> <p>Anem a crear un altre contenidor i muntar el mateix volum, encara que ara utilitzarem l'opci\u00f3 <code>-v</code>:</p> <pre><code>$ docker run -d --name my-apache-app -v miweb:/usr/local/apache2/htdocs -p 8080:80 httpd:2.4\n</code></pre> <p>Com podeu comprovar, sense tornar a crear l'arxiu <code>index.html</code>, la web ja est\u00e0 disponible a http://localhost:8080.</p>"},{"location":"u03/annex/","title":"Docker Compose","text":"<p>Docker Compose \u00e9s una eina que permet definir i executar aplicacions amb varis contenidors. Docker Compose ens permet definir, crear i al\u00e7ar  un conjunt de contenidors a parti d'un \u00fanic arxiu de configuraci\u00f3 i amb una sola instrucci\u00f3.</p> <p>El primer pas \u00e9s definir un arxiu YAML per configurar els serveis de  l'aplicaci\u00f3. A continuaci\u00f3, amb una instrucci\u00f3 docker compose, es crea i posa  en marxa tot l'entorn des de la configuraci\u00f3. Aix\u00ed, podem treballar amb diferents serveis i volums, amb l'opci\u00f3 de definir una xarxa comuna per a tots ells.</p> <p>Amb Docker Compose podem:</p> <ul> <li>Definir, arrancar i parar serveis</li> <li>Veure l'estat dels serveis</li> <li>Veure els logs dels serveis en marxa</li> <li>Executar una instrucci\u00f3 en un serveis</li> </ul> <p>En general Docker Compose \u00e9s similar a Kubernetes pel que fa a muntar un entorn de treball amb diferents contenidors connectats. Docker Compose \u00e9s m\u00e9s senzill i est\u00e0 pensat per a entorns de desenvolupament i per a fer proves.</p> <p>Per a utilitzar Docker Compose cal tenir instal\u00b7lat Docker al nostre sistema. Per comprovar que tenim instal\u00b7lat Docker Compose podem executar la seg\u00fcent instrucci\u00f3:</p> <pre><code>docker-compose --version\n</code></pre> <p>Si no tenim instal\u00b7lat <code>docker-compose</code>, podem fer-ho amb la seg\u00fcent instrucci\u00f3:</p> <pre><code>sudo apt install docker-compose\n</code></pre> <p>De totes formes, en versions recents de Docker poder fer <code>docker compose</code> en lloc de <code>docker-compose</code>.</p>"},{"location":"u03/annex/#el-fitxer-docker-composeyml","title":"El fitxer docker-compose.yml","text":"<p>Com hem comentat, el primer pas per a utilitzar Docker Compose \u00e9s crear un arxiu de configuraci\u00f3 anomenat docker-compose.yml. Aquest arxiu \u00e9s un arxiu de configuraci\u00f3 YAML que cont\u00e9 la definici\u00f3 dels serveis, xarxes i volums que formen l'aplicaci\u00f3 que volem al\u00e7ar.</p> <p>L'estructura b\u00e0sica d'un arxiu docker-compose.yml \u00e9s la seg\u00fcent:</p> <pre><code>version: '3.8'\nservices:\n  servei1:\n    image: imatge1\n    ports:\n      - \"port_host:port_container\"\n    expose:\n      - \"port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\n  servei2:\n    image: imatge2\n    ports:\n      - \"port_host:port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\nnetworks:\n  xarxa1:\n    driver: bridge\n  xarxa2:\n    driver: bridge\n</code></pre> <ul> <li>version: Indica la versi\u00f3 de la sintaxi de Docker Compose que estem utilitzant.</li> <li>services: Cont\u00e9 la definici\u00f3 dels serveis que formen l'aplicaci\u00f3.</li> <li>volumes: Volums que formen l'aplicaci\u00f3 i mapeig entre el host i el contenidor.</li> <li>image: Les imatges que s'utilitzaran per a crear els contenidors.</li> <li>ports: Mapeig de ports entre el host i el contenidor.</li> <li>expose: Exposa un port del contenidor sense fer-lo accessible des de l'exterior.</li> <li>networks: Definici\u00f3 i configuraci\u00f3 de les xarxes.</li> <li>driver: Driver de la xarxa. La xarxa per defecte de Docker \u00e9s bridge.</li> </ul> <p>Podem utilitzar depends_on per a indicar que un servei dep\u00e8n d'un altre, de forma que el servei depenent no arrancar\u00e0 fins que arranque el servei del qual dep\u00e8n.</p> <pre><code>version: '3.8'\nservices:\n  servei1:\n    image: imatge1\n    ports:\n      - \"port_host:port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\n  servei2:\n    image: imatge2\n    ports:\n      - \"port_host:port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\n    depends_on:\n      - servei1\n</code></pre> <p>Com a alternativa a image, amb l'etiqueta build podem indicar la ruta on es troba el Dockerfile per a construir la imatge.</p> <p>Per exemple, si en la mateixa carpeta on tenim l'arxiu docker-compose.yml tenim un Dockerfile, podem fer:</p> <pre><code>version: '3.8'\nservices:\n  servei1:\n    build: .\n    ports:\n      - \"port_host:port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\n</code></pre> <p>Tamb\u00e9 podem crear variables d'entorn en els contenidors amb l'etiqueta environment.</p> <pre><code>version: '3.8'\nservices:\n  servei1:\n    image: imatge1\n    ports:\n      - \"port_host:port_container\"\n    volumes:\n      - \"volum_host:volum_container\"\n    environment:\n      - VAR1=valor1\n      - VAR2=valor2\n</code></pre> <p>Amb l'etiqueta restart podem indicar com volem que es comporte el contenidor en cas de reinici. </p> <ul> <li>restart: no: No es reiniciar\u00e0 mai. Aix\u00f2 implica que si el contenidor es para, no es tornar\u00e0 a al\u00e7ar a no ser que ho fem manualment.</li> <li>restart: always: Es reiniciar\u00e0 sempre que es pare.</li> <li>restart: on-failure: Es reiniciar\u00e0 nom\u00e9s si el contenidor falla. </li> <li>restart: unless-stopped: Es reiniciar\u00e0 sempre que es pare, a no ser que el parem manualment.</li> </ul>"},{"location":"u03/annex/#comandes-basiques-de-docker-compose","title":"Comandes b\u00e0siques de Docker Compose","text":"<p>Un cop tenim l'arxiu de configuraci\u00f3 docker-compose.yml, podem utilitzar</p> <ul> <li>docker-compose up: Crea i al\u00e7a els contenidors especificats a l'arxiu de configuraci\u00f3.</li> <li>docker-compose down: Para i elimina els contenidors especificats a l'arxiu de configuraci\u00f3.</li> <li>docker-compose ps: Mostra l'estat dels contenidors especificats a l'arxiu de configuraci\u00f3.</li> <li>docker-compose logs: Mostra els logs dels contenidors especificats a l'arxiu de configuraci\u00f3.</li> <li>docker-compose exec: Executa una instrucci\u00f3 en un contenidor.</li> <li>docker-compose start: Arranca els contenidors (o el contenidor especificat)</li> <li>docker-compose stop: Para els contenidors (o el contenidor especificat) </li> <li>docker-compose restart: Reinicia els contenidors (o el contenidor especificat)   </li> <li>docker-compose build: Construeix les imatges especificades a l'arxiu de configuraci\u00f3.  </li> </ul>"},{"location":"u03/annex/#exemple-dus-de-docker-compose","title":"Exemple d'\u00fas de Docker Compose","text":"<p>Suposem que volem al\u00e7ar un entorn amb un servidor web i una base de dades MySQL/MariaDB.</p> <p>Creem un arxiu docker-compose.yml amb el seg\u00fcent contingut:</p> <pre><code>version: '3.8'\nservices:\n  webserver:\n    image: nginx:latest\n    ports:\n      - \"8080:80\"\n    volumes:\n      - ./web:/usr/share/nginx/html\n  db:\n    image: mariadb:latest\n    environment:\n      MYSQL_ROOT_PASSWORD: password\n      MYSQL_DATABASE: test\n      MYSQL_USER: user\n      MYSQL_PASSWORD: password\n    volumes:\n      - ./db:/var/lib/mysql\n</code></pre> <p>Si ara, des de la mateixa carpeta on tenim l'arxiu, fem:</p> <pre><code>docker-compose up\n</code></pre> <p>Podrem veure com se creen i s'alcen els contenidors. El servidor web estar\u00e0 disponible a l'adre\u00e7a http://localhost:8080.</p>"},{"location":"u03/annex/#escalar-serveis-amb-docker-compose","title":"Escalar serveis amb Docker Compose","text":"<p>Amb Docker Compose podem escalar serveis de forma senzilla. Per exemple, si volem tenir 3 inst\u00e0ncies del servei webserver, podem fer:</p> <pre><code>docker-compose up --scale webserver=3\n</code></pre> <p>Amb aquesta instrucci\u00f3, es crearan 3 inst\u00e0ncies del servei webserver.</p>"},{"location":"u03/annex/#exemple-dockeritzar-serveis-amb-python","title":"Exemple: dockeritzar serveis amb Python","text":"<p>En Aules teniu un arxiu anomenat api_con_dockerfile.zip que cont\u00e9 un exemple senzill de com dockeritzar un servei amb Python. Baixeu l'arxiu i descomprimiu-lo. Tindreu un fitxer docker.compose.yml amb el seg\u00fcent contingut:</p> <pre><code>version: \"3.7\"\nservices:\n\n  # API \n  api:\n    restart: always\n    container_name: api\n    build: ./folder/\n    ports:\n      - \"8010:8010\"\n    expose:\n      - \"8010\"\n    volumes:\n      - ./folder/data:/folder/data\n</code></pre> <p>El que fa el fitxer \u00e9s al\u00e7ar un contenidor amb un servei API que escolta pel port 8010. El servei est\u00e0 definit en un Dockerfile que es troba a la carpeta folder. El contingut del fitxer e\u015b el seg\u00fcent:</p> <pre><code>FROM python:3.9\n\nWORKDIR /folder\n\nADD . /folder\n\nRUN pip install -r requirements.txt\n\nEXPOSE 8010\n\nCMD [\"python\", \"-u\", \"/folder/script.py\"]\n\nLABEL MAINTAINER jclemente@prodevelop.es\n</code></pre> <p>El Dockerfile crea un contenidor amb Python 3.9, copia el contingut de la carpeta folder al contenidor, instal\u00b7la les depend\u00e8ncies del projecte, exposa el port 8010 i executa el script script.py que es troba a la carpeta folder. L'arxiu requirements.txt cont\u00e9 les depend\u00e8ncies del projecte. L'script script.py crea una API simple que escolta el port 8010 i que ofereix dos serveis: un GET en /getList i un POST en /postExample que, si li passem un par\u00e0metre <code>name</code>, el mostrar\u00e0 per pantalla. </p> <p>Alceu el contenidor i comproveu que els serveis funcionen correctament. El servei GET el podeu provar directament des del navegador. Per a provar el servei POST, podeu fer servir l'eina curl. Per exemple:</p> <pre><code>curl -X POST --header 'Content-Type:application/json' -d '{\"name\":\"Fidel\"}' http://localhost:8010/postExample \n</code></pre> <p>o b\u00e9 utilitzar una eina com Postman o Hoppscotch.</p> <p>En Windows \u00e9s possible que no funcione amb localhost. En aquest cas, podeu provar amb la IP de la m\u00e0quina o b\u00e9 amb host.docker.internal en lloc de localhost.</p>"},{"location":"u03/annex/#exemple-dockeritzar-node-red","title":"Exemple: dockeritzar Node-Red","text":"<p>Un altre exemple senzill \u00e9s el de dockeritzar Node-Red. Node-Red \u00e9s una eina de programaci\u00f3 visual per a IoT. Per a dockeritzar Node-Red, podem fer servir la imatge oficial de Node-Red.</p> <p>Creeu un arxiu docker-compose.yml amb el seg\u00fcent contingut:</p> <pre><code>services:\n  node-red:\n    image: nodered/node-red:latest\n    container_name: nodeRED\n    restart: unless-stopped\n    networks:\n      - net\n    ports:\n      - \"1881:1880\"\n    volumes:\n      - \"./node-red:/data\"\n\nnetworks:\n  net:\n    driver: bridge\n</code></pre> <p>Amb aquest arxiu, al\u00e7arem un contenidor amb Node-Red que escoltar\u00e0 pel port 1880. La carpeta data es mapejar\u00e0 amb la carpeta data del contenidor, de forma que les dades de Node-Red es guardaran en la carpeta data de la m\u00e0quina host. El port 1880 del contenidor se mapeja amb el port 1881 del sistema amfitri\u00f3. </p> <p>Podeu provar a accedir a Node-Red a trav\u00e9s del navegador a l'adre\u00e7a http://localhost:1881.</p> <p>En la seg\u00fcent unitat veurem a fons com utilitzar Node-Red.</p>"},{"location":"u04/","title":"Node-RED","text":"<p>Node-RED es una eina de programaci\u00f3 visual (de les anomenades \"no-Code\", encara que en este cas seria millor \"low-Code\") que permet connectar dispositius de hardware, APIs i serveis en l\u00ednia. Es basa en la programaci\u00f3 amb blocs, on cada bloc realitza una tasca espec\u00edfica. Aquests blocs s\u00f3n anomenats nodes i es poden connectar entre ells per crear un flux de dades. \u00c9s open-source i est\u00e0 desenvolupat inicialment per IBM.</p> <p></p> <p>Informaci\u00f3 en GitHub: Node-RED en GitHub</p> <p>P\u00e0gina oficial: P\u00e0gina oficial de Node-RED</p> <p>Documentaci\u00f3: Documentaci\u00f3 de Node-RED</p>"},{"location":"u04/#installacio-en-linux","title":"Instal\u00b7laci\u00f3 en Linux","text":"<p>Anem a veure els passos per instal\u00b7lar Node-RED en un sistema Linux. De totes formes en principi anem a treballar amb un Node-RED en Docker per evitar problemes de compatibilitat, versions, etc.</p> <p>Per a instal\u00b7lar Node-RED, primer cal tenir instal\u00b7lat Node.js. Si no el tenim instal\u00b7lat, podem descarregar-lo des de la p\u00e0gina oficial: Descarregar Node.js</p> <p>Podem comprobar si tenim NodeJS instal\u00b7lat, aix\u00ed com el gestor de paquets npm, amb les seg\u00fcents comandes:</p> <pre><code>node -v\nnpm -v\n</code></pre> <p>Una vegada tenim instal\u00b7lat node i npm, podem instal\u00b7lar Node-RED amb la seg\u00fcent comanda:</p> <pre><code>sudo npm install -g --unsafe-perm node-red\n</code></pre> <p>Per a executar Node-RED, simplement cal executar la comanda:</p> <pre><code>node-red\n</code></pre>"},{"location":"u04/#installacio-en-windows","title":"Instal\u00b7laci\u00f3 en Windows","text":"<p>Podeu trobar les instruccions per instal\u00b7lar Node-RED en Windows en la p\u00e0gina oficial de l'aplicaci\u00f3.</p> <p>Node-RED en Windows</p>"},{"location":"u04/#installacio-en-docker","title":"Instal\u00b7laci\u00f3 en Docker","text":"<p>Per a instal\u00b7lar Node-RED en un contenidor Docker, tenim 2 opcions:</p> <ul> <li>directament:</li> </ul> <pre><code>docker run -it -p 1880:1880 -v node-red-data:/data --name nodeRED nodered/node-red\n</code></pre> <ul> <li>utilitzant <code>docker-compose</code> (recomanable per a projectes una miqueta m\u00e9s complexos), crearem un arxiu <code>docker-compose.yml</code> amb el seg\u00fcent contingut:</li> </ul> <pre><code>services:\n   node-red:\n      image: nodered/node-red:latest\n      container_name: nodeRED\n      restart: unless-stopped\n      networks:\n         - net\n      ports:\n         - \"1881:1880\"\n      volumes:\n         - \"./node-red-data:/data\"\n\nnetworks:\n   net:\n      driver: bridge\n</code></pre> <p>(per evitar problemes de tabulacions, espais, etc. quan copieu i pegueu, teniu l'arxiu <code>docker-compose.yml</code> pujat a Aules)</p> <p>Ara, com ja sabeu, per crear i al\u00e7ar el contenidor haurem de fer, la primera vegada i en la mateixa carpeta on tenim el <code>docker-compose.yml</code>:</p> <pre><code>docker-compose up -d\n</code></pre> <p>A partir d'ah\u00ed, podem parar el contenidor i tornar-lo a iniciar amb <code>docker start nodeRED</code> i <code>docker stop nodeRED</code>.</p>"},{"location":"u04/#interficie-de-node-red","title":"Interf\u00edcie de Node-RED","text":"<p>Una vegada feta la instal\u00b7laci\u00f3, per comprovar que tenim Node-RED funcionant intentarem accedir amb el navegador al port que hem mapejat, en este cas el 1881:</p> <p>En Linux:</p> <pre><code>http://localhost:1881\n</code></pre> <p>o tamb\u00e9:</p> <pre><code>http://172.17.0.1:1881\n</code></pre> <p>En Windows:</p> <pre><code>http://&lt;IP_del_PC&gt;:1881\n</code></pre> <p>o tamb\u00e9:</p> <pre><code>http://localhost:1881\n</code></pre> <p>i si no funciona amb localhost en Windows, recordeu que podeu provar:</p> <pre><code>http://host.docker.internal:1881\n</code></pre> <p>Si tot ha anat b\u00e9, ens hauria de mostrar la interf\u00edcie de Node-RED.</p> <p></p> <p>Si Node-RED no arranca i ens mostra errors de permisos, mireu amb quin usuari ha creat la carpeta compartida. Potser ho ha fet com a root, i despr\u00e9s el vostre usuari no t\u00e9 permisos per a escriure en ella. En aquest cas, caldr\u00e0 canviar els permisos de la carpeta o modificar el nostre fitxer <code>docker-compose.yml</code> perqu\u00e8 l'usuari siga el nostre i no root:</p> <p><code>yaml    services:       node-red:          image: nodered/node-red:latest          container_name: nodeRED          restart: unless-stopped          networks:             - net          ports:             - \"1881:1880\"          volumes:             - \"./node-red-data:/data\"          user: \"1000:1000\"</code></p> <p>La l\u00ednia <code>user: \"1000:1000\"</code> significa que l'usuari que crear\u00e0 la carpeta compartida ser\u00e0 el que tinga l'ID 1000 i el grup tamb\u00e9 1000. Per a saber quin \u00e9s el vostre ID d'usuari, podeu fer <code>id -u</code> i per al grup <code>id -g</code>.</p>"},{"location":"u04/#components-de-node-red","title":"Components de Node-RED","text":"<p>Node-RED es basa en 3 components principals:</p> <ul> <li>Flows: S\u00f3n els programes que creem amb Node-RED. Estan formats per nodes connectats entre ells.</li> <li>Nodes: S\u00f3n els blocs que realitzen tasques espec\u00edfiques. Podem trobar nodes per interactuar amb dispositius de hardware, per connectar-se a serveis en l\u00ednia, per realitzar c\u00e0lculs, per afegir funcions en JavaScript, per connectar a bases de dades, etc.</li> <li>Dashboard: \u00c9s un node especial que ens permet crear una interf\u00edcie web per a controlar els nostres programes.</li> </ul> <p>En la pantalla principal podem veure 3 seccions:</p> <ul> <li>a la part esquerra, una paleta on trobem tots els nodes disponibles per a ser utilitzats.</li> <li>a la part central, la zona de treball on podem crear els nostres programes. \u00c9s l'anomenat Flow Editor, i all\u00ed crearem els nostres fluxes.</li> <li>a la part dreta, tenim la informaci\u00f3 dels nodes seleccionats, aix\u00ed com la consola de debug i altres opcions de configuraci\u00f3.</li> </ul>"},{"location":"u04/#nodes","title":"Nodes","text":"<p>Un node es un bloc b\u00e0sic que fa una tasca espec\u00edfica i, moltes vegades, predeterminada. Els nodes se connecten entre ells per a crear un flux de dades. Com hem comentat, els nodes disponibles podem trobar-los en la paleta de la part esquerra de la interf\u00edcie. De totes formes, m\u00e9s endavant veurem que podem instal\u00b7lar m\u00e9s nodes per a ampliar les funcionalitats de Node-RED.</p> <p>Els nodes poden posar-se en funcionament per algun event extern, o perqu\u00e8 reben un missatge d'un altre node. A la seua vegada, poden generar un nou missatge que ser\u00e0 enviat a un altre node. Un node pot tindre un port d'entrada i un o m\u00e9s ports d'eixida. </p> <p>En general crearem els nodes arrosegant-los des de la paleta fins a la zona de treball, i connectant-los entre ells amb les fletxes que apareixen quan arrossegem una fletxa des d'un port d'eixida a un port d'entrada.</p> <p>Per exemple, anem a fer un flux amb un node de tipus \"inject\", i un altre de tipus \"debug\". Despr\u00e9s els connectarem entre ells. </p> <p></p> <p>Si se fixeu, veureu un xicotet punt blau en cada node. Aix\u00f2 vol dir que el flux no est\u00e0 guardat (desplegat). Per a guardar el flux, cal fer clic en el bot\u00f3 de la part superior dreta, on diu \"Deploy\" o \"Instanciar\". Veureu que els punts blaus desapareixen.</p> <p>Alguns nodes, com el de tipus \"inject\", tenen un bot\u00f3 a l'esquerra que serveix per posar-lo en marxa si no est\u00e0 associat a cap event extern o a cap altre node. En el nostre exemple, si fem clic en el bot\u00f3 de l'inject, se posa en marxa el flux. En principi no veurem que haja passat res, per\u00f2 si en la part de l'esquerra anem al bot\u00f3 de debug i fem clic, veurem el resultat del flux. En este cas, un n\u00famero que representa el timestamp del moment en qu\u00e8 s'ha executat el flux.</p> <p></p>"},{"location":"u04/#missatges-i-payload","title":"Missatges i Payload","text":"<p>Els nodes de Node-RED es comuniquen entre ells enviant missatges. Un missatge est\u00e0 compost per 3 parts principals:</p> <ul> <li>msg.payload: \u00c9s la informaci\u00f3 continguda en el missatge</li> <li>msg.topic: \u00c9s el tema del missatge</li> <li>msg.any other property: Podem afegir altres propietats al missatge</li> </ul> <p>El payload \u00e9s la informaci\u00f3 principal que es transmet entre els nodes. Per exemple, si tenim un node que llegeix un sensor de temperatura, el valor de la temperatura seria el payload. El topic \u00e9s una cadena de text que ens permet classificar els missatges. Per exemple, si tenim un node que llegeix un sensor de temperatura, el topic podria ser \"temperatura\".</p> <p>Si fem clic en el node d'injecci\u00f3, veurem que podem modificar el tipus de missatge que envia. Per defecte, envia un timestamp amb la data i hora actuals, que e\u015b el n\u00famero que ens mostra al fer el debug. Per\u00f2 podem canviar-ho per a que envie un missatge de tipus string, un n\u00famero, un boole\u00e0, etc. modificant el camp \"Payload\" del missatge.</p> <p></p> <p>Si fem  clic en el node de debug, veurem que t\u00e9 una propietat Salida que per defecte mostrar\u00e0 el payload que li passa el node anterior.</p> <p></p> <p>Si en lloc de mostrar el timestamp tal qual volem mostrar la data i hora en format llegible, podem afegir un node de tipus function entre l'inject i el debug. Aquest node ens permetr\u00e0 modificar el missatge abans de passar-lo al node de debug. Per exemple, podem utilitzar el seg\u00fcent codi per a convertir el timestamp en una data i hora llegible:</p> <pre><code>var date = new Date(msg.payload);\nmsg.payload = date.toString();\nreturn msg;\n</code></pre> <p>Si torneu a fer el deploy i executeu el flux, haurieu de veure la data en un format m\u00e9s llegible.</p> <p></p>"},{"location":"u04/#importar-i-exportar-fluxos","title":"Importar i exportar fluxos","text":"<p>Node-RED ens permet importar i exportar els nostres fluxos. Aix\u00f2 ens permet compartir els nostres programes amb altres persones, aix\u00ed com fer c\u00f2pies de seguretat dels nostres programes. Els fluxos s\u00f3n exportats en format JSON, i podem importar-los des de la interf\u00edcie de Node-RED.</p> <p>Per a exportar un flux, cal fer clic en el bot\u00f3 de la part superior dreta, i seleccionar Exportar. Aix\u00f2 ens mostrar\u00e0 una finestra on podem seleccionar qu\u00e8 volem exportar. Podem exportar tot el flux, nom\u00e9s la selecci\u00f3 actual, o nom\u00e9s un node.</p> <p></p> <p>Tamb\u00e9 podem exportar un flux fent clic amb el bot\u00f3 dret del ratol\u00ed sobre el flux, el grup o el node que volem exportar, i seleccionant Exportar.</p> <p></p> <p>Per a importar un flux pr\u00e8viament guardat en format JSON, fem clic en el men\u00fa de la part superior dreta i seleccionem l'opci\u00f3 Importar. Haurem de seleccionar el fitxer JSON que cont\u00e9 el flux que volem importar i ens crear\u00e0 un flux nou en la zona de treball amb els nodes importats.</p> <p></p>"},{"location":"u04/#nodes-addicionals","title":"Nodes addicionals","text":"<p>Node-RED permet instal\u00b7lar nodes addicionals per a ampliar les funcionalitats de l'aplicaci\u00f3. Per a fer-ho, cal anar a la paleta de la part esquerra de la interf\u00edcie i fer clic en el bot\u00f3 de la part superior dreta, on diu Manage palette o Administrar paleta. Aix\u00f2 ens obrir\u00e0 una finestra on podem veure els nodes que tenim instal\u00b7lats (pestanya Nodos), aix\u00ed com els que podem instal\u00b7lar (pestanya Instalar). Per a instal\u00b7lar un node, cal anar a la pestanya Install o Instalar i buscar el node que volem instal\u00b7lar. Un cop trobat, fem clic en el bot\u00f3 Install i el node ser\u00e0 instal\u00b7lat. A partir d'ara, el node estar\u00e0 disponible en la paleta de nodes que tenim a la part esquerra de la pantalla de treball.</p> <p></p>"},{"location":"u04/#exercici-01","title":"Exercici 01","text":"<p>Intenteu fer un \"Hola, mundo!\". Recordeu que per veure el missatge haureu de tindre un node de debug, fer clic en el bot\u00f3 de debug que teniu a la part dreta de la pantalla, i llan\u00e7ar el primer node manualment. </p> <p>Modifiqueu el flux anterior per a que mostre tamb\u00e9, a m\u00e9s del \"Hola, mundo!\" la data actual. </p>"},{"location":"u04/#exercici-02","title":"Exercici 02","text":"<ul> <li> <p>Descarregueu el flux Basic nodes operations que trobareu a Aules i importeu-lo al vostre NodeRED.</p> </li> <li> <p>Intenteu fer el desplegament del flux. Vos donar\u00e0 un error perqu\u00e8 el flux importat inclou nodes que no teniu instal\u00b7lats.</p> </li> <li> <p>Intenteu instal\u00b7lar els nodes que falten i torneu a fer el desplegament a veure si ja no dona error.</p> </li> </ul>"},{"location":"u04/nodered-avan%C3%A7at/","title":"Node-RED avan\u00e7at","text":"<p>En esta part final de la unitat anem a veure algunes caracter\u00edstiques m\u00e9s avan\u00e7ades de Node-RED.</p>"},{"location":"u04/nodered-avan%C3%A7at/#altres-nodes-comuns","title":"Altres nodes comuns","text":"<p>Anem a veure alguns nodes de la secci\u00f3 \"Com\u00fan\" que no hav\u00edem tractat fins ara.</p>"},{"location":"u04/nodered-avan%C3%A7at/#complete","title":"Complete","text":"<p>El node <code>complete</code> permet marcar un missatge com a complet. Aix\u00f2 pot ser \u00fatil per indicar que s'ha acabat de processar un missatge, o per indicar que s'ha arribat al final d'una seq\u00fc\u00e8ncia de missatges.</p> <p>Com sabeu, ni ha nodes que no reaccionen a l'entrada de missatges fins que no reben un missatge <code>complete</code>. Aix\u00f2 \u00e9s \u00fatil per a processos que necessiten saber quan han acabat de rebre missatges. Ah\u00ed teniu una possible utilitat de <code>complete</code>. </p>"},{"location":"u04/nodered-avan%C3%A7at/#catch","title":"Catch","text":"<p>El node <code>catch</code> permet capturar errors que es produeixen en el flux (en la mateixa pestanya). Aix\u00f2 pot ser \u00fatil per gestionar errors, o per enviar missatges d'error a un node <code>debug</code> o a un node <code>email</code>.</p>"},{"location":"u04/nodered-avan%C3%A7at/#status","title":"Status","text":"<p>El node <code>status</code> permet mostrar l'estat d'altres nodes que pertanyen al mateix flux (en la mateixa pestanya) en la interf\u00edcie de Node-RED. Tamb\u00e9 podem saber quin node ha informat del seu estat, i quin estat ha informat. Una possible utilitat \u00e9s mostrar l'estat d'un sensor en la interf\u00edcie de Node-RED.</p>"},{"location":"u04/nodered-avan%C3%A7at/#comment","title":"Comment","text":"<p>El node <code>comment</code> permet afegir comentaris al flux. No generen cap acci\u00f3.</p>"},{"location":"u04/nodered-avan%C3%A7at/#link-in-i-link-out","title":"Link in i Link out","text":"<p>Els nodes <code>link in</code> i <code>link out</code> permeten connectar dos parts del flux que estan separades. Aix\u00f2 pot ser \u00fatil per connectar dos parts del flux que estan lluny l'una de l'altra, o per connectar dos fluxos diferents (en diferents pestanyes).</p> <p>Si hi ha m\u00e9s d'un node <code>link in</code> amb el mateix nom, tots rebran el missatge. Aix\u00f2 pot ser \u00fatil per connectar un node <code>link out</code> a m\u00e9s d'un node <code>link in</code>. Si volem separar els diferents fluxos, donarem diferents noms a cada parella <code>link in</code>-<code>link out</code>.</p>"},{"location":"u04/nodered-avan%C3%A7at/#link-call","title":"Link call","text":"<p>El node <code>link call</code> permet cridar un node <code>link in</code> des d'un altre node. Aix\u00f2 pot ser \u00fatil per cridar una part del flux des d'una altra part del mateix flux, o des d'un altre flux.</p>"},{"location":"u04/nodered-avan%C3%A7at/#altres-nodes-de-funcio","title":"Altres nodes de funci\u00f3","text":"<p>A m\u00e9s dels nodes de funci\u00f3 que ja hem vist, \u00e9s \u00fatil con\u00e8ixer els seg\u00fcents:</p>"},{"location":"u04/nodered-avan%C3%A7at/#template","title":"Template","text":"<p>El node <code>template</code> permet crear missatges a partir de plantilles. Aix\u00f2 ens permet crear missatges amb un format concret, o a partir de variables. Amb el node <code>template</code> crearem una plantilla que despr\u00e9s se completar\u00e0 amb els valors que li arriben per <code>payload</code>. </p> <p>Exemple: podem crear un node <code>template</code> amb el contingut <code>La temperatura actual \u00e9s {{payload}}\u00baC</code>, i connectar-lo a un node <code>debug</code>. Quan li arribe un missatge amb un valor de temperatura, el node <code>template</code> substituir\u00e0 <code>{{payload}}</code> pel valor de temperatura, i el node <code>debug</code> mostrar\u00e0 el missatge <code>La temperatura actual \u00e9s 25\u00baC</code>.</p> <p></p>"},{"location":"u04/nodered-avan%C3%A7at/#delay","title":"Delay","text":"<p>El node <code>delay</code> permet retardar l'enviament d'un missatge. Aix\u00f2 pot ser \u00fatil per esperar un temps determinat abans d'enviar un missatge, o per evitar enviar missatges massa r\u00e0pidament. Hi ha moltes opcions que podem configurar, aix\u00ed que recomanem que consulteu l'ajuda oficial de Node-RED. </p>"},{"location":"u04/nodered-avan%C3%A7at/#wait-paths","title":"Wait-paths","text":"<p>El node <code>wait-paths</code> permet esperar fins que arriben tots els missatges d'un grup, emesos per diferents fonts, per generar un \u00fanic missatge d'eixida. Aix\u00f2 pot ser \u00fatil per esperar fins que arriben totes les dades d'un grup de sensors, per exemple.</p> <p>Els missatges entrants han de tindre en la propietat <code>paths</code> una clau que l'identifica i un valor que s'envia. El node <code>wait-paths</code> espera fins que arriben tots els missatges amb la mateixa clau o amb les claus especificades, i quan arriben tots envia un \u00fanic missatge amb totes les claus i valors.</p> <p>Podem fer un exemple utilitzant el node <code>delay</code> per fer que els missatges arriben en moments diferents, i nodes <code>change</code> per afegir la clau <code>paths</code> als missatges. En l'exemple seg\u00fcent un <code>inject</code> envia una senyal que passa directament a un <code>change</code> que crea un path, per un costat, i per un altre costat la mateixa senyal s'envia a un altre <code>change</code> que estableix un altre path amb altres valors, per\u00f2 passant pr\u00e8viament per un <code>delay</code>. Aix\u00ed podem veure que fins que els dos paths especificats no arriben, el node <code>debug</code> no mostra res. </p> <p></p> <p></p> <p></p> <p></p> <p>L'exemple el teniu en el flux importat <code>Basic node &amp; operations</code> i per tant podeu provar el seu funcionament.</p>"},{"location":"u04/nodered-avan%C3%A7at/#data-generator","title":"Data generator","text":"<p>El node <code>data generator</code> permet generar dades aleat\u00f2ries. Aix\u00f2 pot ser \u00fatil per provar el flux amb dades fict\u00edcies, o per generar dades per a un node <code>chart</code>. L'advantatge d'aquest node respecte a <code>random</code> \u00e9s que podem generar dades de diferents tipus, com ara noms, text, dates, etc., fins i tot amb un significat concret (noms inventats, poblacions, pa\u00efsos, etc.)</p> <p>Per exemple, en un node <code>data generator</code> podem escriure la seg\u00fcent plantilla com a valor del <code>payload</code>:</p> <pre><code>{\n    \"name\": \"{{firstName}} {{lastName}}\",\n    \"work\": \"{{company}}\",\n    \"email\": \"{{email}}\",\n    \"age\": \"{{random.number(100)}}\",\n    \"city\": \"{{address.city}}\",\n    \"country\": \"{{address.country}}\"\n}\n</code></pre> <p>Aix\u00f2 generar\u00e0 un missatge amb un nom, una empresa, un correu electr\u00f2nic, una edat, una ciutat i un pa\u00eds aleatoris. Podeu veure el contingut del node <code>data generator</code> i la seua eixida en les seg\u00fcents imatges. </p> <p></p> <p></p>"},{"location":"u04/nodered-avan%C3%A7at/#nodes-analitzadors","title":"Nodes analitzadors","text":"<p>Anem a veure alguns nodes de la secci\u00f3 \"Analysers\" que poden ser \u00fatils per analitzar dades.</p>"},{"location":"u04/nodered-avan%C3%A7at/#csv","title":"CSV","text":"<p>Converteix de cadenes CSV a objectes JavaScript, i viceversa.</p>"},{"location":"u04/nodered-avan%C3%A7at/#json","title":"JSON","text":"<p>Converteix de cadenes JSON a objectes JavaScript, i viceversa.</p>"},{"location":"u04/nodered-avan%C3%A7at/#html","title":"HTML","text":"<p>Converteix de cadenes HTML a objectes JavaScript, i viceversa.</p>"},{"location":"u04/nodered-avan%C3%A7at/#xml","title":"XML","text":"<p>Converteix de cadenes XML a objectes JavaScript, i viceversa.</p>"},{"location":"u04/nodered-avan%C3%A7at/#yaml","title":"YAML","text":"<p>Converteix de cadenes YAML a objectes JavaScript, i viceversa.</p> <p>Podeu fer proves redirigint un node <code>inject</code> a un node <code>csv</code> amb un valor com <code>1,2,3,4,5</code>, per exemple, i veure com el converteix en un objecte JavaScript. Tamb\u00e9 podeu crear una plantilla en format JSON i passar-la a un node <code>json</code> per veure com la converteix en un objecte JavaScript. Al rev\u00e9s tamb\u00e9 funciona. </p> <p>En l'exemple del <code>data generator</code> que hem vist abans, podem veure que se genera un objecte JavaScript que se mostra directament en un <code>debug</code>, i per altra banda filtrem l'objecte a trav\u00e9s d'un node <code>json</code> abans de passar-lo a l'altre <code>debug</code>. Aix\u00ed, mostrem per una part l'objecte JavaScript original, i per altra part la conversi\u00f3 a json.</p> <p></p> <p></p> <p>En este moment podeu intentar fer l'exercici 1 que trobareu al final del document.</p>"},{"location":"u04/nodered-avan%C3%A7at/#arrancar-i-parar-fluxos-amb-variables-de-flux","title":"Arrancar i parar fluxos amb variables de flux","text":"<p>Quan vam veure com crear variables dins d'un missatge, coment\u00e0rem tamb\u00e9 que se poden crear variables de flux. Eixes variables s\u00f3n visibles per tot el flux, i poden ser utilitzades, entre altres coses, per controlar l'execuci\u00f3 del flux.</p> <p>Una forma t\u00edpica de fer-ho \u00e9s utilitzar un node <code>inject</code> per enviar un missatge amb valor <code>true</code>, i un altre que envie un missatge <code>false</code>. Els dos nodes <code>inject</code> envien el seu valor a un node <code>change</code> que el llegir\u00e0 i ser\u00e0 el que canviar\u00e0 el valor de la variable de flux. </p> <p></p> <p>Despr\u00e9s, en un altre flux de dades dins del mateix grup, podem utilitzar un node <code>switch</code> per preguntar si la variable de flux \u00e9s <code>true</code> o <code>false</code>, i permetre que continue el flux o no. Podem fer que si la variable \u00e9s <code>true</code> el flux continue per l'eixida 1 del <code>switch</code>, i que si \u00e9s <code>false</code> no continue per cap eixida. </p> <p></p> <p>En este moment podeu intentar fer l'exercici 2 que trobareu al final del document.</p>"},{"location":"u04/nodered-avan%C3%A7at/#nodes-de-xarxa","title":"Nodes de xarxa","text":"<p>Anem a veure alguns nodes relacionats amb la comunicaci\u00f3 amb altres dispositus o serveis. </p>"},{"location":"u04/nodered-avan%C3%A7at/#http-request","title":"HTTP request","text":"<p>El node <code>http request</code> permet fer peticions HTTP a altres servidors. Aix\u00f2 pot ser \u00fatil per obtenir dades d'una API, per enviar dades a un servidor (method PUT, POST), o per rebre dades d'un servidor (GET). Tamb\u00e9, amb el m\u00e8tode DELETE, per eliminar dades. </p> <p>Per a que funcione, hem d'especificar la URL del servidor, el m\u00e8tode HTTP (GET, POST, PUT, DELETE), i opcionalment les dades a enviar. Podem connectar-nos a endpoints creats per nosaltres amb Node-RED, o a qualsevol altre servidor que tinga una API HTTP.</p> <p>Per exemple, hi ha una API que ens permet obtenir les coordenades de la ISS (Estaci\u00f3 Espacial Internacional). Podem utilitzar el node <code>http request</code> per obtenir les coordenades de la ISS, i despr\u00e9s utilitzar-les per mostrar-les en un node <code>debug</code> o en un node <code>ui_text</code>.</p> <p>L'adre\u00e7a \u00e9s <code>http://api.open-notify.org/iss-now.json</code>.</p> <p>Aix\u00ed, el node <code>http request</code> quedaria aix\u00ed:</p> <p></p> <p>Podem passar el response a trav\u00e9s d'un filtre JSON (converteix el JSON rebut a un objecte JavaScript) i el mostrem amb un node <code>debug</code>.</p> <p></p> <p>Tamb\u00e9 podr\u00edem mostrar les dades en forma gr\u00e0fica, per\u00f2 aix\u00f2 ho veurem m\u00e9s endavant.</p>"},{"location":"u04/nodered-avan%C3%A7at/#http-response","title":"HTTP response","text":"<p>El node <code>http response</code> permet enviar respostes HTTP a clients que han fet una petici\u00f3 HTTP. Aix\u00f2 pot ser \u00fatil per crear una API HTTP amb Node-RED, o per respondre a peticions HTTP d'altres servidors.</p> <p>Per enviar peticions a un node <code>http_response</code> necessitem un node <code>http in</code> que ser\u00e0 el nostre endpoint al que li podrem enviar peticions des del navegador, Postman, curl, o similar.</p>"},{"location":"u04/nodered-avan%C3%A7at/#http-in","title":"HTTP in","text":"<p>El node <code>http in</code> permet crear un endpoint HTTP al que es poden fer peticions HTTP. Aix\u00ed podem crear la nostra API amb Node-RED. </p> <p>Anem a veure un exemple senzill amb <code>http in</code> i <code>http response</code>.</p> <p>Creem un node <code>http in</code> amb la seg\u00fcent configuraci\u00f3:</p> <ul> <li>Method: GET</li> <li>URL: /test</li> </ul> <p>Ara connectem el node <code>http in</code> a un node <code>template</code> amb contingut HTML. En el <code>payload</code> podem posar, per exemple:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;&lt;title&gt;Prova Node-RED&lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Hola! Benvingut a la meua API generada amb Node-RED&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Finalment, connectem el node <code>template</code> a un node <code>http response</code> que ser\u00e0 el que tornar\u00e0 la resposta al client. En el node <code>http response</code> no cal configurar res, ja que la resposta ja est\u00e0 configurada en el node <code>template</code>, per\u00f2 podem afegir un codi d'estat i unes cap\u00e7aleres, si volem. </p> <p>El resultat se veuria aix\u00ed:</p> <p></p> <p>Fixeu-vos que, a difer\u00e8ncia del node <code>inject</code>, no podem llan\u00e7ar manualment el node <code>http in</code>. Ho hem de fer des d'un navegador o un programa tipus Postman, curl o similar. Recordeu que li hav\u00edem donat el nom <code>test</code> al endpoint. Aix\u00ed, hem d'accedir a l'adre\u00e7a <code>http://localhost:1881/test</code> des del navegador i veurem qu\u00e8 ens torna el node <code>http response</code>.</p> <p>Haur\u00edem de veure:</p> <p></p>"},{"location":"u04/nodered-avan%C3%A7at/#nodes-darxius","title":"Nodes d'arxius","text":"<p>Anem a veure alguns nodes de la secci\u00f3 <code>almacenamiento</code> que poden ser \u00fatils per llegir i escriure arxius.</p>"},{"location":"u04/nodered-avan%C3%A7at/#escribir-archivo","title":"Escribir archivo","text":"<p>El node <code>escribir archivo</code> permet escriure dades en un arxiu. Podem afegir informaci\u00f3 al final de l'arxiu, o sobreescriure totalment el seu contingut. </p> <p></p>"},{"location":"u04/nodered-avan%C3%A7at/#leer-archivo","title":"Leer archivo","text":"<p>El node <code>leer archivo</code> permet llegir dades d'un arxiu. Se pot tornar tot el contingut de l'arxiu en una cadena, un missatge diferent per cada l\u00ednia de l'arxiu, o b\u00e9 un objecte (o un stream d'objectes) de tipus <code>Buffer</code>.</p> <p></p> <p>Pots intentar fer una prova generant un conjunt de dades aleat\u00f2ries, guardant-les en un arxiu, i despr\u00e9s llegint-lo i mostrant-lo en un node <code>debug</code>.</p> <p>Ara ja pots fer la resta d'exercicis que trobar\u00e0s a continuaci\u00f3.</p>"},{"location":"u04/nodered-avan%C3%A7at/#exercicis","title":"Exercicis","text":""},{"location":"u04/nodered-avan%C3%A7at/#exercici-01","title":"Exercici 01","text":"<p>Imaginem que tenim 2 estacions meteorol\u00f2giques que comuniquen dades de manera independent en un mateix instant de temps. Volem guardar les dades de les dues estacions en un sol document JSON i mostrar-lo amb un node <code>debug</code></p> <p>La primera estaci\u00f3 envia les seg\u00fcents dades:</p> <ul> <li>NO, NO2, NOx, SO2, Humitat, Temperatura, Velocitat del vent, Direcci\u00f3 del vent.</li> </ul> <p>La segona estaci\u00f3 envia nom\u00e9s dues dades: </p> <ul> <li>CO i CO2. </li> </ul> <p>Les dades seran generades aleat\u00f2riament amb el node <code>data generator</code>. Tots els valors poden tindre decimals i un valor m\u00ednim de 0 i un m\u00e0xim de 50. Cada estaci\u00f3 enviar\u00e1 valors nous a intervals de 0.5 segons.</p> <p>Tots dos conjunts tindran un camp <code>Data</code> que ser\u00e0 l'input del payload i que haurem de construir a partir del <code>timestamp</code> del injector .</p> <p>Hem de juntar tots dos conjunts de dades en un sol utilitzant el node <code>join</code> i aplicant tot el que hem vist.</p>"},{"location":"u04/nodered-avan%C3%A7at/#exercici-02","title":"Exercici 02","text":"<p>Fent \u00fas de les variables de flux, modifica l'exercici anterior per poder iniciar, parar o reiniciar la injecci\u00f3 de dades. </p> <ul> <li> <p>Necessitarem tindre 2 fluxes de dades en un mateix grup.</p> </li> <li> <p>El primer flux de dades tindria els nodes <code>inject</code> per activar o desactivar el segon flux.</p> </li> <li> <p>El segon flux de dades seria el mateix que l'exercici anterior.</p> </li> <li> <p>En el primer flux de dades podem utilitzar un node <code>inject</code> per enviar un missatge <code>true</code> i un altre per enviar un missatge <code>false</code>. El valor s'hauria de guardar en una variable de flux.</p> </li> <li> <p>En el segon flux de dades pots utilizar el node <code>switch</code> per preguntar si la variable de flux \u00e9s <code>true</code> o <code>false</code> i permetre que continue el flux o no.</p> </li> </ul>"},{"location":"u04/nodered-avan%C3%A7at/#exercici-03","title":"Exercici 03","text":"<p>Instal\u00b7la el node <code>flightradar24</code> i busca informaci\u00f3 a veure com funciona. Podem demanar informaci\u00f3 dels vols que estan passant per la nostra zona? Com? Intenta fer-ho. Envia l'eixida a un node <code>debug</code> que mostre el resultat, i analitza les dades rebudes. </p>"},{"location":"u04/nodered-avan%C3%A7at/#exercici-04","title":"Exercici 04","text":"<p>Modifica el flux anterior per guardar en un arxiu <code>vols.txt</code> l'aeroport d'origen, el de dest\u00ed, el n\u00famero de vol, l'altitud i la velocitat.</p>"},{"location":"u04/nodered-dashboards/","title":"Node-RED Dashboards","text":"<p>En aquesta unitat veurem com crear interf\u00edcies gr\u00e0fiques amb Node-RED. Aix\u00f2 ens permetr\u00e0 crear panells de control per a dispositius IoT, per a sistemes de monitoratge, per a sistemes de control, etc.</p>"},{"location":"u04/nodered-dashboards/#introduccio","title":"Introducci\u00f3","text":"<p>Un dashboard \u00e9s una interf\u00edcie gr\u00e0fica que ens permet interactuar amb una aplicaci\u00f3 o simplement mostrar elements gr\u00e0fics. Aquesta interf\u00edcie pot ser molt senzilla o m\u00e9s complexa. En el cas de Node-RED, els dashboards ens permeten crear interf\u00edcies gr\u00e0fiques per a les nostres aplicacions per a interactuar amb elles de forma m\u00e9s visual, crear gr\u00e0fics o veure estad\u00edstiques o dades en temps real.</p>"},{"location":"u04/nodered-dashboards/#installacio-dels-nodes-de-node-red-dashboard","title":"Instal\u00b7laci\u00f3 dels nodes de Node-RED Dashboard","text":"<p>Per a poder utilitzar els dashboards de Node-RED, primer cal instal\u00b7lar els nodes necessaris. Per a fer-ho, anem a la pestanya de configuraci\u00f3 de Node-RED i seleccionem la opci\u00f3 de Administrar paleta o Manage palette. A la finestra que ens apareix, busquem el paquet node-red-dashboard i el seleccionem per a instal\u00b7lar-lo.</p> <p></p> <p>Una vegada feu clic en el bot\u00f3 d'instal\u00b7lar, es descarregar\u00e0 i instal\u00b7lar\u00e0 el paquet amb els nodes necessaris per a poder crear dashboards.A la part esquerra vos hauria d'apar\u00e8ixer una nova secci\u00f3 de nodes anomenada dashboard.</p> <p></p>"},{"location":"u04/nodered-dashboards/#creacio-dun-dashboard","title":"Creaci\u00f3 d'un dashboard","text":"<p>Per a crear un dashboard, hem de copiar al flux els nodes que volem que se mostren. Cada node pertany a un tab i a un grup. Els tabs s\u00f3n les pestanyes que apareixen a la part esquerra del dashboard i els grups serveixen per agrupar certs nodes d'una pestanya en un \u00fanic element visual.</p> <p>Anem a fer un exemple senzill creant un node de tipus gauge per mostrar els valors que van entrant al flux, per exemple amb un node random.</p>"},{"location":"u04/nodered-dashboards/#exemple-amb-un-grafic-tipus-gauge-medidor","title":"Exemple amb un gr\u00e0fic tipus gauge (medidor)","text":"<p>1 - Creem un node inject per posar en marxa el flux. Injectar\u00e0 el timestamp cada segon.</p> <p>2 - Creen un node random per a generar un valor aleatori entre -30 i 50. En el nom posarem \"Temperatura\" per poder-lo diferenciar quan tinguem m\u00e9s nodes random. El connectarem amb el node inject.</p> <p>3 - Creem un node gauge per a mostrar el valor de la temperatura. El connectarem amb el node random i li posarem en el camp Label el text \"Temperatura\" i en el tipus seleccionarem Gauge.</p> <p>4 - Hem de definir en quin tab i en quin grup volem que aparega el node gauge. Anem a la secci\u00f3 de propietats i en el camp Group tenim un bot\u00f3 per editar i un altre per afegir un grup nou. Anem a crear un tab que s'anomene Sensors i dins un grup que s'anomene Gr\u00e0fics. Les propietats del node quedarien tal com se veu en la seg\u00fcent imatge.</p> <p></p> <p>5 - Ara ja podem desplegar el flux. Ho fem i no se veu res. Aix\u00f2 \u00e9s perqu\u00e8 per a veure el dashboard hem d'anar a la URL [http://localhost:1881/ui].</p> <p>Recordeu canviar el vostre port si no \u00e9s el 1881, aix\u00ed com la IP si no \u00e9s localhost.</p> <p>6 - A la URL que hem posat, en el men\u00fa de l'esquerra seleccionem el tab Sensors i ens apareixer\u00e0 el gr\u00e0fic. Podem veure com en temps real ens va mostrant les temperatures que van entrant. </p> <p></p>"},{"location":"u04/nodered-dashboards/#afegint-mes-grafics-al-dashboard","title":"Afegint m\u00e9s gr\u00e0fics al dashboard","text":"<p>Si agafem el flux que hem creat, seleccionem tots els nodes i fem copiar-pegar, tindrem un altre flux exactament igual. Ara anem a modificar el node random per generar un valor entre 0 i 100 i li posarem el nom \"Humedad\". Tamb\u00e9 modificarem el node gauge per posar-li el nom \"Humedad\" i dir-li que els valors estaran entre 0 i 100. El nou node gauge tindr\u00e0 el mateix tab i el mateix grup que el primer. </p> <p>El resultat si despleguem i tornem a mostrar el dashboard ser\u00e0 el seg\u00fcent.</p> <p></p> <p>Si provem a posar els dos nodes gauge en grups diferents, se mostrarien en columnes diferents dins del tab Sensors.</p> <p>Si els pos\u00e0rem en dos tabs diferents, tindr\u00edem cada gauge en una pestanya diferent del dashboard.</p> <p></p>"},{"location":"u04/nodered-dashboards/#mes-nodes-de-dashboard","title":"M\u00e9s nodes de dashboard","text":"<p>Per explorar m\u00e9s nodes de tipus dashboard podeu descarregar d'Aules els arxius JSON que trobareu a la carpeta Exemples dashboard. Una vegada carregats en la vostra inst\u00e0ncia de NodeRED, els examinarem i comentarem a classe.</p>"},{"location":"u04/nodered-intermedi/","title":"Node-RED intermedi","text":"<p>Ara que ja sabem com funcionen els nodes i com podem crear un flux de dades senzill, anem a veure com podem fer coses m\u00e9s complexes amb Node-RED. Per fer-ho, analitzarem alguns exemples de fluxos que heu important des d'Aules amb l'arxiu <code>Basic nodes operations</code>.</p>"},{"location":"u04/nodered-intermedi/#nodes-de-sequencies","title":"Nodes de seq\u00fc\u00e8ncies","text":"<p>Els nodes de seq\u00fcencies permeten actuar sobre una seq\u00fc\u00e8ncia de missatges, o crear-ne una de nova. Aix\u00f2 ens permet fer coses com filtrar missatges, dividir-los en parts, o afegir-los a una llista.</p>"},{"location":"u04/nodered-intermedi/#split","title":"Split","text":"<p>El node <code>split</code> permet dividir un missatge en parts. Per exemple, si tenim un missatge amb un text que cont\u00e9 diverses paraules, podem dividir-lo en tantes parts com paraules hi hagi si especifiquem l'espai en blanc com a separador. Aix\u00f2 ens permetr\u00e0 actuar sobre cada paraula de forma independent.</p> <p>A m\u00e9s de l'espai en blanc, podem utilitzar qualsevol altre car\u00e0cter com a separador en l'apartat <code>Split using</code> o <code>Dividir usando</code> del node.</p> <p>A banda de text, tamb\u00e9 podem dividir un array en les seues parts, o un objecte en les seues propietats, tal com podeu veure a la imatge.</p> <p></p>"},{"location":"u04/nodered-intermedi/#join","title":"Join","text":"<p>El node <code>join</code> permet unir les parts d'un missatge en un \u00fanic missatge d'eixida. Per exemple, si tenim un array amb diverses parts, podem unir-les en un sol missatge.</p> <p>Tamb\u00e9 podem treballar amb <code>msg.parts</code>. El funcionament de <code>msg.parts</code> en NodeRED \u00e9s similar al de <code>msg.payload</code>, per\u00f2 en lloc de contenir el valor del missatge, cont\u00e9 informaci\u00f3 sobre la part del missatge que estem tractant. Aix\u00f2 ens permet, per exemple, unir les parts d'un missatge en un ordre diferent al que tenien inicialment. Tamb\u00e9 podem fer que el receptor del missatge espere a que li arriben totes les parts per executar alguna acci\u00f3.</p> <p>Ac\u00ed teniu un exemple d'\u00fas de <code>split</code> i <code>join</code>. El que fa el flux \u00e9s agafar una cadena, dividir-la en paraules, i enviar el resultat per un costat a un node <code>debug</code> que mostrar\u00e0 per pantalla els diferents missatges que li arriben (les diferents paraules), i per altre costat li envia el mateix resultat a un node <code>join</code> que torna a juntar les paraules i les envia a un altre <code>Debug</code> que mostra la frase reconstru\u00efda. </p> <p></p> <p>Una altra utilitat de <code>join</code>, com hem comentat, \u00e9s unificar diferents missatges en un \u00fanic missatge. Se pot fer de manera autom\u00e0tica o manual. Per exemple, si tenim un sensor que ens envia la temperatura i la humitat en dos missatges diferents, podem utilitzar <code>join</code> per unir-los en un sol missatge. Veiem un exemple:</p> <p></p> <p>En este flux, tres nodes <code>inject</code> envien una dada diferent cadascun. Amb la etiqueta <code>topic</code> definim el nom de la propietat del missatge que contindr\u00e0 la dada. Despr\u00e9s, el node <code>Join</code> uneix els tres missatges en un sol missatge, i el node <code>debug</code> mostra el resultat. Fixeu-vos que el node <code>join</code> sap que ha d'esperar fins que li arriben els 3 missatges abans d'unir-los i enviar-los al node <code>debug</code>.</p> <p></p>"},{"location":"u04/nodered-intermedi/#sort","title":"Sort","text":"<p>El node <code>sort</code> permet ordenar les propietats d'un missatge, o una seq\u00fc\u00e8ncia de missatges. L'ordre pot ser ascendent o descendent. Se poden definir molts criteris d'ordenaci\u00f3 diferents, o tamb\u00e9 utilitzar <code>msg.parts</code> per ordenar els missatges. Veiem un exemple molt senzill on el node <code>inject</code> envia un JSON amb un array de n\u00fameros, i el node <code>sort</code> els ordena. En les propietats del node <code>sort</code> podem veure com estem utilitzant com a clau d'ordenaci\u00f3 el valor de l'element. </p> <p></p>"},{"location":"u04/nodered-intermedi/#batch","title":"Batch","text":"<p>El node <code>batch</code> permet crear seq\u00fc\u00e8ncies de missatges seguint certes regles. Hi ha tres formes de seq\u00fcenciar els missatges:</p> <ul> <li>per quantitat de missatges: agrupa missatges en seq\u00fc\u00e8ncies d'una longitud determinada</li> <li>per intervals de temps: agrupa els missatges que arriben en un determinat interval de temps</li> <li>concatenar seq\u00fc\u00e8ncies: agrupa distintes seq\u00fc\u00e8ncies en una sola</li> </ul> <p>A continuaci\u00f3 podeu veure un exemple on els nodes <code>join</code>, <code>batch</code>, <code>split</code> i <code>sort</code> treballen de manera conjunta amb unes seq\u00fc\u00e8ncies de n\u00fameros que envien dos nodes <code>inject</code>.</p> <p></p>"},{"location":"u04/nodered-intermedi/#nodes-de-funcio","title":"Nodes de funci\u00f3","text":"<p>Els nodes de funci\u00f3 ens permeten executar codi JavaScript o fer altres operacions sobre els missatges que passen pel flux. Aix\u00f2 ens permet fer moltes coses, com modificar el missatge, filtrar-lo, o crear-ne de nous. Hem vist abans un exemple amb el qual convertiem un <code>timestamp</code> en una data llegible. Aix\u00f2 ho hem fet amb el node <code>function</code></p> <p>Exemple igualment senzill: tenim un sensor que ens envia la temperatura i la humitat en dos missatges diferents. Volem que si la temperatura \u00e9s superior a 30\u00baC, s'envie un missatge d'alerta. Per fer-ho, utilitzarem un node <code>function</code> que comprovar\u00e0 si la temperatura \u00e9s superior a 30\u00baC, i si ho \u00e9s, enviar\u00e0 un missatge d'alerta.</p> <p>La funci\u00f3 seria aix\u00ed:</p> <pre><code>if (msg.payload.temperature &gt; 30) {\n    return {payload: \"Alerta: temperatura superior a 30\u00baC\"};\n}\n</code></pre> <p>De totes maneres, a banda del node <code>function</code> hi ha altres dins del grup Funci\u00f3n. Anem a veure alguns dels m\u00e9s importants.</p>"},{"location":"u04/nodered-intermedi/#switch","title":"Switch","text":"<p>El node <code>switch</code> ens permet fer bifurcacions en el flux segons el valor d'una propietat del missatge. Per exemple, si tenim un sensor que ens envia la temperatura i la humitat, podem utilitzar <code>switch</code> per enviar un missatge d'alerta si la temperatura \u00e9s superior a 30\u00baC, i un altre si la humitat \u00e9s superior al 70%.</p> <p>Per fer aix\u00f2 anem a necessitar tamb\u00e9 el node <code>Change</code>.</p>"},{"location":"u04/nodered-intermedi/#change","title":"Change","text":"<p>El node <code>change</code> ens permet canviar les propietats d'un missatge. Per exemple, el nostre cas anterior, podem afegir una propietat <code>alert</code> al missatge si la temperatura \u00e9s superior a 30\u00baC o si la humitat \u00e9s superior al 70%. Tamb\u00e9 podem canviar el valor d'una propietat, o eliminar-la. Fins i tot podem, si ens interessa, modificar el valor de <code>Payload</code>.</p> <p>El node <code>Change</code> del nostre exemple quedaria aix\u00ed:</p> <p>Ara podem combinar els nodes <code>Switch</code> i <code>Change</code> per enviar un missatge d'alerta si la temperatura \u00e9s superior a 30\u00baC o si la humitat \u00e9s superior al 70%, o simplement mostrar els valors si s\u00f3n normals. </p> <p></p> <p>El <code>Switch</code> de la temperatura t\u00e9 dues eixides: </p> <ul> <li>la 1 si el valor \u00e9s major que 30, i la 2 si no ho \u00e9s. La 1 porta al node <code>Change</code> que afegeix la propietat <code>alert</code> al missatge, i finalment el node <code>debug</code> mostra l'alerta. La 2 porta directament al node <code>debug</code> que mostra el missatge transformat en un JSON llegible.</li> </ul> <p></p> <p>El <code>Switch</code> de la humitat t\u00e9 dues eixides:</p> <ul> <li>la 1 si el valor \u00e9s major que 70, i la 2 si no ho \u00e9s. La 1 porta al node <code>Change</code> que afegeix la propietat <code>alert</code> al missatge, i finalment el node <code>debug</code> mostra l'alerta. La 2 porta directament al node <code>debug</code> que mostra el missatge transformat en un JSON llegible.</li> </ul> <p>L'esquema \u00e9s el mateix que hem vist per la temperatura.</p>"},{"location":"u04/nodered-intermedi/#random","title":"Random","text":"<p>El node <code>random</code> ens permet generar valors aleatoris. Aix\u00f2 pot ser \u00fatil per simular sensors, o per fer proves, com anem a fer a continuaci\u00f3. </p> <p>En l'exemple anterior de la temperatura i la humitat, si volem saber qu\u00e8 passa al canviar els valors d'entrada hem d'editar el node <code>inject</code> cada vegada. Utilitzant un node <code>random</code>, podem fer que el node d'injecci\u00f3 li envie una senyal al <code>random</code> i que este genere els valors aleat\u00f2riament. A m\u00e9s, com sabem, podem saber que el node <code>inject</code> envie una senyal cada cert temps per a que se generen els valors.</p> <p>El nostre exemple anterior, utilitzant nodes <code>random</code> per generar els valors, quedaria aix\u00ed:</p> <p></p> <p>El node <code>random</code> nom\u00e9s genera valors num\u00e8rics. Per a generar altres tipus de valors, podem utilitzar el node <code>data-generator</code>, que segurament haurem d'instal\u00b7lar des de la paleta de la dreta. </p> <p>Amb <code>data-generator</code> podem generar dades amb sentit, textos que tinguen un significat. Per exemple, li podem dir que genere noms ficticis, adreces i poblacions inventades, i tamb\u00e9 numeros que estiguen dins d'un rang determinat. Ac\u00ed teniu un exemple de generador de dades d'una persona:</p> <p></p> <p></p> <p></p>"}]}